diff -burNpd binutils-2.25.1.orig/bfd/archures.c binutils-2.25.1.PS2/bfd/archures.c
--- binutils-2.25.1.orig/bfd/archures.c	2014-10-14 02:32:02.000000000 -0500
+++ binutils-2.25.1.PS2/bfd/archures.c	2019-12-27 15:50:33.275275780 -0600
@@ -190,6 +190,11 @@ DESCRIPTION
 .#define bfd_mach_mipsisa64r3           66
 .#define bfd_mach_mipsisa64r5           68
 .#define bfd_mach_mipsisa64r6           69
+.#define bfd_mach_dvp_dma		42000
+.#define bfd_mach_dvp_vif		42001
+.#define bfd_mach_dvp_vu		42002
+.#define bfd_mach_dvp_gif		42003
+.#define bfd_mach_dvp_p(mach) ((mach) >= 42000 && (mach) <= 42003)
 .#define bfd_mach_mips_micromips        96
 .  bfd_arch_i386,      {* Intel 386 *}
 .#define bfd_mach_i386_intel_syntax	(1 << 0)
diff -burNpd binutils-2.25.1.orig/bfd/bfd-in2.h binutils-2.25.1.PS2/bfd/bfd-in2.h
--- binutils-2.25.1.orig/bfd/bfd-in2.h	2015-07-21 03:20:58.000000000 -0500
+++ binutils-2.25.1.PS2/bfd/bfd-in2.h	2019-12-27 15:50:33.282221791 -0600
@@ -1980,6 +1980,11 @@ enum bfd_architecture
 #define bfd_mach_mipsisa64r3           66
 #define bfd_mach_mipsisa64r5           68
 #define bfd_mach_mipsisa64r6           69
+#define bfd_mach_dvp_dma               42000
+#define bfd_mach_dvp_vif               42001
+#define bfd_mach_dvp_vu                42002
+#define bfd_mach_dvp_gif               42003
+#define bfd_mach_dvp_p(mach) ((mach) >= 42000 && (mach) <= 42003)
 #define bfd_mach_mips_micromips        96
   bfd_arch_i386,      /* Intel 386 */
 #define bfd_mach_i386_intel_syntax     (1 << 0)
@@ -3069,6 +3074,22 @@ to compensate for the borrow when the lo
   BFD_RELOC_FRV_TLSOFF_RELAX,
   BFD_RELOC_FRV_TLSMOFF,
 
+/* MIPS DVP Relocations. 
+This is an 11-bit pc relative reloc.  The recorded address is for the 
+lower instruction word, and the value is in 128 bit units.  */
+  BFD_RELOC_MIPS_DVP_11_PCREL ,
+
+/* This is a 27 bit address left shifted by 4.  */
+  BFD_RELOC_MIPS_DVP_27_S4 ,
+
+/* This is the 11 bit offset operand of ilw/stw instructions 
+left shifted by 4.  */
+  BFD_RELOC_MIPS_DVP_11_S4 ,
+
+/* This is the 15 bit unsigned immediate operand of the iaddiu instruction 
+left shifted by 3.  */
+  BFD_RELOC_MIPS_DVP_U15_S3 ,
+
 
 /* This is a 24bit GOT-relative reloc for the mn10300.  */
   BFD_RELOC_MN10300_GOTOFF24,
diff -burNpd binutils-2.25.1.orig/bfd/config.bfd binutils-2.25.1.PS2/bfd/config.bfd
--- binutils-2.25.1.orig/bfd/config.bfd	2014-10-14 02:32:02.000000000 -0500
+++ binutils-2.25.1.PS2/bfd/config.bfd	2019-12-27 15:50:33.284580630 -0600
@@ -418,6 +418,11 @@ case "${targ}" in
     targ_defvec=d30v_elf32_vec
     ;;
 
+  dvp-*-*)
+    targ_defvec=mips_elf32_le_vec
+    targ_selvecs="mips_elf64_le_vec"
+    ;;
+
   epiphany-*-elf)
     targ_defvec=epiphany_elf32_vec
     ;;
@@ -1002,6 +1007,10 @@ case "${targ}" in
     targ_selvecs="mips_elf32_le_vec mips_ecoff_be_vec mips_ecoff_le_vec"
     ;;
 #endif
+  mips*-*-irx*)
+    targ_defvec=mips_elf32_le_vec
+    targ_selvecs="mips_elf32_be_vec"
+    ;;
   mips*-sgi-* | mips*-*-bsd*)
     targ_defvec=mips_ecoff_be_vec
     targ_selvecs=mips_ecoff_le_vec
diff -burNpd binutils-2.25.1.orig/bfd/configure binutils-2.25.1.PS2/bfd/configure
--- binutils-2.25.1.orig/bfd/configure	2015-07-21 08:42:55.000000000 -0500
+++ binutils-2.25.1.PS2/bfd/configure	2019-12-27 15:50:33.294943175 -0600
@@ -15250,6 +15250,8 @@ for i in $selvecs ; do
 done
 selvecs="$f"
 
+# dvp is really mips, but we need to distinguish it from mips for opcodes
+selarchs=`echo $selarchs | sed -e s/dvp/mips/g`
 
 # uniq the associated vectors in all the configured targets.
 f=""
diff -burNpd binutils-2.25.1.orig/bfd/configure.ac binutils-2.25.1.PS2/bfd/configure.ac
--- binutils-2.25.1.orig/bfd/configure.ac	2014-10-14 02:32:02.000000000 -0500
+++ binutils-2.25.1.PS2/bfd/configure.ac	2019-12-27 15:50:33.297255548 -0600
@@ -651,6 +651,8 @@ for i in $selvecs ; do
 done
 selvecs="$f"
 
+# dvp is really mips, but we need to distinguish it from mips for opcodes  
+selarchs=`echo $selarchs | sed -e s/dvp/mips/g`
 
 # uniq the associated vectors in all the configured targets.
 f=""
diff -burNpd binutils-2.25.1.orig/bfd/cpu-mips.c binutils-2.25.1.PS2/bfd/cpu-mips.c
--- binutils-2.25.1.orig/bfd/cpu-mips.c	2014-10-14 02:32:02.000000000 -0500
+++ binutils-2.25.1.PS2/bfd/cpu-mips.c	2019-12-27 15:50:33.298305984 -0600
@@ -95,6 +95,10 @@ enum
   I_mipsisa64r3,
   I_mipsisa64r5,
   I_mipsisa64r6,
+  I_dvp_dma,
+  I_dvp_vif,
+  I_dvp_vu,
+  I_dvp_gif,
   I_sb1,
   I_loongson_2e,
   I_loongson_2f,
@@ -145,6 +149,10 @@ static const bfd_arch_info_type arch_inf
   N (64, 64, bfd_mach_mipsisa64r3,"mips:isa64r3", FALSE, NN(I_mipsisa64r3)),
   N (64, 64, bfd_mach_mipsisa64r5,"mips:isa64r5", FALSE, NN(I_mipsisa64r5)),
   N (64, 64, bfd_mach_mipsisa64r6,"mips:isa64r6", FALSE, NN(I_mipsisa64r6)),
+  N (32, 32, bfd_mach_dvp_dma, "dvp:dma",         FALSE, NN(I_dvp_dma)),
+  N (32, 32, bfd_mach_dvp_vif, "dvp:vif",         FALSE, NN(I_dvp_vif)),
+  N (32, 32, bfd_mach_dvp_vu, "dvp:vu",           FALSE, NN(I_dvp_vu)),
+  N (32, 32, bfd_mach_dvp_gif, "dvp:gif",         FALSE, NN(I_dvp_gif)),
   N (64, 64, bfd_mach_mips_sb1, "mips:sb1",       FALSE, NN(I_sb1)),
   N (64, 64, bfd_mach_mips_loongson_2e, "mips:loongson_2e",       FALSE, NN(I_loongson_2e)),
   N (64, 64, bfd_mach_mips_loongson_2f, "mips:loongson_2f",       FALSE, NN(I_loongson_2f)),
diff -burNpd binutils-2.25.1.orig/bfd/elf.c binutils-2.25.1.PS2/bfd/elf.c
--- binutils-2.25.1.orig/bfd/elf.c	2015-07-21 03:20:58.000000000 -0500
+++ binutils-2.25.1.PS2/bfd/elf.c	2019-12-27 15:50:33.307182088 -0600
@@ -2517,7 +2517,7 @@ _bfd_elf_make_section_from_phdr (bfd *ab
       newsect->filepos = hdr->p_offset;
       newsect->flags |= SEC_HAS_CONTENTS;
       newsect->alignment_power = bfd_log2 (hdr->p_align);
-      if (hdr->p_type == PT_LOAD)
+      if (hdr->p_type == PT_LOAD || hdr->p_type == PT_MIPS_IRXHDR)
 	{
 	  newsect->flags |= SEC_ALLOC;
 	  newsect->flags |= SEC_LOAD;
@@ -2555,7 +2555,7 @@ _bfd_elf_make_section_from_phdr (bfd *ab
       if (align == 0 || align > hdr->p_align)
 	align = hdr->p_align;
       newsect->alignment_power = bfd_log2 (align);
-      if (hdr->p_type == PT_LOAD)
+      if (hdr->p_type == PT_LOAD || hdr->p_type == PT_MIPS_IRXHDR)
 	{
 	  /* Hack for gdb.  Segments that have not been modified do
 	     not have their contents written to a core file, on the
@@ -4639,7 +4639,7 @@ assign_file_positions_for_load_sections
       else
 	p->p_paddr = m->sections[0]->lma - m->p_vaddr_offset;
 
-      if (p->p_type == PT_LOAD
+      if ((p->p_type == PT_LOAD || p->p_type == PT_MIPS_IRXHDR)
 	  && (abfd->flags & D_PAGED) != 0)
 	{
 	  /* p_align in demand paged PT_LOAD segments effectively stores
@@ -4664,7 +4664,7 @@ assign_file_positions_for_load_sections
 
       no_contents = FALSE;
       off_adjust = 0;
-      if (p->p_type == PT_LOAD
+      if ((p->p_type == PT_LOAD || p->p_type == PT_MIPS_IRXHDR)
 	  && m->count > 0)
 	{
 	  bfd_size_type align;
@@ -4790,7 +4790,7 @@ assign_file_positions_for_load_sections
 	    }
 	}
 
-      if (p->p_type == PT_LOAD
+      if ((p->p_type == PT_LOAD || p->p_type == PT_MIPS_IRXHDR)
 	  || (p->p_type == PT_NOTE && bfd_get_format (abfd) == bfd_core))
 	{
 	  if (!m->includes_filehdr && !m->includes_phdrs)
@@ -4822,6 +4822,7 @@ assign_file_positions_for_load_sections
 	  align = (bfd_size_type) 1 << bfd_get_section_alignment (abfd, sec);
 
 	  if ((p->p_type == PT_LOAD
+		   || p->p_type == PT_MIPS_IRXHDR
 	       || p->p_type == PT_TLS)
 	      && (this_hdr->sh_type != SHT_NOBITS
 		  || ((this_hdr->sh_flags & SHF_ALLOC) != 0
@@ -4884,7 +4885,7 @@ assign_file_positions_for_load_sections
 	    }
 	  else
 	    {
-	      if (p->p_type == PT_LOAD)
+	      if (p->p_type == PT_LOAD || p->p_type == PT_MIPS_IRXHDR)
 		{
 		  this_hdr->sh_offset = sec->filepos = off;
 		  if (this_hdr->sh_type != SHT_NOBITS)
@@ -4928,7 +4929,7 @@ assign_file_positions_for_load_sections
 
 	      if (align > p->p_align
 		  && !m->p_align_valid
-		  && (p->p_type != PT_LOAD
+		  && ((p->p_type != PT_LOAD && p->p_type != PT_MIPS_IRXHDR)
 		      || (abfd->flags & D_PAGED) == 0))
 		p->p_align = align;
 	    }
@@ -4947,7 +4948,8 @@ assign_file_positions_for_load_sections
 
       /* Check that all sections are in a PT_LOAD segment.
 	 Don't check funky gdb generated core files.  */
-      if (p->p_type == PT_LOAD && bfd_get_format (abfd) != bfd_core)
+      if ((p->p_type == PT_LOAD || p->p_type == PT_MIPS_IRXHDR)
+		  && bfd_get_format (abfd) != bfd_core)
 	{
 	  bfd_boolean check_vma = TRUE;
 
@@ -5060,7 +5062,7 @@ assign_file_positions_for_non_load_secti
   for (m = elf_seg_map (abfd), p = phdrs; m != NULL; m = m->next, p++)
     {
       ++count;
-      if (p->p_type != PT_LOAD)
+      if (p->p_type != PT_LOAD && p->p_type != PT_MIPS_IRXHDR)
 	continue;
 
       if (m->includes_filehdr)
@@ -5142,7 +5144,7 @@ assign_file_positions_for_non_load_secti
 		   lm != NULL;
 		   lm = lm->next, lp++)
 		{
-		  if (lp->p_type == PT_LOAD
+		  if ((lp->p_type == PT_LOAD || lp->p_type == PT_MIPS_IRXHDR)
 		      && lp->p_vaddr < link_info->relro_end
 		      && lm->count != 0
 		      && lm->sections[0]->vma >= link_info->relro_start)
@@ -5157,7 +5159,7 @@ assign_file_positions_for_non_load_secti
 		 library, but we need to use the same linker logic.  */
 	      for (lp = phdrs; lp < phdrs + count; ++lp)
 		{
-		  if (lp->p_type == PT_LOAD
+		  if ((lp->p_type == PT_LOAD || lp->p_type == PT_MIPS_IRXHDR)
 		      && lp->p_paddr == p->p_paddr)
 		    break;
 		}
@@ -5198,7 +5200,7 @@ assign_file_positions_for_non_load_secti
 	}
       else if (m->count != 0)
 	{
-	  if (p->p_type != PT_LOAD
+	  if ((p->p_type != PT_LOAD && p->p_type != PT_MIPS_IRXHDR)
 	      && (p->p_type != PT_NOTE
 		  || bfd_get_format (abfd) != bfd_core))
 	    {
diff -burNpd binutils-2.25.1.orig/bfd/elf32-mips.c binutils-2.25.1.PS2/bfd/elf32-mips.c
--- binutils-2.25.1.orig/bfd/elf32-mips.c	2015-07-21 03:20:58.000000000 -0500
+++ binutils-2.25.1.PS2/bfd/elf32-mips.c	2019-12-27 15:50:33.301170569 -0600
@@ -53,6 +53,8 @@ static bfd_reloc_status_type gprel32_wit
   (bfd *, asymbol *, arelent *, asection *, bfd_boolean, void *, bfd_vma);
 static bfd_reloc_status_type mips_elf_gprel32_reloc
   (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
+static bfd_reloc_status_type dvp_u15_s3_reloc
+  (bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **);
 static bfd_reloc_status_type mips32_64bit_reloc
   (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
 static reloc_howto_type *bfd_elf32_bfd_reloc_type_lookup
@@ -1547,6 +1549,66 @@ static reloc_howto_type elf_mips_gnu_rel
 	 0xffff,		/* dst_mask */
 	 TRUE);			/* pcrel_offset */
 
+/* DVP relocations.
+   Note that partial_inplace and pcrel_offset are backwards from the 
+   mips port.  This is intentional as it seems more reasonable.  */
+static reloc_howto_type elf_mips_dvp_11_pcrel_howto =
+  HOWTO (R_MIPS_DVP_11_PCREL,   /* type */
+         3,                     /* rightshift */
+         2,                     /* size (0 = byte, 1 = short, 2 = long) */
+         11,                    /* bitsize */
+         TRUE,                  /* pc_relative */
+         0,                     /* bitpos */
+         complain_overflow_signed, /* complain_on_overflow */
+         bfd_elf_generic_reloc, /* special_function */
+         "R_MIPS_DVP_11_PCREL", /* name */
+         FALSE,                 /* partial_inplace */
+         0x7ff,                 /* src_mask */
+         0x7ff,                 /* dst_mask */
+         TRUE);                 /* pcrel_offset */
+static reloc_howto_type elf_mips_dvp_27_s4_howto =
+  HOWTO (R_MIPS_DVP_27_S4,      /* type */
+         4,                     /* rightshift */
+         2,                     /* size (0 = byte, 1 = short, 2 = long) */
+         27,                    /* bitsize */
+         FALSE,                 /* pc_relative */
+         4,                     /* bitpos */
+         complain_overflow_unsigned, /* complain_on_overflow */
+         bfd_elf_generic_reloc, /* special_function */
+         "R_MIPS_DVP_27_S4",    /* name */
+         FALSE,                 /* partial_inplace */
+         0x7ffffff0,            /* src_mask */
+         0x7ffffff0,            /* dst_mask */
+         FALSE);                /* pcrel_offset */
+static reloc_howto_type elf_mips_dvp_11_s4_howto =
+  HOWTO (R_MIPS_DVP_11_S4,      /* type */
+         4,                     /* rightshift */
+         2,                     /* size (0 = byte, 1 = short, 2 = long) */
+         11,                    /* bitsize */
+         FALSE,                 /* pc_relative */
+         0,                     /* bitpos */
+         complain_overflow_signed, /* complain_on_overflow */
+         bfd_elf_generic_reloc, /* special_function */
+         "R_MIPS_DVP_11_S4",    /* name */
+         FALSE,                 /* partial_inplace */
+         0x03ff,                /* src_mask */
+         0x03ff,                /* dst_mask */
+         FALSE);                /* pcrel_offset */
+static reloc_howto_type elf_mips_dvp_u15_s3_howto =
+  HOWTO (R_MIPS_DVP_U15_S3,     /* type */
+         3,                     /* rightshift */
+         2,                     /* size (0 = byte, 1 = short, 2 = long) */
+         15,                    /* bitsize */
+         FALSE,                 /* pc_relative */
+         0,                     /* bitpos */
+         complain_overflow_unsigned, /* complain_on_overflow */
+         dvp_u15_s3_reloc,      /* special_function */
+         "R_MIPS_DVP_U15_S3",   /* name */
+         FALSE,                 /* partial_inplace */
+         0xf03ff,               /* src_mask */
+         0xf03ff,               /* dst_mask */
+         FALSE);                /* pcrel_offset */
+
 /* 32 bit pc-relative.  This was a GNU extension used by embedded-PIC.
    It was co-opted by mips-linux for exception-handling data.  It is no
    longer used, but should continue to be supported by the linker for
@@ -1954,6 +2016,58 @@ mips16_gprel_reloc (bfd *abfd, arelent *
   return ret;
 }
 
+/* Handle a dvp R_MIPS_DVP_U15_S3 reloc. 
+   This is needed because the bits aren't contiguous.  */
+         
+static bfd_reloc_status_type
+dvp_u15_s3_reloc (abfd, reloc_entry, symbol, data, input_section,
+                  output_bfd, error_message)
+     bfd *abfd;
+     arelent *reloc_entry;
+     asymbol *symbol;
+     PTR data;
+     asection *input_section;
+     bfd *output_bfd;
+     char **error_message ATTRIBUTE_UNUSED;
+{
+  bfd_vma relocation;
+  bfd_vma x;
+
+  /* If we're relocating, and this is an external symbol with no 
+     addend, we don't want to change anything.  We will only have an 
+     addend if this is a newly created reloc, not read from an ELF 
+     file.  See bfd_elf_generic_reloc.  */
+  if (output_bfd != NULL
+      && (symbol->flags & BSF_SECTION_SYM) == 0
+      /* partial_inplace is FALSE, so this test always succeeds, 
+         but for clarity and consistency with bfd_elf_generic_reloc 
+         this is left as is.  */
+      && (! reloc_entry->howto->partial_inplace
+          || reloc_entry->addend == 0))
+    {
+      reloc_entry->address += input_section->output_offset;
+      return bfd_reloc_ok;
+    }
+    
+  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
+    return bfd_reloc_outofrange;
+
+  relocation = (symbol->value
+                + symbol->section->output_section->vma
+                + symbol->section->output_offset);
+  relocation += reloc_entry->addend;
+  relocation >>= 3;
+
+  x = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
+  x |= (((relocation & 0x7800) << 10)
+        | (relocation & 0x7ff));
+  bfd_put_32 (abfd, x, (bfd_byte *) data + reloc_entry->address);
+
+  if (relocation & ~(bfd_vma) 0x7fff)
+    return bfd_reloc_overflow;
+  return bfd_reloc_ok;
+}
+
 /* A mapping from BFD reloc types to MIPS ELF reloc types.  */
 
 struct elf_reloc_map {
@@ -2114,6 +2228,14 @@ bfd_elf32_bfd_reloc_type_lookup (bfd *ab
       else
 	return &howto_table[(int) R_MIPS_32];
 
+    case BFD_RELOC_MIPS_DVP_11_PCREL:
+      return &elf_mips_dvp_11_pcrel_howto;
+    case BFD_RELOC_MIPS_DVP_27_S4:
+      return &elf_mips_dvp_27_s4_howto;
+    case BFD_RELOC_MIPS_DVP_11_S4:
+      return &elf_mips_dvp_11_s4_howto;
+    case BFD_RELOC_MIPS_DVP_U15_S3:
+      return &elf_mips_dvp_u15_s3_howto;
     case BFD_RELOC_VTABLE_INHERIT:
       return &elf_mips_gnu_vtinherit_howto;
     case BFD_RELOC_VTABLE_ENTRY:
@@ -2185,6 +2307,14 @@ mips_elf32_rtype_to_howto (unsigned int
 {
   switch (r_type)
     {
+    case R_MIPS_DVP_11_PCREL:
+      return &elf_mips_dvp_11_pcrel_howto;
+    case R_MIPS_DVP_27_S4:
+      return &elf_mips_dvp_27_s4_howto;
+    case R_MIPS_DVP_11_S4:
+      return &elf_mips_dvp_11_s4_howto;
+    case R_MIPS_DVP_U15_S3:
+      return &elf_mips_dvp_u15_s3_howto;
     case R_MIPS_GNU_VTINHERIT:
       return &elf_mips_gnu_vtinherit_howto;
     case R_MIPS_GNU_VTENTRY:
diff -burNpd binutils-2.25.1.orig/bfd/elflink.c binutils-2.25.1.PS2/bfd/elflink.c
--- binutils-2.25.1.orig/bfd/elflink.c	2015-07-21 03:20:58.000000000 -0500
+++ binutils-2.25.1.PS2/bfd/elflink.c	2019-12-27 15:50:33.313236378 -0600
@@ -9969,6 +9969,15 @@ elf_link_input_bfd (struct elf_final_lin
 
 		  last_offset = irela->r_offset;
 
+		  /* IRX modules need the relocations, but symbols may be stripped. */
+		  if (elf_elfheader(output_bfd)->e_type == ET_IRX
+		    && flinfo->info->strip == strip_all)
+		  {
+		    irela->r_info = ELF32_R_INFO(STN_UNDEF, ELF32_R_TYPE(irela->r_info));
+		    *rel_hash = NULL;
+		    continue;
+		  }
+
 		  r_symndx = irela->r_info >> r_sym_shift;
 		  if (r_symndx == STN_UNDEF)
 		    continue;
diff -burNpd binutils-2.25.1.orig/bfd/elfxx-mips.c binutils-2.25.1.PS2/bfd/elfxx-mips.c
--- binutils-2.25.1.orig/bfd/elfxx-mips.c	2015-07-21 03:20:58.000000000 -0500
+++ binutils-2.25.1.PS2/bfd/elfxx-mips.c	2019-12-27 15:50:33.322407348 -0600
@@ -7051,6 +7051,10 @@ _bfd_mips_elf_section_from_shdr (bfd *ab
      probably get away with this.  */
   switch (hdr->sh_type)
     {
+    case SHT_IOPMOD:
+      if (strcmp(name, ".iopmod") != 0)
+	return FALSE;
+      break;
     case SHT_MIPS_LIBLIST:
       if (strcmp (name, ".liblist") != 0)
 	return FALSE;
@@ -7232,7 +7236,27 @@ _bfd_mips_elf_fake_sections (bfd *abfd,
 {
   const char *name = bfd_get_section_name (abfd, sec);
 
-  if (strcmp (name, ".liblist") == 0)
+  if (strcmp(name, ".iopmod") == 0)
+   {
+      /* Verify that this bfd is going to be an IRX, and not an object
+	     file or a rogue elf with an .iopmod section by looking for
+	     the PT_MIPS_IRXHDR program header.  */
+	  struct elf_segment_map *m;
+
+	  for (m = elf_seg_map(abfd); m != NULL; m = m->next)
+	  {
+		if (m->p_type == PT_MIPS_IRXHDR)
+	    {
+		  /* Mark the file as an IRX.  */
+		  elf_elfheader(abfd)->e_type = ET_IRX;
+		  /* Setup the section type and flags.  */
+		  hdr->sh_type = SHT_IOPMOD;
+		  hdr->sh_addr = 0;
+		  hdr->sh_flags &= ~(SHF_ALLOC | SHF_WRITE | SHF_EXECINSTR);
+	    }
+	  }
+    }
+  else if (strcmp (name, ".liblist") == 0)
     {
       hdr->sh_type = SHT_MIPS_LIBLIST;
       hdr->sh_info = sec->size / sizeof (Elf32_Lib);
diff -burNpd binutils-2.25.1.orig/bfd/libbfd.h binutils-2.25.1.PS2/bfd/libbfd.h
--- binutils-2.25.1.orig/bfd/libbfd.h	2015-07-21 03:20:58.000000000 -0500
+++ binutils-2.25.1.PS2/bfd/libbfd.h	2019-12-27 15:50:33.324717773 -0600
@@ -1230,6 +1230,10 @@ static const char *const bfd_reloc_code_
   "BFD_RELOC_FRV_GETTLSOFF_RELAX",
   "BFD_RELOC_FRV_TLSOFF_RELAX",
   "BFD_RELOC_FRV_TLSMOFF",
+  "BFD_RELOC_MIPS_DVP_11_PCREL ",
+  "BFD_RELOC_MIPS_DVP_27_S4 ",
+  "BFD_RELOC_MIPS_DVP_11_S4 ",
+  "BFD_RELOC_MIPS_DVP_U15_S3 ",
 
   "BFD_RELOC_MN10300_GOTOFF24",
   "BFD_RELOC_MN10300_GOT32",
diff -burNpd binutils-2.25.1.orig/bfd/reloc.c binutils-2.25.1.PS2/bfd/reloc.c
--- binutils-2.25.1.orig/bfd/reloc.c	2015-07-21 03:20:58.000000000 -0500
+++ binutils-2.25.1.PS2/bfd/reloc.c	2019-12-27 15:50:33.328227250 -0600
@@ -2536,6 +2536,27 @@ ENUMX
 ENUMDOC
   Fujitsu Frv Relocations.
 COMMENT
+ENUM
+  BFD_RELOC_MIPS_DVP_11_PCREL 
+ENUMDOC
+  MIPS DVP Relocations. 
+  This is an 11-bit pc relative reloc.  The recorded address is for the 
+  lower instruction word, and the value is in 128 bit units. 
+ENUM
+  BFD_RELOC_MIPS_DVP_27_S4 
+ENUMDOC
+  This is a 27 bit address left shifted by 4. 
+ENUM
+  BFD_RELOC_MIPS_DVP_11_S4 
+ENUMDOC
+  This is the 11 bit offset operand of ilw/stw instructions 
+  left shifted by 4. 
+ENUM
+  BFD_RELOC_MIPS_DVP_U15_S3 
+ENUMDOC
+  This is the 15 bit unsigned immediate operand of the iaddiu instruction 
+  left shifted by 3. 
+COMMENT
 
 ENUM
   BFD_RELOC_MN10300_GOTOFF24
diff -burNpd binutils-2.25.1.orig/config.sub binutils-2.25.1.PS2/config.sub
--- binutils-2.25.1.orig/config.sub	2014-10-14 02:32:02.000000000 -0500
+++ binutils-2.25.1.PS2/config.sub	2019-12-27 15:50:33.330293959 -0600
@@ -259,6 +259,7 @@ case $basic_machine in
 	| bfin \
 	| c4x | c8051 | clipper \
 	| d10v | d30v | dlx | dsp16xx \
+	| dvp \
 	| epiphany \
 	| fido | fr30 | frv \
 	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
@@ -759,6 +760,10 @@ case $basic_machine in
 		basic_machine=i386-unknown
 		os=-vsta
 		;;
+	iop)
+		basic_machine=mipsel-scei
+		os=-irx
+		;;
 	iris | iris4d)
 		basic_machine=mips-sgi
 		case $os in
@@ -814,6 +819,10 @@ case $basic_machine in
 		basic_machine=m68k-atari
 		os=-mint
 		;;
+	dvp)
+		basic_machine=dvp-scei
+		os=-elf
+		;;
 	mips3*-*)
 		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
 		;;
@@ -1384,7 +1393,8 @@ case $os in
 	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
 	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
 	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
-	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es* | -tirtos*)
+	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es* | -tirtos* \
+		  | -irx*)
 	# Remember, each alternative MUST END IN *, to match a version number.
 		;;
 	-qnx*)
diff -burNpd binutils-2.25.1.orig/configure binutils-2.25.1.PS2/configure
--- binutils-2.25.1.orig/configure	2014-10-14 02:32:02.000000000 -0500
+++ binutils-2.25.1.PS2/configure	2019-12-27 15:50:33.337710960 -0600
@@ -2759,7 +2759,7 @@ host_libs="intl libiberty opcodes bfd re
 # binutils, gas and ld appear in that order because it makes sense to run
 # "make check" in that particular order.
 # If --enable-gold is used, "gold" may replace "ld".
-host_tools="texinfo flex bison binutils gas ld fixincludes gcc cgen sid sim gdb gprof etc expect dejagnu m4 utils guile fastjar gnattools"
+host_tools="flex bison binutils gas ld fixincludes gcc cgen sid sim gdb gprof etc expect dejagnu m4 utils guile fastjar gnattools"
 
 # libgcj represents the runtime libraries only used by gcj.
 libgcj="target-libffi \
diff -burNpd binutils-2.25.1.orig/configure.ac binutils-2.25.1.PS2/configure.ac
--- binutils-2.25.1.orig/configure.ac	2015-07-21 08:46:03.000000000 -0500
+++ binutils-2.25.1.PS2/configure.ac	2019-12-27 15:50:33.341455253 -0600
@@ -989,6 +989,9 @@ case "${target}" in
   d30v-*-*)
     noconfigdirs="$noconfigdirs gdb"
     ;;
+  dvp-*-*)
+    noconfigdirs="$noconfigdirs ld"
+    ;;
   fr30-*-elf*)
     noconfigdirs="$noconfigdirs gdb"
     ;;
diff -burNpd binutils-2.25.1.orig/gas/Makefile.am binutils-2.25.1.PS2/gas/Makefile.am
--- binutils-2.25.1.orig/gas/Makefile.am	2014-10-14 02:32:02.000000000 -0500
+++ binutils-2.25.1.PS2/gas/Makefile.am	2019-12-27 15:50:33.356155109 -0600
@@ -136,6 +136,7 @@ TARGET_CPU_CFILES = \
 	config/tc-d10v.c \
 	config/tc-d30v.c \
 	config/tc-dlx.c \
+	config/tc-dvp.c \
 	config/tc-epiphany.c \
 	config/tc-fr30.c \
 	config/tc-frv.c \
@@ -208,6 +209,7 @@ TARGET_CPU_HFILES = \
 	config/tc-d10v.h \
 	config/tc-d30v.h \
 	config/tc-dlx.h \
+	config/tc-dvp.h \
 	config/tc-epiphany.h \
 	config/tc-fr30.h \
 	config/tc-frv.h \
diff -burNpd binutils-2.25.1.orig/gas/Makefile.in binutils-2.25.1.PS2/gas/Makefile.in
--- binutils-2.25.1.orig/gas/Makefile.in	2014-10-14 02:32:02.000000000 -0500
+++ binutils-2.25.1.PS2/gas/Makefile.in	2019-12-27 15:50:33.359611874 -0600
@@ -405,6 +405,7 @@ TARGET_CPU_CFILES = \
 	config/tc-d10v.c \
 	config/tc-d30v.c \
 	config/tc-dlx.c \
+	config/tc-dvp.c \
 	config/tc-epiphany.c \
 	config/tc-fr30.c \
 	config/tc-frv.c \
@@ -477,6 +478,7 @@ TARGET_CPU_HFILES = \
 	config/tc-d10v.h \
 	config/tc-d30v.h \
 	config/tc-dlx.h \
+	config/tc-dvp.h \
 	config/tc-epiphany.h \
 	config/tc-fr30.h \
 	config/tc-frv.h \
@@ -831,6 +833,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-d10v.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-d30v.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-dlx.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-dvp.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-epiphany.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-fr30.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-frv.Po@am__quote@
@@ -1081,6 +1084,20 @@ tc-dlx.obj: config/tc-dlx.c
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tc-dlx.obj `if test -f 'config/tc-dlx.c'; then $(CYGPATH_W) 'config/tc-dlx.c'; else $(CYGPATH_W) '$(srcdir)/config/tc-dlx.c'; fi`
 
+tc-dvp.o: config/tc-dvp.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT tc-dvp.o -MD -MP -MF $(DEPDIR)/tc-dvp.Tpo -c -o tc-dvp.o `test -f 'config/tc-dvp.c' || echo '$(srcdir)/'`config/tc-dvp.c
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/tc-dvp.Tpo $(DEPDIR)/tc-dvp.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='config/tc-dvp.c' object='tc-dvp.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tc-dvp.o `test -f 'config/tc-dvp.c' || echo '$(srcdir)/'`config/tc-dvp.c
+
+tc-dvp.obj: config/tc-dvp.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT tc-dvp.obj -MD -MP -MF $(DEPDIR)/tc-dvp.Tpo -c -o tc-dvp.obj `if test -f 'config/tc-dvp.c'; then $(CYGPATH_W) 'config/tc-dvp.c'; else $(CYGPATH_W) '$(srcdir)/config/tc-dvp.c'; fi`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/tc-dvp.Tpo $(DEPDIR)/tc-dvp.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='config/tc-dvp.c' object='tc-dvp.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tc-dvp.obj `if test -f 'config/tc-dvp.c'; then $(CYGPATH_W) 'config/tc-dvp.c'; else $(CYGPATH_W) '$(srcdir)/config/tc-dvp.c'; fi`
+
 tc-epiphany.o: config/tc-epiphany.c
 @am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT tc-epiphany.o -MD -MP -MF $(DEPDIR)/tc-epiphany.Tpo -c -o tc-epiphany.o `test -f 'config/tc-epiphany.c' || echo '$(srcdir)/'`config/tc-epiphany.c
 @am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/tc-epiphany.Tpo $(DEPDIR)/tc-epiphany.Po
diff -burNpd binutils-2.25.1.orig/gas/config/tc-dvp.c binutils-2.25.1.PS2/gas/config/tc-dvp.c
--- binutils-2.25.1.orig/gas/config/tc-dvp.c	1969-12-31 18:00:00.000000000 -0600
+++ binutils-2.25.1.PS2/gas/config/tc-dvp.c	2019-12-27 15:50:33.352554784 -0600
@@ -0,0 +1,3382 @@
+/* tc-dvp.c -- Assembler for the DVP
+   Copyright (C) 1997, 1998 Free Software Foundation.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to
+   the Free Software Foundation, 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include "as.h"
+#include "config.h" 
+#include "struc-symbol.h"
+#include "subsegs.h"
+#include "safe-ctype.h" 
+/* Needed by opcode/dvp.h.  */
+#include "dis-asm.h"
+#include "opcode/dvp.h"
+#include "elf/mips.h"
+
+#include <assert.h>
+#include <stdarg.h>
+
+/* Value of VIF `nop' instruction.  */
+#define VIFNOP 0
+
+#define MIN(a,b) ((a) < (b) ? (a) : (b))
+
+/* Compute DMA operand index number of OP.  */
+#define DMA_OPERAND_INDEX(op) ((op) - dma_operands)
+
+/* Our local label prefix.  */
+#define DVP_LOCAL_LABEL_PREFIX ".L"
+/* Label prefix for end markers used in autocounts.  */
+#define END_LABEL_PREFIX ".L.end."
+/* Label to use for unique labels.  */
+#define UNIQUE_LABEL_PREFIX ".L.dvptmp."
+/* Prefix for mips version of labels defined in vu code.
+   Note that symbols that begin with '$' are local symbols
+   on mips targets, so we can't begin it with '$'.  */
+#define VU_LABEL_PREFIX "_$"
+/* Prefix for symbols at start of vu overlays, in r5900 space.  */
+#define VUOVERLAY_START_PREFIX "__start_"
+
+static long parse_float (char **, const char **);
+static symbolS * create_label (const char *, const char *);
+static symbolS * create_colon_label (int, const char *, const char *);
+static char * unique_name (const char *);
+static int vuoverlay_section_p (segT);
+static char * vuoverlay_section_name (symbolS *);
+static void create_vuoverlay_section (const char *, symbolS *,
+					      symbolS *, symbolS *);
+static const char *scan_symbol (const char *sym);
+static symbolS * compute_mpgloc (symbolS *, symbolS *, symbolS *);
+static int compute_nloop (gif_type, int, int);
+static void check_nloop (gif_type, int, int, int,
+				 char *, unsigned int);
+static long eval_expr (dvp_cpu, int, int, const char *, ...);
+static long parse_dma_addr_autocount(const dvp_opcode *opcode, const dvp_operand *operand, int mods, DVP_INSN *insn_buf, char **pstr, const char **errmsg);
+static void inline_dma_data (int, DVP_INSN *);
+static void setup_dma_autocount (const char *, DVP_INSN *, int);
+
+int vif_insn_type (char ibyte);
+
+static void insert_operand 
+     (dvp_cpu, const dvp_opcode *, const dvp_operand *, int,
+	      DVP_INSN *, offsetT, const char **);
+static void insert_operand_final
+     (dvp_cpu, const dvp_operand *, int,
+	      DVP_INSN *, offsetT, char *, unsigned int);
+
+static void insert_mpg_marker (unsigned long);
+//static void insert_unpack_marker (unsigned long);
+static int insert_file (const char *,
+				void (*) (unsigned long),
+				unsigned long, int);
+
+static void install_vif_length (char *, int);
+int vif_insn_type (char ibyte);
+int vif_length_value (char ibyte, int wl, int cl, int bytes);
+
+static symbolS *expr_build_binary (operatorT op, symbolS *s1, symbolS *s2);
+
+const char comment_chars[] = ";";
+const char line_comment_chars[] = "#";
+const char line_separator_chars[] = "!";
+const char EXP_CHARS[] = "eE";
+const char FLT_CHARS[] = "dD";
+
+/* Last label seen.
+   When we see a .dmastart, any immediately preceding label is
+   automagically aligned as well.  */
+static symbolS *last_label_seen;
+/* Labels for vu code are duplicated, one in vu space, one in normal space.
+   This records the label in vu space.  */
+static symbolS *last_label_seen2;
+
+
+/* Current assembler state.
+   Instructions like mpg and direct are followed by a restricted set of
+   instructions.  In the case of a '*' length argument an end marker must
+   be provided.  (e.g. mpg is followed by vu insns until a .EndMpg is
+   seen).
+
+   Allowed state transitions:
+   ASM_INIT <--> ASM_MPG
+                 ASM_DIRECT <--> ASM_GIF
+                 ASM_UNPACK <--> ASM_GIF
+                 ASM_VU
+		 ASM_GIF
+
+   FIXME: Make the ASM_INIT -> ASM_VU a one way transition.
+   ".vu" must be seen at the top of the file,
+   and cannot be switched out of.
+*/
+
+typedef enum {
+  ASM_INIT, ASM_DIRECT, ASM_MPG, ASM_UNPACK, ASM_VU, ASM_GIF, ASM_MAX
+} asm_state;
+
+/* We need to maintain a stack of the current and previous status to handle
+   such things as "direct ...; gifpacked ... ; .endgif ; .enddirect".  */
+#define MAX_STATE_DEPTH 2
+static asm_state asm_state_stack[MAX_STATE_DEPTH];
+/* Current state's index in the stack.  */
+static int cur_state_level;
+/* Macro to fetch the current state.  */
+#define CUR_ASM_STATE (asm_state_stack[cur_state_level])
+
+/* Functions to push/pop the state stack.  */
+static void push_asm_state (asm_state);
+static void pop_asm_state (int);
+static void set_asm_state (asm_state, const char *);
+
+/* Set to non-zero if any non-vu insn seen.
+   Used to control type of relocations emitted.  */
+static int non_vu_insn_seen_p = 0;
+
+
+/* Current cpu (machine variant) type state.
+   We copy the mips16 way of recording what the current machine type is in
+   the code.  A label is created whenever necessary and has an "other" value
+   the denotes the machine type.  */
+static dvp_cpu cur_cpu;
+/* Record the current mach type.  */
+static void record_mach (dvp_cpu, int);
+/* Force emission of mach type label at next insn.
+   This isn't static as TC_START_LABEL uses it.  */
+int force_mach_label (void);
+/* Given a dvp_cpu value, return the STO_DVP value to use.  */
+static int cpu_sto (dvp_cpu, const char **);
+
+/* Nonzero if inside .DmaData.  */
+static int dma_data_state = 0;
+/* Label of .DmaData (internally generated for inline data).  */
+static const char *dma_data_name;
+
+/* Variable length VIF insn support.  */
+/* Label at start of insn's data.  */
+static symbolS *vif_data_start;
+/* Label at end of insn's data.  */
+static symbolS *vif_data_end;
+
+/* Special symbol $.mpgloc.  The value is in bytes.
+   This value is kept absolute, for simplicity.
+   The st_other field for this must always be set to STO_DVP_VU because
+   symbols computed from this will get their st_other field clobbered
+   with this one (via resolve_symbol_value,copy_symbol_attributes).  */
+static symbolS *mpgloc_sym;
+
+/* Handle of the current vu overlay section.  */
+static segT vuoverlay_section;
+
+/* The overlay table section is a table mapping lma's to vma's.  */
+static segT vuoverlay_table_section;
+/* String table to record section names in the overlay table.  */
+static segT vuoverlay_string_section;
+
+/* Table to map vu space labels to their overlay sections.
+   Labels in vu space are first put in the ABS section to simplify
+   PC relative branch calculations (s1 - s2 isn't supported if they're
+   in different sections).  Before the file is written out the labels
+   are moved to their overlay section.  */
+typedef struct ovlysym {
+  struct ovlysym *next;
+  segT sec;
+  symbolS *sym;
+} ovlysymS;
+static ovlysymS *ovlysym_table;
+
+/* GIF insn support.  */
+/* Type of insn.  */
+static int gif_insn_type;
+/* Name of label of insn's data.  */
+static const char *gif_data_name;
+/* Pointer to frag of insn.  */
+static fragS *gif_insn_frag;
+/* Pointer to current gif insn in gif_insn_frag.  */
+static char *gif_insn_frag_loc;
+
+/* Count of vu insns seen since the last mpg.
+   Set to -1 to disable automatic mpg insertion.  */
+static int vu_count;
+
+/* Non-zero if packing vif instructions in dma tags.  */
+static int dma_pack_vif_p;
+
+/* Non-zero if dma insns are to be included in the output.
+   This is the default, but writing "if (! no_dma)" is klunky.  */
+static int output_dma = 1;
+/* Non-zero if vif insns are to be included in the output.  */
+static int output_vif = 1;
+
+/* Current opcode/operand for use by md_operand.  */
+static const dvp_opcode *cur_opcode;
+static const dvp_operand *cur_operand;
+
+/* Options for the `caller' argument to s_endmpg.  */
+typedef enum { ENDMPG_USER, ENDMPG_INTERNAL, ENDMPG_MIDDLE } endmpg_caller;
+
+/* Relaxation support.  */
+#define RELAX_MPG 1
+#define RELAX_DIRECT 2
+/* vu insns aren't relaxed, but they use machine dependent frags so we
+   must handle them during relaxation */
+#define RELAX_VU 3
+#define RELAX_ENCODE(type, growth) (10 + (growth))
+#define RELAX_GROWTH(state) ((state) - 10)
+/* Return non-zero if STATE represents a relaxed state.  */
+#define RELAX_DONE_P(state) ((state) >= 10)
+
+
+const char *md_shortopts = "";
+
+struct option md_longopts[] =
+{
+#define OPTION_NO_DMA (OPTION_MD_BASE + 1)
+  { "no-dma", no_argument, NULL, OPTION_NO_DMA },
+#define OPTION_NO_DMA_VIF (OPTION_NO_DMA + 1)
+  { "no-dma-vif", no_argument, NULL, OPTION_NO_DMA_VIF },
+
+  {NULL, no_argument, NULL, 0}
+};
+size_t md_longopts_size = sizeof(md_longopts);
+
+int
+md_parse_option (c, arg)
+     int c;
+     char *arg __attribute__((unused));
+{
+  switch (c)
+    {
+    case OPTION_NO_DMA :
+      output_dma = 0;
+      break;
+    case OPTION_NO_DMA_VIF :
+      output_dma = 0;
+      output_vif = 0;
+      break;
+    default :
+      return 0;
+    }
+  return 1;
+}
+
+void
+md_show_usage (stream)
+  FILE *stream;
+{
+  fprintf (stream, "\
+DVP options:\n\
+-no-dma			do not include DMA instructions in the output\n\
+-no-dma-vif		do not include DMA or VIF instructions in the output\n\
+");
+} 
+
+static void s_dmadata (int);
+static void s_enddmadata (int);
+static void s_dmapackvif (int);
+static void s_enddirect (int);
+static void s_endmpg (int);
+static void s_endunpack (int);
+static void s_endgif (int);
+static void s_vu (int);
+static void s_dvp_func (int);
+
+/* The target specific pseudo-ops which we support.  */
+const pseudo_typeS md_pseudo_table[] =
+{
+  { "word", cons, 4 },
+  { "quad", cons, 16 },
+  { "dmadata", s_dmadata, 0 },
+  { "dmapackvif", s_dmapackvif, 0 },
+  { "enddirect", s_enddirect, 0 },
+  { "enddmadata", s_enddmadata, 0 },
+  { "endmpg", s_endmpg, ENDMPG_USER },
+  { "endunpack", s_endunpack, 0 },
+  { "endgif", s_endgif, 0 },
+  { "vu", s_vu, 0 },
+  /* We need to intercept .func/.endfunc so that we can prepend _$.
+     ??? Not sure this is right though as _$foo is the lma version.  */
+  { "func", s_dvp_func, 0 },
+  { "endfunc", s_dvp_func, 1 },
+  { NULL, NULL, 0 }
+};
+
+
+void
+md_begin ()
+{
+  /* Initialize the opcode tables.
+     This involves computing the hash chains.  */
+  dvp_opcode_init_tables ();
+
+  /* Force a mach type label for the first insn.  */
+  force_mach_label ();
+
+  /* Initialize the parsing state.  */
+  set_asm_state (ASM_INIT, NULL);
+
+  /* Pack vif insns in dma tags by default.  */
+  dma_pack_vif_p = 1;
+
+  /* Disable automatic mpg insertion.  */
+  vu_count = -1;
+
+  /* Initialize $.mpgloc.  */
+  mpgloc_sym = expr_build_uconstant (0);
+  S_SET_OTHER (mpgloc_sym, STO_DVP_VU);
+
+  /* Create the vu overlay table section.  */
+  {
+    /* Must preserve the current seg/subseg.  It is the initial one.  */
+    segT orig_seg = now_seg;
+    subsegT orig_subseg = now_subseg;
+
+    vuoverlay_table_section = subseg_new (SHNAME_DVP_OVERLAY_TABLE, 0);
+    record_alignment (now_seg, 2);
+    vuoverlay_string_section = subseg_new (SHNAME_DVP_OVERLAY_STRTAB, 0);
+    /* Ensure first byte in executable is zero.  So what if we waste
+       a few bytes.  */
+    FRAG_APPEND_1_CHAR (0);
+
+    subseg_set (orig_seg, orig_subseg);
+  }
+
+  /* Set the type of the output file to r5900.  */
+  bfd_set_arch_mach (stdoutput, bfd_arch_mips, 5900);
+}
+
+
+/* We need to keep a list of fixups.  We can't simply generate them as
+   we go, because that would require us to first create the frag, and
+   that would screw up references to ``.''.  */
+
+struct dvp_fixup
+{
+  /* the cpu this fixup is associated with */
+  dvp_cpu cpu;
+  /* index into `dvp_operands' */
+  int opindex;
+  /* byte offset from beginning of instruction */
+  int offset;
+  /* user specified value [when there is one] */
+  int user_value;
+  /* wl,cl values, only used with unpack insn */
+  short wl,cl;
+  /* the expression */
+  expressionS exp;
+};
+
+#define MAX_FIXUPS 5
+
+static int fixup_count;
+static struct dvp_fixup fixups[MAX_FIXUPS];
+
+/* Given a cpu type and operand number, return a temporary reloc type
+   for use in generating the fixup that encodes the cpu type and operand.  */
+static unsigned int encode_fixup_reloc_type (dvp_cpu, int);
+/* Given an encoded fixup reloc type, decode it into cpu and operand.  */
+static void decode_fixup_reloc_type (int, dvp_cpu *,
+					     const dvp_operand **);
+
+static void assemble_dma (char *);
+static void assemble_gif (char *);
+static void assemble_vif (char *);
+static void assemble_vu (char *);
+static const dvp_opcode * assemble_one_insn (dvp_cpu,
+						     const dvp_opcode *,
+						     const dvp_operand *,
+						     int, int,
+						     char **, DVP_INSN *);
+
+/* Main entry point for assembling an instruction.  */
+
+void
+md_assemble (str)
+     char *str;
+{
+  /* Skip leading white space.  */
+  while (ISSPACE (*str))
+    str++;
+
+  /* After a gif tag, no insns can appear until a .endgif is seen.  */
+  if (CUR_ASM_STATE == ASM_GIF)
+    {
+      as_bad ("missing .endgif");
+      pop_asm_state (1);
+      /* We still parse the instruction.  */
+    }
+
+  if (CUR_ASM_STATE == ASM_INIT)
+    {
+      if (strncasecmp (str, "dma", 3) == 0)
+	assemble_dma (str);
+      else if (strncasecmp (str, "gif", 3) == 0)
+	assemble_gif (str);
+      else
+	assemble_vif (str);
+      non_vu_insn_seen_p = 1;
+    }
+  else if (CUR_ASM_STATE == ASM_DIRECT
+	   || CUR_ASM_STATE == ASM_UNPACK)
+    {
+      assemble_gif (str);
+      non_vu_insn_seen_p = 1;
+    }
+  else if (CUR_ASM_STATE == ASM_VU
+	   || CUR_ASM_STATE == ASM_MPG)
+    assemble_vu (str);
+  else
+    as_fatal ("internal error: unknown parse state");
+}
+
+/* Subroutine of md_assemble to assemble DMA instructions.  */
+
+static void
+assemble_dma (str)
+     char *str;
+{
+  DVP_INSN insn_buf[2];
+  /* Pointer to allocated frag.  */
+  char *f;
+  int i;
+  const dvp_opcode *opcode;
+
+  if (output_dma)
+    {
+      /* Do an implicit alignment to a 16 byte boundary.
+	 Do it now so that inline dma data labels are at the right place.  */
+      /* ??? One can certainly argue all this implicit alignment is
+	 questionable.  The thing is assembler programming is all that will
+	 mostly likely ever be done and not doing so forces an extra [and
+	 arguably unnecessary] burden on the programmer.
+	 ??? On the other hand this automagic alignment requires the supremely
+	 grotesque last_label_seen hack.  Assembler macros may have been a
+	 better way to go.  */
+      frag_align (4, 0, 0);
+      record_alignment (now_seg, 4);
+
+      /* Advance up the immediately preceding label if present.  */
+      if (last_label_seen)
+	{
+	  assert (S_GET_SEGMENT (last_label_seen) == now_seg);
+	  last_label_seen->sy_frag = frag_now;
+	  S_SET_VALUE (last_label_seen, frag_now_fix ());
+	}
+    }
+
+  /* This is the DMA tag.  */
+  insn_buf[0] = 0;
+  insn_buf[1] = 0;
+
+  opcode = assemble_one_insn (DVP_DMA,
+			      dma_opcode_lookup_asm (str), dma_operands,
+			      0, 0, &str, insn_buf);
+  if (opcode == NULL)
+    return;
+  if (!output_dma)
+    return;
+
+  record_mach (DVP_DMA, 0);
+
+  f = frag_more (8);
+
+  /* Write out the DMA instruction. */
+  for (i = 0; i < 2; ++i)
+    md_number_to_chars (f + i * 4, insn_buf[i], 4);
+
+  /* Create any fixups.  */
+  /* FIXME: It might eventually be possible to combine all the various
+     copies of this bit of code.  */
+  for (i = 0; i < fixup_count; ++i)
+    {
+      int op_type, reloc_type, offset;
+      const dvp_operand *operand;
+
+      /* Create a fixup for this operand.
+	 At this point we do not use a bfd_reloc_code_real_type for
+	 operands residing in the insn, but instead just use the
+	 operand index.  This lets us easily handle fixups for any
+	 operand type, although that is admittedly not a very exciting
+	 feature.  We pick a BFD reloc type in md_apply_fix.  */
+
+      op_type = fixups[i].opindex;
+      offset = fixups[i].offset;
+      reloc_type = encode_fixup_reloc_type (DVP_DMA, op_type);
+      operand = &dma_operands[op_type];
+      fix_new_exp (frag_now, f + offset - frag_now->fr_literal, 4,
+		   &fixups[i].exp,
+		   (operand->flags & DVP_OPERAND_RELATIVE_BRANCH) != 0,
+		   (bfd_reloc_code_real_type) reloc_type);
+    }
+
+  /* The upper two words are vif insns.  */
+  record_mach (DVP_VIF, 0);
+
+  /* If not doing dma/vif packing, fill out the insn with vif nops.
+     ??? We take advantage of the fact that the default fill value of zero
+     is the vifnop insn.  This occurs for example when handling mpg
+     alignment.  It also occurs when one dma tag immediately follows the
+     previous one.  */
+  if (! dma_pack_vif_p)
+    {
+      f = frag_more (8);
+      md_number_to_chars (f + 0, VIFNOP, 4);
+      md_number_to_chars (f + 4, VIFNOP, 4);
+    }
+}
+
+/* Subroutine of md_assemble to assemble VIF instructions.  */
+
+static void
+assemble_vif (str)
+     char *str;
+{
+  /* Space for the instruction.
+     The variable length insns can require much more space than this.
+     It is allocated later, when we know we have such an insn.  */
+  DVP_INSN insn_buf[5];
+  /* Insn's length, in 32 bit words.  */
+  int len;
+  /* Pointer to allocated frag.  */
+  char *f;
+  int i,wl,cl;
+  const dvp_opcode *opcode;
+  fragS * insn_frag;
+  /* Name of file to read data from.  */
+  const char *file;
+  /* Length in 32 bit words.  */
+  int data_len;
+  /* Macro expansion, if there is one.  */
+  char * macstr;
+
+  f = NULL;
+
+  /* First check for macros.  */
+  macstr = dvp_expand_macro (vif_macros, vif_macro_count, str);
+  if (macstr)
+    {
+      /* The macro may expand into several insns (delimited with '\n'),
+	 so loop.  */
+      char * next = macstr;
+      do
+	{
+	  char *p = strchr (next, '\n');
+	  if (p)
+	    *p = 0;
+	  assemble_vif (next);
+	  next = p ? p + 1 : 0;
+	}
+      while (next);
+      free (macstr);
+      return;
+    }
+
+  opcode = assemble_one_insn (DVP_VIF,
+			      vif_opcode_lookup_asm (str), vif_operands,
+			      0, 0, &str, insn_buf);
+  if (opcode == NULL)
+    return;
+
+  if (opcode->flags & VIF_OPCODE_LENVAR)
+    len = 1; /* actual data follows later */
+  else if (opcode->flags & VIF_OPCODE_LEN2)
+    len = 2;
+  else if (opcode->flags & VIF_OPCODE_LEN5)
+    len = 5;
+  else
+    len = 1;
+
+  /* We still have to switch modes (if mpg for example) so we can't exit
+     early if -no-vif.  */
+
+  if (output_vif)
+    {
+      /* Record the mach before doing the alignment so that we properly
+	 disassemble any inserted vifnop's.  For mpg and direct insns
+	 force the recording of the mach type for the next insn.  The data
+	 will switch the mach type and we want to ensure it's switched
+	 back.  */
+
+      if (opcode->flags & (VIF_OPCODE_MPG | VIF_OPCODE_DIRECT))
+	record_mach (DVP_VIF, 1);
+      else
+	record_mach (DVP_VIF, 0);
+
+      /* For variable length instructions record a fixup that is the symbol
+	 marking the end of the data.  eval_expr will queue the fixup
+	 which will then be emitted later.  */
+      if (opcode->flags & VIF_OPCODE_LENVAR)
+	{
+	  char *name;
+
+	  asprintf (&name, "%s%s", DVP_LOCAL_LABEL_PREFIX,
+		    unique_name ("varlen"));
+	  vif_data_end = symbol_new (name, now_seg, 0, 0);
+	  symbol_table_insert (vif_data_end);
+	  fixups[fixup_count].cpu = DVP_VIF;
+	  fixups[fixup_count].exp.X_op = O_symbol;
+	  fixups[fixup_count].exp.X_add_symbol = vif_data_end;
+	  fixups[fixup_count].exp.X_add_number = 0;
+	  fixups[fixup_count].opindex = vif_operand_datalen_special;
+	  fixups[fixup_count].offset = 0;
+
+	  /* See what the user specified.  */
+	  vif_get_var_data (&file, &data_len);
+	  if (file)
+	    data_len = -1;
+	  fixups[fixup_count].user_value = data_len;
+	  /* Get the wl,cl values.  Only useful for the unpack insn but
+	     it doesn't hurt to always record them.  */
+	  vif_get_wl_cl (&wl, &cl);
+	  fixups[fixup_count].wl = wl;
+	  fixups[fixup_count].cl = cl;
+	  ++fixup_count;
+	}
+
+      /* Obtain space in which to store the instruction.  */
+
+      if (opcode->flags & VIF_OPCODE_MPG)
+	{
+	  /* The data must be aligned on a 64 bit boundary (so the mpg insn
+	     comes just before that 64 bit boundary).
+	     Do this by putting the mpg insn in a relaxable fragment
+	     with a symbol that marks the beginning of the aligned data.  */
+
+	  /* Ensure relaxable fragments are in their own fragment.
+	     Otherwise md_apply_fix mishandles fixups to insns earlier
+	     in the fragment (because we set fr_opcode for the `mpg' insn
+	     because it can move in the fragment).  */
+	  frag_wane (frag_now);
+	  frag_new (0);
+
+	  /* One could combine the previous two lines with the following.
+	     They're not for clarity: keep separate the actions being
+	     performed.  */
+
+	  /* This dance with frag_grow is so we can record frag_now in
+	     insn_frag.  frag_var always changes frag_now.  We must allocate
+	     the maximal amount of space we need so there's room to move
+	     the insn in the frag during relaxation.  */
+	  frag_grow (8);
+	  /* Allocate space for the fixed part.  */
+	  f = frag_more (4);
+	  insn_frag = frag_now;
+
+	  frag_var (rs_machine_dependent,
+		    4, /* max chars */
+		    0, /* variable part is empty at present */
+		    RELAX_MPG, /* subtype */
+		    NULL, /* no symbol */
+		    0, /* offset */
+		    f); /* opcode */
+
+	  frag_align (3, 0, 0);
+	  record_alignment (now_seg, 3);
+
+	  /* Put a symbol at the start of data.  The relaxation code uses
+	     this to figure out how many bytes to insert.  $.mpgloc
+	     calculations use it.  The disassembler uses it.  The overlay
+	     tracking table uses it.
+	     Update $.mpgloc.
+	     Create an overlay section.  */
+	  {
+	    int mpgloc = vif_get_mpgloc ();
+	    const char * section_name;
+
+	    /* Update $.mpgloc if explicitly set.
+	       Otherwise just use the current value.  */
+	    if (mpgloc != -1)
+	      {
+		/* The value is recorded in bytes, mpgloc is in dwords.  */
+		mpgloc_sym = expr_build_uconstant (mpgloc * 8);
+		S_SET_OTHER (mpgloc_sym, STO_DVP_VU);
+	      }
+
+	    section_name = vuoverlay_section_name (mpgloc_sym);
+	    vif_data_start = create_colon_label (STO_DVP_VU,
+#if 0
+						 VUOVERLAY_START_PREFIX,
+#else
+						 DVP_LOCAL_LABEL_PREFIX,
+#endif
+						 section_name);
+	    insn_frag->fr_symbol = vif_data_start;
+
+	    create_vuoverlay_section (section_name, mpgloc_sym,
+				      vif_data_start, vif_data_end);
+	  }
+	}
+      else if (opcode->flags & VIF_OPCODE_DIRECT)
+	{
+	  /* The data must be aligned on a 128 bit boundary (so the direct insn
+	     comes just before that 128 bit boundary).
+	     Do this by putting the direct insn in a relaxable fragment.
+	     with a symbol that marks the beginning of the aligned data.  */
+
+	  /* Ensure relaxable fragments are in their own fragment.
+	     Otherwise md_apply_fix mishandles fixups to insns earlier
+	     in the fragment (because we set fr_opcode for the `direct' insn
+	     because it can move in the fragment).  */
+	  frag_wane (frag_now);
+	  frag_new (0);
+
+	  /* One could combine the previous two lines with the following.
+	     They're not for clarity: keep separate the actions being
+	     performed.  */
+
+	  /* This dance with frag_grow is so we can record frag_now in
+	     insn_frag.  frag_var always changes frag_now.  We must allocate
+	     the maximal amount of space we need so there's room to move
+	     the insn in the frag during relaxation.  */
+	  frag_grow (16);
+	  /* Allocate space for the fixed part.  */
+	  f = frag_more (4);
+	  insn_frag = frag_now;
+
+	  frag_var (rs_machine_dependent,
+		    12, /* max chars */
+		    0, /* variable part is empty at present */
+		    RELAX_DIRECT, /* subtype */
+		    NULL, /* no symbol */
+		    0, /* offset */
+		    f); /* opcode */
+
+	  frag_align (4, 0, 0);
+	  record_alignment (now_seg, 4);
+
+	  /* Put a symbol at the start of data.  The relaxation code uses
+	     this to figure out how many bytes to insert.  */
+	  vif_data_start = create_colon_label (0, DVP_LOCAL_LABEL_PREFIX,
+					       unique_name ("direct"));
+	  insn_frag->fr_symbol = vif_data_start;
+	}
+      else if (opcode->flags & VIF_OPCODE_UNPACK)
+	{
+	  f = frag_more (len * 4);
+	  insn_frag = frag_now;
+	  /* Put a symbol at the start of data.  $.unpackloc calculations
+	     use it.  */
+	  /* ??? $.unpackloc is gone.  Is this also used for data length
+	     verification?  */
+	  vif_data_start = create_colon_label (STO_DVP_VIF, DVP_LOCAL_LABEL_PREFIX,
+					       unique_name ("unpack"));
+	}
+      else
+	{
+	  /* Reminder: it is important to fetch enough space in one call to
+	     `frag_more'.  We use (f - frag_now->fr_literal) to compute where
+	     we are and we don't want frag_now to change between calls.  */
+	  f = frag_more (len * 4);
+	  insn_frag = frag_now;
+	}
+
+      /* Write out the instruction.  */
+      for (i = 0; i < len; ++i)
+	md_number_to_chars (f + i * 4, insn_buf[i], 4);
+
+      /* Create any fixups.  */
+      /* FIXME: It might eventually be possible to combine all the various
+	 copies of this bit of code.  */
+      for (i = 0; i < fixup_count; ++i)
+	{
+	  int op_type, reloc_type, offset;
+	  const dvp_operand *operand;
+	  fixS *fixP;
+
+	  /* Create a fixup for this operand.
+	     At this point we do not use a bfd_reloc_code_real_type for
+	     operands residing in the insn, but instead just use the
+	     operand index.  This lets us easily handle fixups for any
+	     operand type, although that is admittedly not a very exciting
+	     feature.  We pick a BFD reloc type in md_apply_fix.  */
+
+	  op_type = fixups[i].opindex;
+	  offset = fixups[i].offset;
+	  reloc_type = encode_fixup_reloc_type (DVP_VIF, op_type);
+	  operand = &vif_operands[op_type];
+	  fixP = fix_new_exp (insn_frag, f + offset - insn_frag->fr_literal, 4,
+			      &fixups[i].exp,
+			      (operand->flags & DVP_OPERAND_RELATIVE_BRANCH) != 0,
+			      (bfd_reloc_code_real_type) reloc_type);
+	  fixP->tc_fix_data.user_value = fixups[i].user_value;
+	  fixP->tc_fix_data.wl = fixups[i].wl;
+	  fixP->tc_fix_data.cl = fixups[i].cl;
+
+	  /* Set fx_tcbit so other parts of the code know this fixup is for
+	     a vif insn.  */
+	  fixP->fx_tcbit = 1;
+	}
+    }
+
+  /* Handle variable length insns.  */
+
+  if (opcode->flags & VIF_OPCODE_LENVAR)
+    {
+      /* See what the user specified.  */
+      vif_get_var_data (&file, &data_len);
+
+      if (file)
+	{
+	  /* The handling for each of mpg,direct,unpack is basically the same:
+	     - emit a label to set the mach type for the data we're inserting
+	     - switch to the new assembler state
+	     - insert the file
+	     - call the `end' handler  */
+
+	  if (opcode->flags & VIF_OPCODE_MPG)
+	    {
+	      record_mach (DVP_VUUP, 1);
+	      set_asm_state (ASM_MPG, "mpg");
+	      insert_file (file, insert_mpg_marker, 0, 256 * 8);
+	      s_endmpg (ENDMPG_INTERNAL);
+	    }
+	  else if (opcode->flags & VIF_OPCODE_DIRECT)
+	    {
+	      record_mach (DVP_GIF, 1);
+	      set_asm_state (ASM_DIRECT, "direct");
+	      insert_file (file, NULL, 0, 0);
+	      s_enddirect (1);
+	    }
+	  else if (opcode->flags & VIF_OPCODE_UNPACK)
+	    {
+	      int max_len = 0; /*unpack_max_byte_len (insn_buf[0]);*/
+	      set_asm_state (ASM_UNPACK, "unpack");
+	      insert_file (file, NULL /*insert_unpack_marker*/,
+				      insn_buf[0], max_len);
+	      s_endunpack (1);
+	    }
+	  else
+	    as_fatal ("internal error: unknown cpu type for variable length vif insn");
+	}
+      else /* file == NULL */
+	{
+	  /* data_len == -1 means the value must be computed from
+	     the data.  */
+	  if (data_len <= -2)
+	    as_bad ("invalid data length");
+
+	  if (output_vif && data_len != -1)
+	    install_vif_length (f, data_len);
+
+	  if (opcode->flags & VIF_OPCODE_MPG)
+	    {
+	      set_asm_state (ASM_MPG, "mpg");
+	      /* Enable automatic mpg insertion every 256 insns.  */
+	      vu_count = 0;
+	    }
+	  else if (opcode->flags & VIF_OPCODE_DIRECT)
+	    set_asm_state (ASM_DIRECT, "direct");
+	  else if (opcode->flags & VIF_OPCODE_UNPACK)
+	    set_asm_state (ASM_UNPACK, "unpack");
+	}
+    }
+}
+
+/* Subroutine of md_assemble to assemble GIF instructions.
+   We assume CUR_ASM_STATE is one of ASM_{INIT,DIRECT,UNPACK}.  */
+
+static void
+assemble_gif (str)
+     char *str;
+{
+  DVP_INSN insn_buf[4];
+  const dvp_opcode *opcode;
+  char *f;
+  int i;
+
+  insn_buf[0] = insn_buf[1] = insn_buf[2] = insn_buf[3] = 0;
+
+  opcode = assemble_one_insn (DVP_GIF,
+			      gif_opcode_lookup_asm (str), gif_operands,
+			      0, 0, &str, insn_buf);
+  if (opcode == NULL)
+    return;
+
+  /* Do an implicit alignment to a 16 byte boundary.  */
+  frag_align (4, 0, 0);
+  record_alignment (now_seg, 4);
+
+  /* Advance up the immediately preceding label if present.  */
+  if (last_label_seen)
+    {
+      assert (S_GET_SEGMENT (last_label_seen) == now_seg);
+      last_label_seen->sy_frag = frag_now;
+      S_SET_VALUE (last_label_seen, frag_now_fix ());
+    }
+
+  /* Insert a label so we can compute the number of quadwords when the
+     .endgif is seen.  This is put before the mach type label because gif
+     insns are followed by data and we don't want the disassembler to try
+     to disassemble them as mips insns (since it uses the st_other field)
+     of the closest label to choose the mach type and since we don't have
+     a special st_other value for "data".  */
+  gif_data_name = S_GET_NAME (create_colon_label (0, DVP_LOCAL_LABEL_PREFIX,
+						  unique_name ("gifdata")));
+
+  record_mach (DVP_GIF, 1);
+
+  gif_insn_frag_loc = f = frag_more (16);
+  gif_insn_frag = frag_now;
+  for (i = 0; i < 4; ++i)
+    md_number_to_chars (f + i * 4, insn_buf[i], 4);
+
+  /* Record the type of the gif tag so we know how to compute nloop
+     in s_endgif.  */
+  if (strcmp (opcode->mnemonic, "gifpacked") == 0)
+    gif_insn_type = GIF_PACKED;
+  else if (strcmp (opcode->mnemonic, "gifreglist") == 0)
+    gif_insn_type = GIF_REGLIST;
+  else if (strcmp (opcode->mnemonic, "gifimage") == 0)
+    gif_insn_type = GIF_IMAGE;
+  else
+    abort ();
+  push_asm_state (ASM_GIF);
+}
+
+/* Subroutine of md_assemble to assemble VU instructions.  */
+
+static void
+assemble_vu (str)
+     char *str;
+{
+  int i;
+  char *f;
+  const dvp_opcode *opcode;
+  /* The lower instruction has the lower address so insns[0] = lower insn,
+     insns[1] = upper insn.  */
+  DVP_INSN insns[2];
+  fragS * insn_frag;
+
+  /* Handle automatic mpg insertion if enabled.  */
+  if (CUR_ASM_STATE == ASM_MPG
+      && vu_count == 256)
+    insert_mpg_marker (0);
+
+  /* Do an implicit alignment to a 8 byte boundary.  */
+  frag_align (3, 0, 0);
+  record_alignment (now_seg, 3);
+
+  /* Advance up the immediately preceding label if present.  */
+  if (last_label_seen)
+    {
+      assert (S_GET_SEGMENT (last_label_seen) == now_seg);
+      last_label_seen->sy_frag = frag_now;
+      S_SET_VALUE (last_label_seen, frag_now_fix ());
+
+      /* Do the same for the copy in vu space.
+	 Note that there won't be one if the file is all vu code.  */
+      if (last_label_seen2)
+	{
+	  symbolS * cur_mpgloc = compute_mpgloc (mpgloc_sym, vif_data_start,
+						 expr_build_dot ());
+	  last_label_seen2->sy_value = cur_mpgloc->sy_value;
+	}
+    }
+
+  record_mach (DVP_VUUP, 0);
+
+#ifdef VERTICAL_BAR_SEPARATOR
+  char *p = strchr (str, '|');
+
+  if (p == NULL)
+    {
+      as_bad ("lower instruction missing");
+      return;
+    }
+
+  *p = 0;
+  opcode = assemble_one_insn (DVP_VUUP,
+			      vu_upper_opcode_lookup_asm (str), vu_operands,
+			      0, 4, &str, &insns[1]);
+  *p = '|';
+  str = p + 1;
+#else
+  opcode = assemble_one_insn (DVP_VUUP,
+			     vu_upper_opcode_lookup_asm (str), vu_operands,
+			     0, 4, &str, &insns[1]);
+#endif
+
+  /* Don't assemble next one if we couldn't assemble the first.  */
+  if (opcode == NULL)
+    return;
+
+  if (*str == 0)
+    {
+      as_bad ("lower instruction missing");
+      return;
+    }
+
+  /* Assemble the lower insn.
+     Pass `fixup_count' for `init_fixup_count' so that we don't clobber
+     any fixups the upper insn had.  */
+  opcode = assemble_one_insn (DVP_VULO,
+			      vu_lower_opcode_lookup_asm (str), vu_operands,
+			      fixup_count, 0, &str, &insns[0]);
+  if (opcode == NULL)
+    return;
+
+  /* If there were fixups and we're inside mpg, create a machine dependent
+     fragment so that we can record the current value of $.mpgloc in fr_symbol.
+     Reminder: it is important to fetch enough space in one call to
+     `frag_more'.  We use (f - frag_now->fr_literal) to compute where
+     we are and we don't want frag_now to change between calls.  */
+  if (fixup_count != 0
+      && CUR_ASM_STATE == ASM_MPG)
+    {
+      symbolS * cur_mpgloc;
+
+      /* Ensure we get a new frag.  */
+      frag_wane (frag_now);
+      frag_new (0);
+
+      /* Compute the current $.mpgloc.  */
+      cur_mpgloc = compute_mpgloc (mpgloc_sym, vif_data_start,
+				   expr_build_dot ());
+
+      /* We need to use frag_now afterwards, so we can't just call frag_var.
+	 Instead we use frag_more and save the value of frag_now in
+	 insn_frag.  */
+      f = frag_more (8);
+      insn_frag = frag_now;
+      /* Turn the frag into a machine dependent frag.  */
+      frag_variant (rs_machine_dependent,
+		    0, /* max chars */
+		    0, /* no variable part */
+		    RELAX_VU, /* subtype */
+		    cur_mpgloc, /* $.mpgloc */
+		    0, /* offset */
+		    NULL); /* opcode */
+    }
+  else
+    {
+      f = frag_more (8);
+      insn_frag = frag_now;
+    }
+
+  /* Write out the instructions.  */
+  md_number_to_chars (f, insns[0], 4);
+  md_number_to_chars (f + 4, insns[1], 4);
+
+  /* Create any fixups.  */
+  for (i = 0; i < fixup_count; ++i)
+    {
+      int op_type, reloc_type;
+      const dvp_operand *operand;
+      dvp_cpu cpu;
+
+      /* Create a fixup for this operand.
+	 At this point we do not use a bfd_reloc_code_real_type for
+	 operands residing in the insn, but instead just use the
+	 operand index.  This lets us easily handle fixups for any
+	 operand type, although that is admittedly not a very exciting
+	 feature.  We pick a BFD reloc type in md_apply_fix.  */
+
+      cpu = fixups[i].cpu;
+      op_type = fixups[i].opindex;
+      reloc_type = encode_fixup_reloc_type (cpu, op_type);
+      operand = &vu_operands[op_type];
+
+      /* Branch operands inside mpg have to be handled specially.
+	 We want a pc relative relocation in a section different from our own.
+	 See the br-2.s dejagnu testcase for a good example.  */
+      if (CUR_ASM_STATE == ASM_MPG
+	  && (operand->flags & DVP_OPERAND_RELATIVE_BRANCH) != 0)
+	{
+	  symbolS *e1,*e2,*diff_expr;
+
+	  /* For "br foo" we want "foo - (. + 8)".  */
+	  e1 = expr_build_binary (O_add, insn_frag->fr_symbol,
+				  expr_build_uconstant (8));
+	  e2 = make_expr_symbol (&fixups[i].exp);
+	  diff_expr = expr_build_binary (O_subtract, e2, e1);
+	  fixups[i].exp.X_op = O_symbol; 
+	  fixups[i].exp.X_add_symbol = diff_expr;
+	  fixups[i].exp.X_add_number = 0;
+	}
+
+      fix_new_exp (insn_frag, f + fixups[i].offset - insn_frag->fr_literal, 4,
+		   &fixups[i].exp,
+		   CUR_ASM_STATE == ASM_MPG /* pcrel */
+		   ? 0
+		   : (operand->flags & DVP_OPERAND_RELATIVE_BRANCH) != 0,
+		   (bfd_reloc_code_real_type) reloc_type);
+    }
+
+  /* If this was the "loi" pseudo-insn, we need to set the `i' bit.  */
+  if (strcmp (opcode->mnemonic, "loi") == 0)
+    f[7] |= 0x80;
+
+  /* Increment the vu insn counter.
+     If get reach 256 we need to insert an `mpg'.  */
+  ++vu_count;
+}
+
+/* Assemble one instruction at *PSTR.
+   CPU indicates what component we're assembling for.
+   The assembled instruction is stored in INSN_BUF.
+   OPCODE is a pointer to the head of the hash chain.
+   INIT_FIXUP_COUNT is the initial value for `fixup_count'.
+   It exists to allow the fixups for multiple calls to this insn to be
+   queued up before actually emitting them.
+   *PSTR is updated to point passed the parsed instruction.
+
+   If the insn is successfully parsed the result is a pointer to the opcode
+   entry that successfully matched and *PSTR is updated to point passed
+   the parsed insn.  If an error occurs the result is NULL and *PSTR is left
+   at some random point in the string (??? may wish to leave it pointing where
+   the error occured).  */
+
+static const dvp_opcode *
+assemble_one_insn (cpu, opcode, operand_table, init_fixup_count, fixup_offset,
+		   pstr, insn_buf)
+     dvp_cpu cpu;
+     const dvp_opcode *opcode;
+     const dvp_operand *operand_table;
+     int init_fixup_count;
+     int fixup_offset;
+     char **pstr;
+     DVP_INSN *insn_buf;
+{
+  char *start, *str;
+
+  /* Keep looking until we find a match.  */
+
+  start = str = *pstr;
+  for ( ; opcode != NULL; opcode = DVP_OPCODE_NEXT_ASM (opcode))
+    {
+      int past_opcode_p;
+      const unsigned char *syn;
+
+      /* Ensure the mnemonic part matches.  */
+      for (str = start, syn = (unsigned char*)opcode->mnemonic; *syn != '\0'; ++str, ++syn)
+	if (TOLOWER (*str) != TOLOWER (*syn))
+	  break;
+      if (*syn != '\0')
+	continue;
+
+      /* Scan the syntax string.  If it doesn't match, try the next one.  */
+
+      dvp_opcode_init_parse ();
+      insn_buf[opcode->opcode_word] = opcode->value;
+      fixup_count = init_fixup_count;
+      past_opcode_p = 0;
+
+      /* We don't check for (*str != '\0') here because we want to parse
+	 any trailing fake arguments in the syntax string.  */
+      for (/*str = start, */ syn = opcode->syntax; *syn != '\0'; )
+	{
+	  int mods,index;
+	  const dvp_operand *operand;
+	  const char *errmsg;
+	  long value;
+
+	  /* Non operand chars must match exactly.
+	     Operand chars that are letters are not part of symbols
+	     and are case insensitive.  */
+	  if (*syn < 128)
+	    {
+	      if (TOLOWER (*str) == TOLOWER (*syn))
+		{
+		  if (*syn == ' ')
+		    past_opcode_p = 1;
+		  ++syn;
+		  ++str;
+		}
+	      else
+		break;
+	      continue;
+	    }
+
+	  /* We have a suffix or an operand.  Pick out any modifiers.  */
+	  mods = 0;
+	  index = DVP_OPERAND_INDEX (*syn);
+	  while (DVP_MOD_P (operand_table[index].flags))
+	    {
+	      mods |= operand_table[index].flags & DVP_MOD_BITS;
+	      ++syn;
+	      index = DVP_OPERAND_INDEX (*syn);
+	    }
+	  operand = operand_table + index;
+
+	  if (operand->flags & DVP_OPERAND_FAKE)
+	    {
+	      long parsed_value = 0;
+
+	      if (operand->flags & DVP_OPERAND_DMA_INLINE)
+		{
+		  inline_dma_data ((mods & DVP_OPERAND_AUTOCOUNT) != 0,
+				  insn_buf);
+		  ++syn;
+		  continue;
+		}
+
+	      if (operand->parse)
+		{
+		  errmsg = NULL;
+		  parsed_value = (*operand->parse) (opcode, operand, mods,
+					     &str, &errmsg);
+		  if (errmsg)
+		    break;
+		}
+	      if (operand->insert)
+		{
+		  errmsg = NULL;
+		  (*operand->insert) (opcode, operand, mods, insn_buf,
+				      (offsetT) parsed_value, &errmsg);
+		  /* If we get an error, go on to try the next insn.  */
+		  if (errmsg)
+		    break;
+		}
+	      ++syn;
+	      continue;
+	    }
+
+	  /* Are we finished with suffixes?  */
+	  if (!past_opcode_p)
+	    {
+	      long suf_value;
+
+	      if (!(operand->flags & DVP_OPERAND_SUFFIX))
+		as_fatal ("internal error: bad opcode table, missing suffix flag");
+
+	      /* Parse the suffix.  If we're at a space in the input string
+		 there are no more suffixes.  Suffix parse routines must be
+		 prepared to deal with this.  */
+	      errmsg = NULL;
+	      suf_value = (*operand->parse) (opcode, operand, mods, &str,
+					     &errmsg);
+	      if (errmsg)
+		{
+		  /* This can happen, for example, in ARC's in "blle foo" and
+		     we're currently using the template "b%q%.n %j".  The "bl"
+		     insn occurs later in the table so "lle" isn't an illegal
+		     suffix.  */
+		  break;
+		}
+
+	      /* Insert the suffix's value into the insn.  */
+	      insert_operand (cpu, opcode, operand, mods, insn_buf,
+			      (offsetT) suf_value, &errmsg);
+
+	      ++syn;
+	      continue;
+	    }
+
+	  /* This is an operand, either a register or an expression of
+	     some kind.  */
+
+	  value = 0;
+
+	  if (operand->flags & DVP_OPERAND_SUFFIX)
+	    as_fatal ("internal error: bad opcode table, suffix wrong");
+
+	  /* Is there anything left to parse?
+	     We don't check for this at the top because we want to parse
+	     any trailing fake arguments in the syntax string.  */
+	  /* ??? This doesn't allow operands with a legal value of "".  */
+	  if (*str == '\0')
+	    break;
+
+	  /* Parse the operand.  */
+	  if (operand->flags & DVP_OPERAND_FLOAT)
+	    {
+	      errmsg = 0;
+	      value = parse_float (&str, &errmsg);
+	      if (errmsg)
+		break;
+	    }
+	  else if ((operand->flags & DVP_OPERAND_DMA_ADDR)
+		   && (mods & DVP_OPERAND_AUTOCOUNT))
+	    {
+	      errmsg = 0;
+	      value = parse_dma_addr_autocount (opcode, operand, mods,
+						insn_buf, &str, &errmsg);
+	      if (errmsg)
+		break;
+	    }
+	  else
+	    {
+	      char *origstr,*hold;
+	      expressionS exp;
+
+	      /* First see if there is a special parser.  */
+	      origstr = str;
+	      if (operand->parse)
+		{
+		  errmsg = NULL;
+		  value = (*operand->parse) (opcode, operand, mods,
+					     &str, &errmsg);
+		  if (errmsg)
+		    break;
+		}
+
+	      /* If there wasn't a special parser, or there was and it
+		 left the input stream unchanged, use the general
+		 expression parser.  */
+	      if (str == origstr)
+		{
+		  hold = input_line_pointer;
+		  input_line_pointer = str;
+		  /* Set cur_{opcode,operand} for md_operand.  */
+		  cur_opcode = opcode;
+		  cur_operand = operand;
+		  expression (&exp);
+		  cur_opcode = NULL;
+		  str = input_line_pointer;
+		  input_line_pointer = hold;
+
+		  if (exp.X_op == O_illegal
+		      || exp.X_op == O_absent)
+		    break;
+		  else if (exp.X_op == O_constant)
+		    value = exp.X_add_number;
+		  else if (exp.X_op == O_register)
+		    as_fatal ("internal error: got O_register");
+		  else
+		    {
+		      /* We need to generate a fixup for this expression.  */
+		      if (fixup_count >= MAX_FIXUPS)
+			as_fatal ("internal error: too many fixups");
+		      fixups[fixup_count].cpu = cpu;
+		      fixups[fixup_count].exp = exp;
+		      fixups[fixup_count].opindex = index;
+		      /* FIXME: Revisit.  Do we really need operand->word?
+			 The endianness of a 128 bit DMAtag is rather
+			 twisted.  How about defining word 0 as the word with
+			 the lowest address and basing operand-shift off that.
+			 operand->word could then be deleted.  */
+		      fixups[fixup_count].offset = fixup_offset;
+		      if (operand->word != 0)
+			fixups[fixup_count].offset += operand->word * 4;
+		      else
+			fixups[fixup_count].offset += (operand->shift / 32) * 4;
+		      ++fixup_count;
+		      value = 0;
+		    }
+		}
+	    }
+
+	  /* Insert the register or expression into the instruction.  */
+	  errmsg = NULL;
+	  insert_operand (cpu, opcode, operand, mods, insn_buf,
+			  (offsetT) value, &errmsg);
+	  if (errmsg != (const char *) NULL)
+	    break;
+
+	  ++syn;
+	}
+
+      /* If we're at the end of the syntax string, we're done.  */
+      if (*syn == '\0')
+	{
+	  /* For the moment we assume a valid `str' can only contain blanks
+	     now.  IE: We needn't try again with a longer version of the
+	     insn and it is assumed that longer versions of insns appear
+	     before shorter ones (eg: lsr r2,r3,1 vs lsr r2,r3).  */
+
+	  while (ISSPACE (*str))
+	    ++str;
+
+	  if (*str != '\0'
+#ifndef VERTICAL_BAR_SEPARATOR
+	      && cpu != DVP_VUUP
+#endif
+	      )
+	    as_bad ("junk at end of line: `%s'", str);
+
+	  /* It's now up to the caller to emit the instruction and any
+	     relocations.  */
+	  *pstr = str;
+	  return opcode;
+	}
+
+      /* Try the next entry.  */
+    }
+
+  as_bad ("bad instruction `%s'", start);
+  return 0;
+}
+
+
+/* Given a dvp cpu type, return it's STO_DVP value.
+   The label prefix to use is stored in *PNAME.  */
+
+static int
+cpu_sto (cpu, pname)
+     dvp_cpu cpu;
+     const char **pname;
+{
+  switch (cpu)
+    {
+    case DVP_DMA : *pname = ".dma."; return STO_DVP_DMA;
+    case DVP_VIF : *pname = ".vif."; return STO_DVP_VIF;
+    case DVP_GIF : *pname = ".gif."; return STO_DVP_GIF;
+    case DVP_VUUP : *pname = ".vu."; return STO_DVP_VU;
+    default: abort();
+    }
+}
+
+/* Record the current mach type in the object file.
+   If FORCE_NEXT_P is non-zero, force a label to be emitted the next time
+   we're called.  This is useful for variable length instructions that can
+   have labels embedded within them.  */
+
+static void
+record_mach (cpu, force_next_p)
+     dvp_cpu cpu;
+     int force_next_p;
+{
+  const char *name;
+  int sto;
+
+  if (cpu == cur_cpu)
+    return;
+
+  sto = cpu_sto (cpu, &name);
+
+  create_colon_label (sto, "", unique_name (name));
+
+  if (force_next_p)
+    cur_cpu = DVP_UNKNOWN;
+  else
+    cur_cpu = cpu;
+}
+
+/* Force emission of mach type label at next insn.
+   This isn't static as TC_START_LABEL uses it.
+   The result is the value of TC_START_LABEL.  */
+
+int
+force_mach_label ()
+{
+  cur_cpu = DVP_UNKNOWN;
+  return 1;
+}
+
+/* Push the current parsing state to NEW_STATE.  */
+
+static void
+push_asm_state (new_state)
+     asm_state new_state;
+{
+  ++cur_state_level;
+  if (cur_state_level == MAX_STATE_DEPTH)
+    as_fatal ("internal error: unexpected state push");
+  asm_state_stack[cur_state_level] = new_state;
+}
+
+/* TOP_OK_P is non-zero if it's ok that we're at the top of the stack.
+   If so we reset the state to ASM_INIT.  */
+
+static void
+pop_asm_state (top_ok_p)
+     int top_ok_p;
+{
+  if (cur_state_level == 0)
+    {
+      if (! top_ok_p)
+	as_fatal ("internal error: unexpected state pop");
+      CUR_ASM_STATE = ASM_INIT;
+    }
+  else
+    --cur_state_level;
+}
+
+/* Set the top level assembler state.  */
+
+static void
+set_asm_state (state, insn_name)
+     asm_state state;
+     const char *insn_name;
+{
+  if (insn_name)
+    {
+      if (CUR_ASM_STATE != ASM_INIT)
+	as_bad ("illegal place for `%s' instruction", insn_name);
+    }
+  cur_state_level = 0;
+  CUR_ASM_STATE = state;
+}
+
+
+void 
+md_operand (expressionP)
+     expressionS *expressionP;
+{
+  /* Check if this is a '*' for mpgloc.  */
+  if (cur_opcode
+      && (cur_opcode->flags & VIF_OPCODE_MPG) != 0
+      && (cur_operand->flags & DVP_OPERAND_VU_ADDRESS) != 0
+      && *input_line_pointer == '*')
+    {
+      expressionP->X_op = O_symbol;
+      expressionP->X_add_symbol = mpgloc_sym;
+      expressionP->X_add_number = 0;
+
+      /* Advance over the '*'.  */
+      ++input_line_pointer;
+      return;
+    }
+}
+
+valueT
+md_section_align (segment, size)
+     segT segment;
+     valueT size;
+{
+  int align = bfd_get_section_alignment (stdoutput, segment);
+  return ((size + (1 << align) - 1) & (-1 << align));
+}
+
+symbolS *
+md_undefined_symbol (name)
+  char *name __attribute__((unused));
+{
+  return 0;
+}
+
+/* Called before parsing each line via md_start_line_hook.  */
+
+void
+dvp_start_line_hook ()
+{
+  /* If we've advanced since the last label seen, reset it.  */
+  if (last_label_seen
+      && (now_seg != S_GET_SEGMENT (last_label_seen)
+	  || frag_now != last_label_seen->sy_frag
+	  || frag_now_fix () != S_GET_VALUE (last_label_seen)))
+    {
+      last_label_seen = NULL;
+      last_label_seen2 = NULL;
+    }
+}
+
+/* Called after parsing the file via md_after_pass_hook.  */
+
+void
+dvp_after_pass_hook ()
+{
+  /* If doing dma packing, ensure the last dma tag is filled out.  */
+  if (dma_pack_vif_p)
+    {
+      /* Nothing to do as vifnops are zero and frag_align at beginning
+	 of dmatag is all we need.  */
+    }
+
+#if 0 /* ??? Doesn't work unless we keep track of the nested include file
+	 level.  */
+  /* Check for missing .EndMpg, and supply one if necessary.  */
+  if (CUR_ASM_STATE == ASM_MPG)
+    s_endmpg (ENDMPG_INTERNAL);
+  else if (CUR_ASM_STATE == ASM_DIRECT)
+    s_enddirect (0);
+  else if (CUR_ASM_STATE == ASM_UNPACK)
+    s_endunpack (0);
+#endif
+}
+
+/* Called after parsing all files via md_end.  */
+
+void
+dvp_end ()
+{
+  /* Check for missing .EndMpg, etc.  */
+  if (CUR_ASM_STATE == ASM_MPG)
+    as_bad ("missing `.endmpg'");
+  else if (CUR_ASM_STATE == ASM_DIRECT)
+    as_bad ("missing `.enddirect'");
+  else if (CUR_ASM_STATE == ASM_UNPACK)
+    as_bad ("missing `.endunpack'");
+}
+
+/* Called via tc_frob_label when a label is defined.  */
+
+void
+dvp_frob_label (sym)
+     symbolS *sym;
+{
+  const char * name = S_GET_NAME (sym);
+  /* Non-zero if SYM is a user specified label.  */
+  int user_label_p =
+    (
+     /* Not sure how we can distinguish them other than by some prefix.  */
+     *name != '.' && *name != '$'
+     /* -gstabs creates FAKE_LABEL_NAME labels.  */
+     && ! S_IS_LOCAL (sym)
+     /* Check for recursive invocation creating the _$name.  */
+     && strncmp (name, VU_LABEL_PREFIX, sizeof (VU_LABEL_PREFIX) - 1) != 0
+     /* Machine generated labels to mark the start of overlays.  */
+     && strncmp (name, VUOVERLAY_START_PREFIX, sizeof (VUOVERLAY_START_PREFIX) - 1) != 0
+     );
+
+  /* All labels in vu code must be specially marked for the disassembler.
+     The disassembler ignores all previous information at each new label
+     (that has an address higher than the last one).  */
+  if (CUR_ASM_STATE == ASM_MPG
+      || CUR_ASM_STATE == ASM_VU)
+    S_SET_OTHER (sym, STO_DVP_VU);
+
+  if (! user_label_p)
+    return;
+
+  /* If inside an mpg, move vu space labels to their own section and create
+     the corresponding _$ version in normal space.  */
+
+  if (CUR_ASM_STATE == ASM_MPG)
+    {
+      /* Move this symbol to the vu overlay.  */
+      symbolS * cur_mpgloc = compute_mpgloc (mpgloc_sym, vif_data_start,
+					     expr_build_dot ());
+#if 0 /* Don't do this now, leave in ABS and then move to overlay
+	 section before file is written.  */
+      S_SET_SEGMENT (sym, vuoverlay_section);
+#else
+      /* Record the overlay section this symbol is in.  */
+      {
+	ovlysymS *p = (ovlysymS *) xmalloc (sizeof (ovlysymS));
+	p->next = ovlysym_table;
+	p->sec = vuoverlay_section;
+	p->sym = sym;
+	ovlysym_table = p;
+      }
+      S_SET_SEGMENT (sym, expr_section);
+#endif
+      sym->sy_value = cur_mpgloc->sy_value;
+      sym->sy_frag = &zero_address_frag;
+
+      /* Save for later automagic alignment.  */
+      last_label_seen2 = sym;
+
+      /* Create the _$ symbol in normal space.
+	 This is the one we store in last_label_seen (and not last_label_seen2)
+	 because when the need for automagic alignment is queried, we want
+	 now_seg == S_GET_GETMENT (last_label_seen).  */
+      last_label_seen = create_colon_label (STO_DVP_VU, VU_LABEL_PREFIX, name);
+    }
+  else
+    {
+      /* Save for later automagic alignment.  */
+      last_label_seen = sym;
+      last_label_seen2 = NULL;
+    }
+}
+
+/* Move vu space symbols into their overlay sections.
+   Called via tc_frob_file.  */
+
+void
+dvp_frob_file ()
+{
+  ovlysymS *p;
+
+  for (p = ovlysym_table; p; p = p->next)
+    {
+      /* See the comment near tc_frob_file in write.c.
+	 We are responsible for updating sym->bsym->value.  */
+      S_SET_SEGMENT (p->sym, p->sec);
+      /* Adjust for the section's vma.  */
+      /* FIXME: bfd doesn't get this right, it adds the section vma
+	 back in (in elf.c:swap_out_syms).  As a workaround the
+	 section vma is assumed to be zero.  Of course, there might
+	 not be a point in setting it to non-zero anyway.  */
+      p->sym->bsym->value -= bfd_get_section_vma (stdoutput, p->sec);
+    }
+}
+
+
+/* mpg/direct alignment is handled via relaxation */
+
+/* Return an initial guess of the length by which a fragment must grow to
+   hold a branch to reach its destination.
+   Also updates fr_type/fr_subtype as necessary.
+
+   Called just before doing relaxation.
+   Any symbol that is now undefined will not become defined.
+   The guess for fr_var is ACTUALLY the growth beyond fr_fix.
+   Whatever we do to grow fr_fix or fr_var contributes to our returned value.
+   Although it may not be explicit in the frag, pretend fr_var starts with a
+   0 value.  */
+
+int
+md_estimate_size_before_relax (fragP, segment)
+     fragS * fragP __attribute__((unused));
+     segT segment __attribute__((unused));
+{
+  /* Our initial estimate is always 0.  */
+  return 0;
+} 
+
+/* Perform the relaxation.
+   STRETCH is the amount the start of the frag has already been shifted by.
+   All we have to do is figure out how many bytes we need to insert to
+   get to the recorded symbol (which is at the required alignment).
+   This function is also called for machine dependent vu insn frags.
+   In this case the growth is always 0.  */
+
+long
+dvp_relax_frag (fragP, stretch)
+     fragS * fragP;
+     long stretch;
+{
+  /* Address of variable part.  */
+  long address = fragP->fr_address + fragP->fr_fix;
+  /* Symbol marking start of data.  */
+  symbolS * symbolP = fragP->fr_symbol;
+  /* Address of the symbol.  */
+  long target;
+  long growth;
+
+  /* subtype >= 10 means "done" */
+  if (RELAX_DONE_P (fragP->fr_subtype))
+    return 0;
+
+  /* vu insn? */
+  if (fragP->fr_subtype == RELAX_VU)
+    {
+      fragP->fr_subtype = RELAX_ENCODE (RELAX_VU, 0);
+      return 0;
+    }
+
+  target = S_GET_VALUE (symbolP) + symbolP->sy_frag->fr_address;
+
+  if (fragP->fr_subtype == RELAX_MPG)
+    {
+      /* The frag the symbol is in hasn't been relaxed yet so any .org
+	 adjustments haven't been applied to it.  We know the symbol
+	 is the address of the next frag so adjust target by stretch.  */
+      target += stretch;
+      growth = target - address;
+      if (growth < 0)
+	as_fatal ("internal error: bad mpg alignment handling");
+      fragP->fr_subtype = RELAX_ENCODE (RELAX_MPG, growth);
+      return growth;
+    }
+
+  if (fragP->fr_subtype == RELAX_DIRECT)
+    {
+      /* The frag the symbol is in hasn't been relaxed yet so any .org
+	 adjustments haven't been applied to it.  We know the symbol
+	 is the address of the next frag so adjust target by stretch.  */
+      target += stretch;
+      growth = target - address;
+      if (growth < 0)
+	as_fatal ("internal error: bad direct alignment handling");
+      fragP->fr_subtype = RELAX_ENCODE (RELAX_DIRECT, growth);
+      return growth;
+    }
+
+  as_fatal ("internal error: unknown fr_subtype");
+}
+
+/* *fragP has been relaxed to its final size, and now needs to have
+   the bytes inside it modified to conform to the new size.
+
+   Called after relaxation is finished.
+   fragP->fr_type == rs_machine_dependent.
+   fragP->fr_subtype is the subtype of what the address relaxed to.  */
+
+void
+md_convert_frag (abfd, sec, fragP)
+  bfd * abfd __attribute__((unused));
+  segT sec __attribute__((unused));
+  fragS * fragP;
+{
+  int growth = RELAX_GROWTH (fragP->fr_subtype);
+
+  fragP->fr_fix += growth;
+
+  if (growth != 0)
+    {
+      /* We had to grow this fragment.  Shift the mpg/direct insn to the end
+	 (so it abuts the following data).  */
+      DVP_INSN insn = bfd_getl32 (fragP->fr_opcode);
+      md_number_to_chars (fragP->fr_opcode, VIFNOP, 4);
+      if (growth > 4)
+	md_number_to_chars (fragP->fr_opcode + 4, VIFNOP, 4);
+      if (growth > 8)
+	md_number_to_chars (fragP->fr_opcode + 8, VIFNOP, 4);
+      md_number_to_chars (fragP->fr_literal + fragP->fr_fix - 4, insn, 4);
+
+      /* Adjust fr_opcode so md_apply_fix works with the right bytes.  */
+      fragP->fr_opcode += growth;
+    }
+}
+
+
+/* Functions concerning relocs.  */
+
+/* Spacing between each cpu type's operand numbers.
+   Should be at least as big as any operand table.  */
+#define RELOC_SPACING 256
+
+/* Given a cpu type and operand number, return a temporary reloc type
+   for use in generating the fixup that encodes the cpu type and operand
+   number.  */
+
+static unsigned int
+encode_fixup_reloc_type (cpu, opnum)
+     dvp_cpu cpu;
+     int opnum;
+{
+  return (unsigned int) BFD_RELOC_UNUSED + ((unsigned int) cpu * RELOC_SPACING) + opnum;
+}
+
+/* Given a fixup reloc type, decode it into cpu type and operand.  */
+
+static void
+decode_fixup_reloc_type (fixup_reloc, cpuP, operandP)
+     int fixup_reloc;
+     dvp_cpu *cpuP;
+     const dvp_operand **operandP;
+{
+  dvp_cpu cpu = (fixup_reloc - (int) BFD_RELOC_UNUSED) / RELOC_SPACING;
+  int opnum = (fixup_reloc - (int) BFD_RELOC_UNUSED) % RELOC_SPACING;
+
+  *cpuP = cpu;
+  switch (cpu)
+    {
+    case DVP_VUUP : *operandP = &vu_operands[opnum]; break;
+    case DVP_VULO : *operandP = &vu_operands[opnum]; break;
+    case DVP_DMA : *operandP = &dma_operands[opnum]; break;
+    case DVP_VIF : *operandP = &vif_operands[opnum]; break;
+    case DVP_GIF : *operandP = &gif_operands[opnum]; break;
+    default : as_fatal ("internal error: bad fixup encoding");
+    }
+}
+
+/* The location from which a PC relative jump should be calculated,
+   given a PC relative reloc.  */
+
+long
+md_pcrel_from_section (fixP, sec)
+     fixS *fixP __attribute__((unused));
+     segT sec;
+{
+  if (fixP->fx_addsy != (symbolS *) NULL
+      && (! S_IS_DEFINED (fixP->fx_addsy)
+	  || S_GET_SEGMENT (fixP->fx_addsy) != sec))
+    {
+      /* If fx_tcbit is set this is for a vif insn and thus should never
+	 happen in correct code.  */
+      /* ??? The error message could be a bit more descriptive.  */
+      if (fixP->fx_tcbit)
+	as_bad ("unable to compute length of vif insn");
+      /* The symbol is undefined (or is defined but not in this section).
+	 Let the linker figure it out.  +8: branch offsets are relative to the
+	 delay slot.  */
+      return 8;
+    }
+
+  /* If fx_tcbit is set, this is a vif end-of-variable-length-insn marker.
+     In this case the offset is relative to the start of data.
+     Otherwise we assume this is a vu branch.  In this case
+     offsets are calculated based on the address of the next insn.  */
+  if (fixP->fx_tcbit)
+    {
+      /* As a further refinement, if fr_opcode is NULL this is `unpack'
+	 which doesn't involve any relaxing.  */
+      if (fixP->fx_frag->fr_opcode == NULL)
+	return fixP->fx_frag->fr_address + fixP->fx_where + 4;
+      else
+	return fixP->fx_frag->fr_address + fixP->fx_frag->fr_fix;
+    }
+  else
+    return ((fixP->fx_frag->fr_address + fixP->fx_where) & -8L) + 8;
+}
+
+/* Apply a fixup to the object code.  This is called for all the
+   fixups we generated by calls to fix_new_exp.  At this point all symbol
+   values should be fully resolved, and we attempt to completely resolve the
+   reloc.  If we can not do that, we determine the correct reloc code and put
+   it back in the fixup.  */
+
+void
+md_apply_fix (fixP, valueP, seg)
+     fixS *fixP;
+     valueT *valueP;
+     segT seg __attribute__((unused));
+{
+  char *where = fixP->fx_frag->fr_literal + fixP->fx_where;
+  valueT value;
+
+  /* FIXME FIXME FIXME: The value we are passed in *valueP includes
+     the symbol values.  Since we are using BFD_ASSEMBLER, if we are
+     doing this relocation the code in write.c is going to call
+     bfd_perform_relocation, which is also going to use the symbol
+     value.  That means that if the reloc is fully resolved we want to
+     use *valueP since bfd_perform_relocation is not being used.
+     However, if the reloc is not fully resolved we do not want to use
+     *valueP, and must use fx_offset instead.  However, if the reloc
+     is PC relative, we do want to use *valueP since it includes the
+     result of md_pcrel_from.  This is confusing.  */
+
+  if (fixP->fx_addsy == (symbolS *) NULL)
+    {
+      value = *valueP;
+      fixP->fx_done = 1;
+    }
+  else if (fixP->fx_pcrel)
+    {
+      value = *valueP;
+    }
+  /* If this is for mpgloc and the value is a label in vu space, we
+     know its value.  We don't handle emitting a relocation for this
+     so handle it specially here.
+     The test of fx_tcbit is a quick test to avoid unnecessary cpu.  */
+  else if (fixP->fx_tcbit
+	   && fixP->fx_r_type == encode_fixup_reloc_type (DVP_VIF, vif_operand_mpgloc)
+	   && vuoverlay_section_p (S_GET_SEGMENT (fixP->fx_addsy)))
+    {
+      value = *valueP;
+    }
+  else
+    {
+      value = fixP->fx_offset;
+      if (fixP->fx_subsy != (symbolS *) NULL)
+	{
+	  if (S_GET_SEGMENT (fixP->fx_subsy) == absolute_section)
+	    value -= S_GET_VALUE (fixP->fx_subsy);
+	  else
+	    {
+	      /* We can't actually support subtracting a symbol.  */
+	      as_bad_where (fixP->fx_file, fixP->fx_line,
+			    "expression too complex");
+	    }
+	}
+    }
+
+  /* Check for dvp operands.  These are indicated with a reloc value
+     >= BFD_RELOC_UNUSED.  */
+
+  if ((int) fixP->fx_r_type >= (int) BFD_RELOC_UNUSED)
+    {
+      dvp_cpu cpu;
+      const dvp_operand *operand;
+      DVP_INSN insn;
+      fragS *fragP = fixP->fx_frag;
+
+      /* If this was a relaxable insn, the opcode may have moved.  Find it.  */
+      if (fragP->fr_opcode != NULL)
+	where = fragP->fr_opcode;
+
+      decode_fixup_reloc_type ((int) fixP->fx_r_type,
+			       & cpu, & operand);
+
+      /* For variable length vif insn data lengths, validate the user specified
+	 value or install the computed value in the instruction.  */
+      if (cpu == DVP_VIF
+	  && (operand - vif_operands) == vif_operand_datalen_special)
+	{
+	  int insn_type = vif_insn_type (where[3]);
+	  value = vif_length_value (where[3],
+				    fixP->tc_fix_data.wl, fixP->tc_fix_data.cl,
+				    value);
+	  if (fixP->tc_fix_data.user_value != -1)
+	    {
+	      /* We can't do this for unpack insns with wl > cl.  */
+	      if ((insn_type != VIF_OPCODE_UNPACK
+		   || (fixP->tc_fix_data.wl <= fixP->tc_fix_data.cl))
+		  && fixP->tc_fix_data.user_value != (int)value)
+		as_warn_where (fixP->fx_file, fixP->fx_line,
+			       "specified length value doesn't match computed value");
+	      /* Don't override the user specified value.  */
+	    }
+	  else
+	    {
+	      if (output_vif)
+		{
+		  install_vif_length (where, value);
+		}
+	    }
+	  fixP->fx_done = 1;
+	  return;
+	}
+
+      /* For the gif nloop operand, if it was specified by the user ensure
+	 it matches the value we computed.  */
+      if (cpu == DVP_GIF
+	  && (operand - gif_operands) == gif_operand_nloop)
+	{
+	  value = compute_nloop (fixP->tc_fix_data.type,
+				 fixP->tc_fix_data.nregs,
+				 value);
+	  if (fixP->tc_fix_data.user_value != -1)
+	    {
+	      check_nloop (fixP->tc_fix_data.type,
+			   fixP->tc_fix_data.nregs,
+			   fixP->tc_fix_data.user_value,
+			   value,
+			   fixP->fx_file, fixP->fx_line);
+	      /* Don't override the user specified value.  */
+	      fixP->fx_done = 1;
+	      return;
+	    }
+	}
+
+      /* ??? It might be cleaner to not do this at all here (when ! fx_done)
+	 and leave it to bfd_install_relocation.  */
+      if ((operand->flags & DVP_OPERAND_RELOC_U15_S3) != 0)
+	value >>= 3;
+      else if ((operand->flags & DVP_OPERAND_RELOC_11_S4) != 0)
+	value >>= 4;
+
+      /* Fetch the instruction, insert the fully resolved operand
+	 value, and stuff the instruction back again.  The fixup is recorded
+	 at the appropriate word so pass DVP_MOD_THIS_WORD so any offset
+	 specified in the tables is ignored.  */
+      insn = bfd_getl32 ((unsigned char *) where);
+      insert_operand_final (cpu, operand, DVP_MOD_THIS_WORD, &insn,
+			    (offsetT) value, fixP->fx_file, fixP->fx_line);
+      bfd_putl32 ((bfd_vma) insn, (unsigned char *) where);
+
+      /* If this is mpgloc/unpackloc, we're done.  */
+      if (operand->flags & (DVP_OPERAND_VU_ADDRESS | DVP_OPERAND_UNPACK_ADDRESS))
+	fixP->fx_done = 1;
+
+      if (fixP->fx_done)
+	{
+	  /* Nothing else to do here.  */
+	  return;
+	}
+
+      /* Determine a BFD reloc value based on the operand information.
+	 We are only prepared to turn a few of the operands into relocs.  */
+      if ((operand->flags & DVP_OPERAND_RELATIVE_BRANCH) != 0)
+	{
+	  assert (operand->bits == 11
+		  && operand->shift == 0);
+
+	  /* The fixup isn't recorded as a pc relative branch to some label.
+	     Instead a complicated expression is used to compute the desired
+	     value.  Well, that didn't work and we have to emit a reloc.
+	     Things are tricky because the result we want is the difference
+	     of two addresses in a section potentially different from the one
+	     the reloc is in.  Ugh.
+	     The solution is to emit two relocs, one that adds the target
+	     address and one that subtracts the source address + 8 (the
+	     linker will perform the byte->dword conversion).
+	     This is rather complicated and rather than risk breaking
+	     existing code we fall back on the old way if the file only
+	     contains vu code.  In this case the file is intended to
+	     be fully linked with other vu code and thus we have a normal
+	     situation where the relocation directly corresponds to the
+	     branch insn.  */
+
+	  if (non_vu_insn_seen_p)
+	    {
+	      as_bad_where (fixP->fx_file, fixP->fx_line,
+			    "can't handle mpg loaded vu code with branch relocations");
+	      fixP->fx_done = 1;
+	      return;
+	    }
+	  else
+	    {
+	      fixP->fx_r_type = BFD_RELOC_MIPS_DVP_11_PCREL;
+	    }
+	}
+      else if ((operand->flags & DVP_OPERAND_DMA_ADDR) != 0
+	       || (operand->flags & DVP_OPERAND_DMA_NEXT) != 0)
+	{
+	  assert (operand->bits == 27
+		  && operand->shift == 4);
+	  fixP->fx_r_type = BFD_RELOC_MIPS_DVP_27_S4;
+	}
+      else if ((operand->flags & DVP_OPERAND_RELOC_11_S4) != 0)
+	{
+	  assert (operand->bits == 11
+		  && operand->shift == 0);
+	  fixP->fx_r_type = BFD_RELOC_MIPS_DVP_11_S4;
+	  /* ??? bfd_install_relocation will duplicate what we've done to
+	     install the addend, so tell it not to.  This is an instance
+	     where setting partial_inplace to true has some use.  */
+	  value = 0;
+	}
+      else if ((operand->flags & DVP_OPERAND_RELOC_U15_S3) != 0)
+	{
+	  assert (operand->bits == 15
+		  && operand->shift == 0);
+	  fixP->fx_r_type = BFD_RELOC_MIPS_DVP_U15_S3;
+	  /* ??? bfd_install_relocation will duplicate what we've done to
+	     install the addend, so tell it not to.  This is an instance
+	     where setting partial_inplace to true has some use.  */
+	  value = 0;
+	}
+      else
+	{
+	  as_bad_where (fixP->fx_file, fixP->fx_line,
+			"unresolved expression that must be resolved");
+	  fixP->fx_done = 1;
+	  return;
+	}
+    }
+  else if (fixP->fx_done)
+    {
+      /* We're finished with this fixup.  Install it because
+	 bfd_install_relocation won't be called to do it.  */
+      switch (fixP->fx_r_type)
+	{
+	case BFD_RELOC_8:
+	  md_number_to_chars (where, value, 1);
+	  break;
+	case BFD_RELOC_16:
+	  md_number_to_chars (where, value, 2);
+	  break;
+	case BFD_RELOC_32:
+	  md_number_to_chars (where, value, 4);
+	  break;
+	case BFD_RELOC_64:
+	  md_number_to_chars (where, value, 8);
+	  break;
+	default:
+	  as_fatal ("internal error: unexpected fixup");
+	}
+    }
+  else
+    {
+      /* bfd_install_relocation will be called to finish things up.  */
+    }
+
+  /* Tuck `value' away for use by tc_gen_reloc.
+     See the comment describing fx_addnumber in write.h.  */
+  fixP->fx_addnumber = value;
+
+  return;
+}
+
+/* Translate internal representation of relocation info to BFD target
+   format.  */
+
+arelent *
+tc_gen_reloc (section, fixP)
+     asection *section __attribute__((unused));
+     fixS *fixP;
+{
+  arelent *reloc;
+
+  reloc = (arelent *) xmalloc (sizeof (arelent));
+
+  reloc->sym_ptr_ptr = &fixP->fx_addsy->bsym;
+  reloc->address = fixP->fx_frag->fr_address + fixP->fx_where;
+  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixP->fx_r_type);
+  if (reloc->howto == (reloc_howto_type *) NULL)
+    {
+      as_bad_where (fixP->fx_file, fixP->fx_line,
+		    "internal error: can't export reloc type %d (`%s')",
+		    fixP->fx_r_type, bfd_get_reloc_code_name (fixP->fx_r_type));
+      return NULL;
+    }
+
+  if (!fixP->fx_pcrel != !reloc->howto->pc_relative)
+    {
+      as_bad_where (fixP->fx_file, fixP->fx_line,
+		    fixP->fx_pcrel
+		    ? "PC-relative reloc not supported here"
+		    : "PC-relative reloc required here");
+      return NULL;
+    }
+
+  reloc->addend = fixP->fx_addnumber;
+
+  return reloc;
+}
+
+
+/* Write a value out to the object file, using the appropriate endianness.  */
+
+void
+md_number_to_chars (buf, val, n)
+     char *buf;
+     valueT val;
+     int n;
+{
+  if (target_big_endian)
+    number_to_chars_bigendian (buf, val, n);
+  else
+    number_to_chars_littleendian (buf, val, n);
+}
+
+/* Turn a string in input_line_pointer into a floating point constant of type
+   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
+   emitted is stored in *sizeP .  An error message is returned, or NULL on OK.
+*/
+
+/* Equal to MAX_PRECISION in atof-ieee.c */
+#define MAX_LITTLENUMS 6
+
+char *
+md_atof (type, litP, sizeP)
+     char type;
+     char *litP;
+     int *sizeP;
+{
+	return ieee_md_atof(type, litP, sizeP, target_big_endian);
+}
+
+
+/* Miscellaneous utilities.  */
+
+/* Parse a 32 bit floating point number.
+   The result is those 32 bits as an integer.  */
+
+static long
+parse_float (pstr, errmsg)
+     char **pstr;
+     const char **errmsg __attribute__((unused));
+{
+  if ((*pstr)[0] == '0'
+      && ((*pstr)[1] == 'x' || (*pstr)[1] == 'X'))
+    {
+      long value;
+      (*pstr) += 2;
+      value = strtoul (*pstr, pstr, 16);
+      return value;
+    }
+  else
+    {
+      LITTLENUM_TYPE words[MAX_LITTLENUMS];
+      if ((*pstr)[0] == '0'
+	  && ISALPHA ((*pstr)[1]))
+	(*pstr) += 2;
+      *pstr = atof_ieee (*pstr, 'f', words);
+      return (words[0] << 16) | words[1];
+    }
+}
+
+/* Scan a symbol and return a pointer to one past the end.  */
+
+#define issymchar(ch) (ISALNUM(ch) || ch == '_')
+static const char *
+scan_symbol (sym)
+    const char *sym;
+{
+  while (*sym && issymchar (*sym))
+    ++sym;
+  return sym;
+}
+
+/* Evaluate an expression for an operand.
+   The result is the value of the expression if it can be evaluated,
+   or 0 if it cannot (say because some symbols haven't been defined yet)
+   in which case a fixup is queued.
+
+   If OPINDEX is 0, don't queue any fixups, just return 0.  */
+
+static long
+eval_expr (dvp_cpu cpu, int opindex, int offset, const char *fmt, ...)
+{
+  long value;
+  va_list ap;
+  char *str,*save_input;
+  expressionS exp;
+
+  va_start (ap, fmt);
+  vasprintf (&str, fmt, ap);
+  va_end (ap);
+
+  save_input = input_line_pointer;
+  input_line_pointer = str;
+  expression (&exp);
+  input_line_pointer = save_input;
+  free (str);
+  if (exp.X_op == O_constant)
+    value = exp.X_add_number;
+  else
+    {
+      if (opindex != 0)
+	{
+	  fixups[fixup_count].cpu = cpu;
+	  fixups[fixup_count].exp = exp;
+	  fixups[fixup_count].opindex = opindex;
+	  fixups[fixup_count].offset = offset;
+	  fixups[fixup_count].user_value = -1;
+	  fixups[fixup_count].wl = -1;
+	  fixups[fixup_count].cl = -1;
+	  ++fixup_count;
+	}
+      value = 0;
+    }
+  return value;
+}
+
+/* Create a label named by concatenating PREFIX to NAME.  */
+
+static symbolS *
+create_label (const char *prefix, const char *name)
+{
+  int namelen = strlen (name);
+  int prefixlen = strlen (prefix);
+  char *fullname;
+  symbolS *result;
+
+  fullname = xmalloc (prefixlen + namelen + 1);
+  strcpy (fullname, prefix);
+  strcat (fullname, name);
+  result = symbol_find_or_make (fullname);
+  free (fullname);
+  return result;
+}
+
+/* Create a label named by concatenating PREFIX to NAME,
+   and define it as `.'.
+   STO, if non-zero, is the st_other value to assign to this label.
+   If STO is zero `cur_cpu', call force_mach_label to force record_mach to
+   emit a cpu label.  Otherwise the disassembler gets confused.  */
+
+static symbolS *
+create_colon_label (sto, prefix, name)
+     int sto;
+     const char *prefix, *name;
+{
+  int namelen = strlen (name);
+  int prefixlen = strlen (prefix);
+  char *fullname;
+  symbolS *result;
+
+  fullname = xmalloc (prefixlen + namelen + 1);
+  strcpy (fullname, prefix);
+  strcat (fullname, name);
+  result = colon (fullname);
+  if (sto)
+    S_SET_OTHER (result, sto);
+  else
+    force_mach_label ();
+  free (fullname);
+  return result;
+}
+
+/* Return a malloc'd string useful in creating unique labels.
+   PREFIX is the prefix to use or NULL if we're to pick one.  */
+
+static char *
+unique_name (prefix)
+     const char *prefix;
+{
+  static int counter;
+  char *result;
+
+  if (prefix == NULL)
+    prefix = UNIQUE_LABEL_PREFIX;
+  asprintf (&result, "%s%d", prefix, counter);
+  ++counter;
+  return result;
+}
+
+
+/* VU support.  */
+
+/* Return a boolean indicating if SEG is a vu overlay section.  */
+
+static int
+vuoverlay_section_p (seg)
+     segT seg;
+{
+  return (strncmp (segment_name (seg), SHNAME_DVP_OVERLAY_PREFIX,
+		   sizeof (SHNAME_DVP_OVERLAY_PREFIX) - 1)
+	  == 0);
+}
+
+/* Return the name of the overlay section.
+   It must be unique among all overlays in the executable.  */
+
+static char *
+vuoverlay_section_name (addr)
+     symbolS *addr;
+{
+  char *section_name;
+  char *file;
+  unsigned int lineno;
+  unsigned int fileno;
+  /* One mpg may actually result in several, counter keeps track of this.  */
+  static int counter;
+
+  as_where (&file, &lineno);
+  for (fileno = 0; *file; ++file)
+    fileno = (fileno << 1) + *file;
+  if (addr->sy_value.X_op == O_constant)
+    asprintf (&section_name, "%s.0x%x.%u.%u.%d", SHNAME_DVP_OVERLAY_PREFIX,
+	      (int) S_GET_VALUE (addr), fileno, lineno, counter);
+  else
+    asprintf (&section_name, "%s.unknvma.%u.%u.%d", SHNAME_DVP_OVERLAY_PREFIX,
+	      fileno, lineno, counter);
+  ++counter;
+  return section_name;
+}
+
+/* Create a shadow section for VU code that starts at ADDR in vu space.
+   START_LABEL and END_LABEL, if non-NULL, are symbols marking the start and
+   end of the section.  If NULL, no overlay tracking information is output.  */
+
+static void
+create_vuoverlay_section (section_name, addr, start_label, end_label)
+     const char *section_name;
+     /* Remember, expressions are recorded as symbols.  */
+     symbolS *addr;
+     symbolS *start_label, *end_label;
+{
+  /* Must preserve the current seg/subseg.  */
+  segT orig_seg = now_seg;
+  subsegT orig_subseg = now_subseg;
+
+  /* Create and get handle of a vu overlay section.  All vu symbols go here.
+     The section name must be unique in the entire executable.
+     We achieve this by encoding the source file name and file number.  Ick.
+     ??? A cleaner way would be if mpg took a new argument that named the
+     overlay.  */
+  vuoverlay_section = subseg_new (section_name, 0);
+  bfd_set_section_flags (stdoutput, vuoverlay_section, SEC_CODE);
+  /* There's no point in setting the section vma as we can't get the linker
+     to preserve it.  But what the heck ...  It might be useful to the
+     objdump user.  */
+#if 0  /* FIXME: bfd's elf.c:swap_out_syms always emits symbol values with
+	  the section vma added in so we can't do this.  */
+  if (addr->sy_value.X_op == O_constant)
+    bfd_set_section_vma (stdoutput, vuoverlay_section, S_GET_VALUE (addr));
+#endif
+
+#if 1
+  /* Create a symbol marking the start of the section.
+     This is different than START_LABEL as this one is for gdb.
+     It needs a symbol to start a section so we give it one.
+     This one could be combined with START_LABEL, but I haven't since
+     they serve different purposes.  */
+  {
+    symbolS * gdb_start_sym;
+    gdb_start_sym = create_colon_label (STO_DVP_VU, VUOVERLAY_START_PREFIX,
+					section_name);
+    gdb_start_sym->sy_value = addr->sy_value;
+  }
+#endif
+
+  /* The size of the section won't be known until we see the .endmpg,
+     but we can compute it from the start and end labels.  */
+  /* FIXME: This causes the section to occupy space in the file.  */
+  if (start_label)
+    frag_var (rs_space, 1, 1, (relax_substateT) 0,
+	      expr_build_binary (O_subtract, end_label, start_label),
+	      (offsetT) 0, (char *) 0);
+
+#if 0 /* already done */
+  /* Initialize $.mpgloc.  */
+  mpgloc_sym = expr_build_uconstant (addr);
+  S_SET_OTHER (mpgloc_sym, STO_DVP_VU);
+#endif
+
+#if 0 /* $.mpgloc is kept in the ABS section.  */
+  S_SET_SEGMENT (mpgloc_sym, vuoverlay_section);
+#endif
+
+  /* Add an entry to the vu overlay table.  */
+  if (start_label)
+    {
+      expressionS exp;
+      const char *p;
+      symbolS * name_label;
+
+      /* Put the section name in the overlay string table.  */
+
+      subseg_set (vuoverlay_string_section, 0);
+      name_label = create_colon_label (0, DVP_LOCAL_LABEL_PREFIX,
+				       unique_name ("secstr"));
+      /* FIXME: should be a utility to do this.  */
+      for (p = section_name; *p; ++p)
+	FRAG_APPEND_1_CHAR (*p);
+      FRAG_APPEND_1_CHAR (0);
+
+      subseg_set (vuoverlay_table_section, 0);
+
+      /* FIXME: should be a utility to do these.  */
+      /* Offset into string table.  */
+      exp.X_op = O_symbol;
+      exp.X_add_symbol = name_label;
+      exp.X_add_number = 0;
+      emit_expr (&exp, 4);
+
+      /* The section's lma.  */
+      exp.X_op = O_symbol;
+      exp.X_add_symbol = start_label;
+      exp.X_add_number = 0;
+      emit_expr (&exp, 4);
+
+      /* The section's vma.  */
+      exp.X_op = O_symbol;
+      exp.X_add_symbol = addr;
+      exp.X_add_number = 0;
+      emit_expr (&exp, 4);
+    }
+
+  /* Restore the original seg/subseg.  */
+  subseg_set (orig_seg, orig_subseg);
+}
+
+/* Compute a value for $.mpgloc given a symbol at the start of a chunk
+   of code, the $.mpgloc value for the start, and a symbol at the end
+   of the chunk of code.  */
+
+static symbolS *
+compute_mpgloc (startloc, startsym, endsym)
+     symbolS * startloc;
+     symbolS * startsym;
+     symbolS * endsym;
+{
+  symbolS *s;
+
+  s = expr_build_binary (O_subtract, endsym, startsym);
+  s = expr_build_binary (O_add, startloc, s);
+  return s;
+}
+
+
+/* Compute a value for nloop.  */
+
+static int
+compute_nloop (type, nregs, bytes)
+     gif_type type;
+     int nregs, bytes;
+{
+  int computed_nloop;
+
+  switch (type)
+    {
+    case GIF_PACKED :
+      /* We can't compute a value if no regs were specified and there is a
+	 non-zero amount of data.  Just set to something useful, a warning
+	 will be issued later.  */
+      if (nregs == 0)
+	nregs = 1;
+      computed_nloop = (bytes >> 4) / nregs;
+      break;
+    case GIF_REGLIST :
+      if (nregs == 0)
+	nregs = 1;
+      computed_nloop = (bytes >> 3) / nregs;
+      break;
+    case GIF_IMAGE :
+      computed_nloop = bytes >> 4;
+      break;
+    default :
+      abort();
+    }
+
+  return computed_nloop;
+}
+
+/* Issue a warning if the user specified nloop value doesn't match the
+   computed value.  */
+
+static void
+check_nloop (type, nregs, user_nloop, computed_nloop, file, line)
+     gif_type type __attribute__((unused));
+     int nregs __attribute__((unused)),user_nloop,computed_nloop;
+     char *file;
+     unsigned int line;
+{
+  if (user_nloop != computed_nloop)
+    as_warn_where (file, line, "nloop value does not match amount of data");
+}
+
+
+/* Compute the auto-count value for a DMA tag.
+   INLINE_P is non-zero if the dma data is inline.  */
+
+static void
+setup_dma_autocount (name, insn_buf, inline_p)
+     const char *name;
+     DVP_INSN *insn_buf;
+     int inline_p;
+{
+  long count;
+
+  if (inline_p)
+    {
+      /* -1: The count is the number of following quadwords, so skip the one
+	 containing the dma tag.  */
+      count = eval_expr (DVP_DMA, dma_operand_count, 0,
+			 "((%s%s - %s) >> 4) - 1", END_LABEL_PREFIX, name, name);
+    }
+  else
+    {
+      /* We don't want to subtract 1 here as the begin and end labels
+	 properly surround the data we want to compute the length of.  */
+      count = eval_expr (DVP_DMA, dma_operand_count, 0,
+			 "(%s%s - %s) >> 4", END_LABEL_PREFIX, name, name);
+    }
+
+  /* Store the count field. */
+  insn_buf[0] &= 0xffff0000;
+  insn_buf[0] |= count & 0x0000ffff;
+}
+
+/* Record that inline data follows.  */
+
+static void
+inline_dma_data (autocount_p, insn_buf)
+    int autocount_p;
+    DVP_INSN *insn_buf;
+{
+  if (dma_data_state != 0 )
+    {
+      as_bad ("DmaData blocks cannot be nested.");
+      return;
+    }
+
+  dma_data_state = 1;
+
+  if (autocount_p)
+    {
+      dma_data_name = S_GET_NAME (create_colon_label (0, "", unique_name (NULL)));
+      setup_dma_autocount (dma_data_name, insn_buf, 1);
+    }
+  else
+    dma_data_name = 0;
+}
+
+/* Compute the auto-count value for a DMA tag with out-of-line data.  */
+
+static long
+parse_dma_addr_autocount (opcode, operand, mods, insn_buf, pstr, errmsg)
+    const dvp_opcode *opcode __attribute__((unused));
+    const dvp_operand *operand __attribute__((unused));
+    int mods __attribute__((unused));
+    DVP_INSN *insn_buf;
+    char **pstr;
+    const char **errmsg;
+{
+  char *start = *pstr;
+  char *end = start;
+  long retval;
+  const char *name;
+  char c;
+
+  if (! is_name_beginner (*start))
+    {
+      *errmsg = "invalid .DmaData label";
+      return 0;
+    }
+
+  name = start;
+  end = (char*)scan_symbol (name);
+  c = *end;
+  *end = 0;
+  symbol_find_or_make (name);
+  *end = c;
+
+  /* Use the same prefix as vu labels here.  */
+  create_label (VU_LABEL_PREFIX, name);
+  create_label (END_LABEL_PREFIX, name);
+
+  retval = eval_expr (DVP_DMA, dma_operand_addr, 4, name);
+
+  setup_dma_autocount (name, insn_buf, 0);
+
+  *pstr = end;
+  return retval;
+}
+
+
+/* Compute the type of vif insn of IBYTE.
+   IBYTE is the msb of the insn.
+   This is only used for mpg,direct,unpack insns.
+   The result is one of VIF_OPCODE_{DIRECT,DIRECTHL,MPG,UNPACK}.  */
+
+int
+vif_insn_type (char ibyte)
+{
+  switch (ibyte & 0x70)
+    {
+    case 0x50 :
+      return (ibyte & 1) ? VIF_OPCODE_DIRECTHL : VIF_OPCODE_DIRECT;
+    case 0x40 :
+      return VIF_OPCODE_MPG;
+    case 0x60 :
+    case 0x70 :
+      return VIF_OPCODE_UNPACK;
+    default :
+      as_fatal ("internal error: bad call to vif_insn_type");
+    }
+}
+
+/* Return the length value to insert in a VIF instruction whose upper
+   byte is IBYTE and whose data length is BYTES.
+   WL,CL are used for unpack insns and are the stcycl values in effect.
+   This does not do the max -> 0 conversion.  */
+
+int
+vif_length_value (char ibyte, int wl, int cl, int bytes)
+{
+  switch (ibyte & 0x70)
+    {
+    case 0x50 : /* direct */
+      /* ??? Worry about data /= 16 cuts off?  */
+      return bytes / 16;
+    case 0x40 : /* mpg */
+      /* ??? Worry about data /= 8 cuts off?  */
+      return bytes / 8;
+    case 0x60 : /* unpack */
+    case 0x70 :
+      return vif_unpack_len_value (ibyte & 15, wl, cl, bytes);
+    default :
+      as_fatal ("internal error: bad call to vif_length_value");
+    }
+}
+
+/* Install length LEN in the vif insn at BUF.
+   LEN is the actual value to store, except that the max->0 conversion
+   hasn't been done (we do it).
+   The bytes in BUF are in target order.  */
+
+static void
+install_vif_length (buf, len)
+     char *buf;
+     int len;
+{
+  unsigned char ibyte = buf[3];
+
+  if ((ibyte & 0x70) == 0x40)
+    {
+      /* mpg */
+      if (len > 256)
+	as_bad ("`mpg' data length must be between 1 and 256");
+      buf[2] = len == 256 ? 0 : len;
+    }
+  else if ((ibyte & 0x70) == 0x50)
+    {
+      /* direct/directhl */
+      if (len > 65536)
+	as_bad ("`direct' data length must be between 1 and 65536");
+      len = len == 65536 ? 0 : len;
+      buf[0] = len;
+      buf[1] = len >> 8;
+    }
+  else if ((ibyte & 0x60) == 0x60)
+    {
+      /* unpack */
+      /* len == -1 means wl,cl are unknown and thus we can't compute
+	 a useful value */
+      if (len == -1)
+	{
+	  as_bad ("missing `stcycle', can't compute length of `unpack' insn");
+	  len = 1;
+	}
+      if (len < 0 || len > 256)
+	as_bad ("`unpack' data length must be between 0 and 256");
+      /* 256 is recorded as 0 in the insn */
+      len = len == 256 ? 0 : len;
+      buf[2] = len;
+    }
+  else
+    as_fatal ("internal error: bad call to install_vif_length");
+}
+
+/* Finish off the current set of mpg insns, and start a new set.
+   The IGNORE arg exists because insert_unpack_marker uses it and both
+   of these functions are passed to insert_file.  */
+
+static void
+insert_mpg_marker (ignore)
+     unsigned long ignore __attribute__((unused));
+{
+  s_endmpg (ENDMPG_MIDDLE);
+  /* mpgloc is updated by s_endmpg.  */
+  md_assemble ("mpg *,*");
+  /* Record the cpu type in case we're in the middle of reading binary
+     data.  */
+  record_mach (DVP_VUUP, 0);
+  /* We need a stabs line number entry at the start of the vu code.
+     This has already been called, but too early and we can't stop that.
+     So just emit another.  */
+  generate_lineno_debug ();
+}
+
+/* Finish off the current unpack insn and start a new one.
+   INSN0 is the first word of the insn and is used to figure out what
+   kind of unpack insn it is.  */
+
+/* static void
+insert_unpack_marker (insn0)
+     unsigned long insn0 __attribute__((unused));
+{
+} */
+
+/* Insert a file into the output.
+   The -I arg passed to GAS is used to specify where to find the file.
+   INSERT_MARKER if non-NULL is called every SIZE bytes with an argument of
+   INSERT_MARKER_ARG.  This is used by the mpg insn to insert mpg's every 256
+   insns and by the unpack insn.
+   The result is the number of bytes inserted.
+   If an error occurs an error message is printed and zero is returned.  */
+
+static int
+insert_file (file, insert_marker, insert_marker_arg, size)
+     const char *file;
+     void (*insert_marker) (unsigned long);
+     unsigned long insert_marker_arg;
+     int size;
+{
+  FILE *f;
+  char buf[256];
+  int i, n, total, left_before_marker;
+  char *path;
+
+  path = xmalloc (strlen (file) + include_dir_maxlen + 5 /*slop*/);
+  f = NULL;
+  for (i = 0; i < include_dir_count; i++)
+    {
+      strcpy (path, include_dirs[i]);
+      strcat (path, "/");
+      strcat (path, file);
+      if ((f = fopen (path, FOPEN_RB)) != NULL)
+	break;
+    }
+  free (path);
+  if (f == NULL)
+    f = fopen (file, FOPEN_RB);
+  if (f == NULL)
+    {
+      as_bad ("unable to read file `%s'", file);
+      return 0;
+    }
+
+  total = 0;
+  left_before_marker = 0;
+  do {
+    int bytes;
+    if (insert_marker)
+      bytes = MIN (size - left_before_marker, (int)sizeof (buf));
+    else
+      bytes = sizeof (buf);
+    n = fread (buf, 1, bytes, f);
+    if (n > 0)
+      {
+	char *fr = frag_more (n);
+	memcpy (fr, buf, n);
+	total += n;
+	if (insert_marker)
+	  {
+	    left_before_marker += n;
+	    if (left_before_marker > size)
+	      as_fatal ("internal error: file insertion sanity checky failed");
+	    if (left_before_marker == size)
+	      {
+		(*insert_marker) (insert_marker_arg);
+		left_before_marker = 0;
+	      }
+	  }
+      }
+  } while (n > 0);
+
+  fclose (f);
+  /* We assume the file is smaller than 2^31 bytes.
+     Ok, we shouldn't make any assumptions.  */
+  return total;
+}
+
+/* Insert an operand value into an instruction.  */
+
+static void
+insert_operand (cpu, opcode, operand, mods, insn_buf, val, errmsg)
+     dvp_cpu cpu __attribute__((unused));
+     const dvp_opcode *opcode;
+     const dvp_operand *operand;
+     int mods;
+     DVP_INSN *insn_buf;
+     offsetT val;
+     const char **errmsg;
+{
+  if (operand->insert)
+    {
+      (*operand->insert) (opcode, operand, mods, insn_buf, (long) val, errmsg);
+    }
+  else
+    {
+      /* We currently assume a field does not cross a word boundary.  */
+      int shift = ((mods & DVP_MOD_THIS_WORD)
+		   ? (operand->shift & 31)
+		   : operand->shift);
+      /* FIXME: revisit */
+      if (operand->word == 0)
+	{
+	  int word = (mods & DVP_MOD_THIS_WORD) ? 0 : (shift / 32);
+	  if (operand->bits == 32)
+	    insn_buf[word] = val;
+	  else
+	    {
+	      shift = shift % 32;
+	      insn_buf[word] |= ((long) val & ((1 << operand->bits) - 1)) << shift;
+	    }
+	}
+      else
+	{
+	  int word = (mods & DVP_MOD_THIS_WORD) ? 0 : operand->word;
+	  if (operand->bits == 32)
+	    insn_buf[word] = val;
+	  else
+	    {
+	      long temp = (long) val & ((1 << operand->bits) - 1);
+	      insn_buf[word] |= temp << operand->shift;
+	    }
+	}
+    }
+}
+
+/* Insert an operand's final value into an instruction.
+   Here we can give warning messages about operand values if we want to.  */
+
+static void
+insert_operand_final (cpu, operand, mods, insn_buf, val, file, line)
+     dvp_cpu cpu;
+     const dvp_operand *operand;
+     int mods;
+     DVP_INSN *insn_buf;
+     offsetT val;
+     char *file;
+     unsigned int line;
+{
+  if (operand->bits != 32)
+    {
+      offsetT min, max, test;
+
+      /* ??? This test belongs more properly in the insert handler.  */
+      if ((operand->flags & DVP_OPERAND_RELATIVE_BRANCH) != 0)
+	{
+	  if ((val & 7) != 0)
+	    {
+	      if (file == (char *) NULL)
+		as_warn ("branch to misaligned address");
+	      else
+		as_warn_where (file, line, "branch to misaligned address");
+	    }
+	  val >>= 3;
+	}
+      /* ??? This test belongs more properly in the insert handler.  */
+      else if ((operand->flags & DVP_OPERAND_VU_ADDRESS) != 0)
+	{
+	  if ((val & 7) != 0)
+	    {
+	      if (file == (char *) NULL)
+		as_warn ("misaligned vu address");
+	      else
+		as_warn_where (file, line, "misaligned vu address");
+	    }
+	  val >>= 3;
+	}
+
+      if ((operand->flags & DVP_OPERAND_SIGNED) != 0)
+	{
+	  if ((operand->flags & DVP_OPERAND_SIGNOPT) != 0)
+	    max = (1 << operand->bits) - 1;
+	  else
+	    max = (1 << (operand->bits - 1)) - 1;
+	  min = - (1 << (operand->bits - 1));
+	}
+      else
+	{
+	  max = (1 << operand->bits) - 1;
+	  min = 0;
+	}
+
+      if ((operand->flags & DVP_OPERAND_NEGATIVE) != 0)
+	test = - val;
+      else
+	test = val;
+
+      if (test < (offsetT) min || test > (offsetT) max)
+	{
+	  const char *err =
+	    "operand out of range (%s not between %ld and %ld)";
+	  char buf[100];
+
+	  sprint_value (buf, test);
+	  if (file == (char *) NULL)
+	    as_warn (err, buf, min, max);
+	  else
+	    as_warn_where (file, line, err, buf, min, max);
+	}
+    }
+
+  {
+    const char *errmsg = NULL;
+    insert_operand (cpu, NULL, operand, mods, insn_buf, val, &errmsg);
+    if (errmsg != NULL)
+      as_warn_where (file, line, errmsg);
+  }
+}
+
+
+/* DVP pseudo ops.  */
+
+static void
+s_dmadata (ignore)
+    int ignore __attribute__((unused));
+{
+  char *name, c;
+
+  dma_data_name = 0;
+
+  if (dma_data_state != 0)
+    {
+      as_bad ("DmaData blocks cannot be nested.");
+      ignore_rest_of_line ();
+      return;
+    }
+  dma_data_state = 1;
+
+  SKIP_WHITESPACE ();		/* Leading whitespace is part of operand. */
+  name = input_line_pointer;
+
+  if (!is_name_beginner (*name))
+    {
+      as_bad ("invalid identifier for \".DmaData\"");
+      ignore_rest_of_line ();
+      return;
+    }
+
+  /* Do an implicit alignment to a 16 byte boundary. */
+  frag_align (4, 0, 0);
+  record_alignment (now_seg, 4);
+
+  c = get_symbol_end ();
+  line_label = colon (name);	/* user-defined label */
+  dma_data_name = S_GET_NAME (line_label);
+  *input_line_pointer = c;
+
+  /* Force emission of a machine type label for the next insn.  */
+  force_mach_label ();
+
+  demand_empty_rest_of_line ();
+}
+
+static void
+s_enddmadata (ignore)
+    int ignore __attribute__((unused));
+{
+  if (dma_data_state != 1)
+    {
+      as_warn (".EndDmaData encountered outside a DmaData block -- ignored.");
+      ignore_rest_of_line ();
+      dma_data_name = 0;
+    }
+  dma_data_state = 0;
+  demand_empty_rest_of_line ();
+
+  /* If count provided, verify it is correct.  */
+  /* ... */
+
+  /* Fill the data out to a multiple of 16 bytes.  */
+  /* FIXME: Are the fill contents right?  */
+  frag_align (4, 0, 0);
+
+  /* "label" points to beginning of block.
+     Create a name for the final label like _$<name>.  */
+  if (dma_data_name)
+    create_colon_label (0, END_LABEL_PREFIX, dma_data_name);
+}
+
+static void
+s_dmapackvif (ignore)
+    int ignore __attribute__((unused));
+{
+  /* Syntax: .dmapackvif 0|1 */
+
+  /* Leading whitespace is part of operand. */
+  SKIP_WHITESPACE ();
+  switch (*input_line_pointer++)
+    {
+    case '0':
+      dma_pack_vif_p = 0;
+      break;
+    case '1':
+      dma_pack_vif_p = 1;
+      break;
+    default:
+      as_bad ("illegal argument to `.dmapackvif'");
+    }
+  demand_empty_rest_of_line ();
+}
+
+/* INTERNAL_P is non-zero if invoked internally by this file rather than
+   by the user.  In this case we don't touch the input stream.  */
+
+static void
+s_enddirect (internal_p)
+     int internal_p;
+{
+  if (CUR_ASM_STATE != ASM_DIRECT)
+    {
+      as_bad ("`.enddirect' has no matching `direct' instruction");
+      return;
+    }
+
+    if (!output_vif)
+    {
+        pop_asm_state (1);
+        demand_empty_rest_of_line ();
+      return;
+    }
+  /* Record in the end data symbol the current location.  */
+  if (now_seg != S_GET_SEGMENT (vif_data_end))
+    as_bad (".enddirect in different section");
+  vif_data_end->sy_frag = frag_now;
+  S_SET_VALUE (vif_data_end, (valueT) frag_now_fix ());
+
+  pop_asm_state (1);
+
+  /* Needn't be reset, but to catch bugs it is.  */
+  vif_data_end = NULL;
+
+  if (! internal_p)
+    demand_empty_rest_of_line ();
+}
+
+/* CALLER denotes who's calling us.
+   If ENDMPG_USER then .endmpg was found in the input stream.
+   If ENDMPG_INTERNAL then we've been invoked to finish off file insertion.
+   If ENDMPG_MIDDLE then we've been invoked in the middle of a long stretch
+   of vu code.  */
+
+static void
+s_endmpg (caller)
+     int caller;
+{
+  if (CUR_ASM_STATE != ASM_MPG)
+    {
+      as_bad ("`.endmpg' has no matching `mpg' instruction");
+      return;
+    }
+
+  if (!output_vif)
+    {
+      pop_asm_state (1);
+      /* Reset the vu insn counter.  */
+      if (caller != ENDMPG_MIDDLE)
+        vu_count = -1;
+      if (caller == ENDMPG_USER)
+        demand_empty_rest_of_line ();
+      return;
+    }
+  /* Record in the end data symbol the current location.  */
+  if (now_seg != S_GET_SEGMENT (vif_data_end))
+    as_bad (".endmpg in different section");
+  vif_data_end->sy_frag = frag_now;
+  S_SET_VALUE (vif_data_end, (valueT) frag_now_fix ());
+
+  /* Update $.mpgloc.
+     We have to leave the old value alone as it may be used in fixups
+     already recorded.  Since compute_mpgloc allocates a new symbol for the
+     result we're ok.  The new value is the old value plus the number of
+     double words in this chunk.  */
+  mpgloc_sym = compute_mpgloc (mpgloc_sym, vif_data_start, vif_data_end);
+  S_SET_OTHER (mpgloc_sym, STO_DVP_VU);
+
+  pop_asm_state (1);
+
+  /* Needn't be reset, but to catch bugs it is.  */
+  vif_data_end = NULL;
+
+  /* Reset the vu insn counter.  */
+  if (caller != ENDMPG_MIDDLE)
+    vu_count = -1;
+
+  if (caller == ENDMPG_USER)
+    demand_empty_rest_of_line ();
+}
+
+/* INTERNAL_P is non-zero if invoked internally by this file rather than
+   by the user.  In this case we don't touch the input stream.  */
+
+static void
+s_endunpack (internal_p)
+     int internal_p;
+{
+  if (CUR_ASM_STATE != ASM_UNPACK)
+    {
+      as_bad ("`.endunpack' has no matching `unpack' instruction");
+      return;
+    }
+
+    if (!output_vif)
+    {
+        pop_asm_state (1);
+        demand_empty_rest_of_line ();
+      return;
+    }
+
+
+  /* Record in the end data symbol the current location.  */
+  /* ??? $.unpackloc is gone.  Is this also used for data length
+     verification?  */
+  if (now_seg != S_GET_SEGMENT (vif_data_end))
+    as_bad (".endunpack in different section");
+  vif_data_end->sy_frag = frag_now;
+  S_SET_VALUE (vif_data_end, (valueT) frag_now_fix ());
+
+  /* Round up to next word boundary.  */
+  frag_align (2, 0, 0);
+
+  pop_asm_state (1);
+
+  /* Needn't be reset, but to catch bugs it is.  */
+  vif_data_end = NULL;
+
+  if (! internal_p)
+    demand_empty_rest_of_line ();
+}
+
+static void
+s_endgif (ignore)
+     int ignore __attribute__((unused));
+{
+  int bytes;
+  int specified_nloop = gif_nloop ();
+  int computed_nloop;
+  int nregs = gif_nregs ();
+  char *file;
+  unsigned int line;
+
+  as_where (&file, &line);
+
+  if (CUR_ASM_STATE != ASM_GIF)
+    {
+      as_bad (".endgif doesn't follow a gif tag");
+      return;
+    }
+  pop_asm_state (1);
+
+  /* Fill out to proper boundary.
+     ??? This may cause eval_expr to always queue a fixup.  So be it.  */
+  switch (gif_insn_type)
+    {
+    case GIF_PACKED :  frag_align (4, 0, 0); break;
+    case GIF_REGLIST : frag_align (3, 0, 0); break;
+    case GIF_IMAGE :   frag_align (4, 0, 0); break;
+    }
+
+  /* The -16 is because the `gif_data_name' label is emitted at the
+     start of the gif tag.  If we're in a different frag from the one we
+     started with, this can't be computed until much later.  To cope we queue
+     a fixup and deal with it then.
+     ??? The other way to handle this is by having expr() compute "syma - symb"
+     when they're in different fragments but the difference is constant.
+     Not sure how much of a slowdown that will introduce though.  */
+  fixup_count = 0;
+  bytes = eval_expr (DVP_GIF, gif_operand_nloop, 0, ". - %s - 16", gif_data_name);
+
+  /* Compute a value for nloop if we can.  */
+
+  if (fixup_count == 0)
+    {
+      computed_nloop = compute_nloop (gif_insn_type, nregs, bytes);
+
+      /* If the user specified nloop, verify it.  */
+      if (specified_nloop != -1)
+	check_nloop (gif_insn_type, nregs,
+		     specified_nloop, computed_nloop,
+		     file, line);
+    }
+
+  /* If computation of nloop can't be done yet, queue a fixup and do it later.
+     Otherwise validate nloop if specified or write the computed value into
+     the insn.  */
+
+  if (fixup_count != 0)
+    {
+      /* FIXME: It might eventually be possible to combine all the various
+	 copies of this bit of code.  */
+      int op_type, reloc_type, offset;
+      fixS *fix;
+
+      op_type = fixups[0].opindex;
+      offset = fixups[0].offset;
+      reloc_type = encode_fixup_reloc_type (DVP_GIF, op_type);
+      fix = fix_new_exp (gif_insn_frag,
+			 (gif_insn_frag_loc + offset
+			  - gif_insn_frag->fr_literal),
+			 4, &fixups[0].exp, 0,
+			 (bfd_reloc_code_real_type) reloc_type);
+      /* Record user specified value so we can test it when we compute the
+	 actual value.  */
+      fix->tc_fix_data.type = gif_insn_type;
+      fix->tc_fix_data.nregs = nregs;
+      fix->tc_fix_data.user_value = specified_nloop;
+    }
+  else if (specified_nloop != -1)
+    ; /* nothing to do */
+  else
+    {
+      DVP_INSN insn = bfd_getl32 (gif_insn_frag_loc);
+      insert_operand_final (DVP_GIF, &gif_operands[gif_operand_nloop],
+			    DVP_MOD_THIS_WORD, &insn,
+			    (offsetT) computed_nloop, file, line);
+      bfd_putl32 ((bfd_vma) insn, gif_insn_frag_loc);
+    }
+
+  /* These needn't be reset, but to catch bugs they are.  */
+  gif_data_name = NULL;
+  gif_insn_frag = NULL;
+  gif_insn_frag_loc = NULL;
+
+  demand_empty_rest_of_line ();
+}
+
+static void
+s_vu (ignore)
+     int ignore __attribute__((unused));
+{
+  /* If in MPG state and the user requests to change to VU state,
+     leave the state as MPG.  This happens when we see an mpg followed
+     by a .include that has .vu.  Note that no attempt is made to support
+     an include depth > 1 for this case.  */
+  if (CUR_ASM_STATE == ASM_MPG)
+    return;
+
+  /* We need to set up things for $.mpgloc calculations.  */
+  /* FIXME: May need to check that we're not clobbering currently
+     in use versions of these.  Also need to worry about which section
+     the .vu is issued in.  On the other hand, ".vu" isn't intended
+     to be supported everywhere.  */
+  vif_data_start = expr_build_dot ();
+  mpgloc_sym = expr_build_uconstant (0);
+  S_SET_OTHER (mpgloc_sym, STO_DVP_VU);
+#if 0 /* ??? wip */
+  create_vuoverlay_section (vuoverlay_section_name (NULL), mpgloc_sym,
+			    NULL, NULL);
+#endif
+
+  set_asm_state (ASM_VU, ".vu");
+
+  demand_empty_rest_of_line ();
+}
+
+/* Same as read.c:s_func except prepend VU_LABEL_PREFIX by default.  */
+
+static void
+s_dvp_func (int end_p)
+{
+  do_s_func (end_p, VU_LABEL_PREFIX);
+}
+
+/* Build an expression for s1 OP s2.  */
+
+static symbolS *
+expr_build_binary (operatorT op, symbolS *s1, symbolS *s2)
+{
+  expressionS e;
+
+  e.X_op = op;
+  e.X_add_symbol = s1;
+  e.X_op_symbol = s2;
+  e.X_add_number = 0;
+  return make_expr_symbol (&e);
+}
diff -burNpd binutils-2.25.1.orig/gas/config/tc-dvp.h binutils-2.25.1.PS2/gas/config/tc-dvp.h
--- binutils-2.25.1.orig/gas/config/tc-dvp.h	1969-12-31 18:00:00.000000000 -0600
+++ binutils-2.25.1.PS2/gas/config/tc-dvp.h	2019-12-27 15:50:33.353821592 -0600
@@ -0,0 +1,100 @@
+/* tc-dvp.h -- Header file for tc-dvp.c.
+   Copyright (C) 1997, 1998 Free Software Foundation, Inc.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to
+   the Free Software Foundation, 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA. */
+
+#define TC_DVP
+
+#define LISTING_HEADER "DVP GAS "
+
+/* The target BFD architecture.  */
+#define TARGET_ARCH bfd_arch_mips
+
+#define TARGET_FORMAT "elf32-littlemips"
+
+#define TARGET_BYTES_BIG_ENDIAN 0
+
+/* Handle +- specially so the scrubber doesn't remove the space after loi
+  in "nop loi +1.0" and "nop loi -1.0".  */
+#define tc_symbol_chars "+-"
+
+long md_pcrel_from_section (struct fix *, segT);
+
+/* call md_pcrel_from_section, not md_pcrel_from */
+#define MD_PCREL_FROM_SECTION(FIXP, SEC) md_pcrel_from_section(FIXP, SEC)   
+
+/* Permit temporary numeric labels.  */
+#define LOCAL_LABELS_FB 1
+
+#define DIFF_EXPR_OK		/* .-foo gets turned into PC relative relocs */
+
+/* We don't need to handle .word strangely.  */
+#define WORKING_DOT_WORD
+
+/* Handle mpg/direct alignment requirements with relaxation.  */
+extern long dvp_relax_frag (fragS *, long);
+#define md_relax_frag(segment, fragP,stretch) dvp_relax_frag ((fragP), (stretch))
+
+/* Ensure insns at labels have their mach type properly recorded.  */
+int force_mach_label (void);
+#define TC_START_LABEL(ch, str, ptr)	(ch == ':' && force_mach_label ())
+
+#define TC_HANDLES_FX_DONE
+
+/* Record user specified val, for cases where we can't compute the actual
+   value until the end of assembly.  */
+#define TC_FIX_TYPE \
+struct { \
+  int type; /* gif_type, or vif type */ \
+  int nregs; /* for gif insns only */ \
+  short wl; short cl; /* for unpack only */ \
+  int user_value; \
+}
+/* Code to initialize it.  */
+#define TC_INIT_FIX_DATA(fixP) \
+do { memset (&fixP->tc_fix_data, 0, sizeof (fixP->tc_fix_data)); } while (0)
+
+/* Called before parsing each line.  */
+extern void dvp_start_line_hook (void);
+#define md_start_line_hook() dvp_start_line_hook ()
+
+/* Called after parsing a file.  */
+extern void dvp_after_pass_hook (void);
+#define md_after_pass_hook() dvp_after_pass_hook ()
+
+/* Called after parsing all files.  */
+extern void dvp_end (void);
+#define md_end() dvp_end ()
+
+/* Called for each label.  */
+extern void dvp_frob_label (struct symbol *);
+#define tc_frob_label(sym) dvp_frob_label (sym)
+
+/* Called just before writing the file out.  */
+extern void dvp_frob_file (void);
+#define tc_frob_file() dvp_frob_file ()
+
+/* Default section names. */
+#define TEXT_SECTION_NAME	".vutext"
+#define DATA_SECTION_NAME	".vudata"
+#define BSS_SECTION_NAME	".vubss"
+
+#define ELF_TC_SPECIAL_SECTIONS \
+  { ".vubss",	SHT_NOBITS,	SHF_ALLOC + SHF_WRITE		}, \
+  { ".vudata",	SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE		}, \
+  { ".vutext",	SHT_PROGBITS,	SHF_ALLOC + SHF_EXECINSTR	},
diff -burNpd binutils-2.25.1.orig/gas/configure.tgt binutils-2.25.1.PS2/gas/configure.tgt
--- binutils-2.25.1.orig/gas/configure.tgt	2015-07-21 03:20:58.000000000 -0500
+++ binutils-2.25.1.PS2/gas/configure.tgt	2019-12-27 15:50:33.354758645 -0600
@@ -176,6 +176,8 @@ case ${generic_target} in
   d30v-*-*)				fmt=elf ;;
   dlx-*-*)				fmt=elf ;;
 
+  dvp-*-*)				fmt=elf bfd_gas=yes install_tooldir= ;;
+
   epiphany-*-*)				fmt=elf ;;
 
   fr30-*-*)				fmt=elf ;;
@@ -335,6 +337,7 @@ case ${generic_target} in
   mips-*-elf* | mips-*-rtems*)		fmt=elf ;;
   mips-*-netbsd*)			fmt=elf em=tmips ;;
   mips-*-openbsd*)			fmt=elf em=tmips ;;
+  mips-*-irx*)				fmt=elf endian=little ;;
 
   mmix-*-*)				fmt=elf ;;
 
diff -burNpd binutils-2.25.1.orig/gas/read.c binutils-2.25.1.PS2/gas/read.c
--- binutils-2.25.1.orig/gas/read.c	2015-07-21 03:20:58.000000000 -0500
+++ binutils-2.25.1.PS2/gas/read.c	2019-12-27 15:50:33.363658702 -0600
@@ -237,7 +237,6 @@ static frchainS *bundle_lock_frchain;
 static unsigned int bundle_lock_depth;
 #endif
 
-static void do_s_func (int end_p, const char *default_prefix);
 static void do_align (int, char *, int, int);
 static void s_align (int, int);
 static void s_altmacro (int);
@@ -5895,7 +5894,7 @@ s_func (int end_p)
 /* Subroutine of s_func so targets can choose a different default prefix.
    If DEFAULT_PREFIX is NULL, use the target's "leading char".  */
 
-static void
+void
 do_s_func (int end_p, const char *default_prefix)
 {
   /* Record the current function so that we can issue an error message for
diff -burNpd binutils-2.25.1.orig/gas/read.h binutils-2.25.1.PS2/gas/read.h
--- binutils-2.25.1.orig/gas/read.h	2014-10-14 02:32:03.000000000 -0500
+++ binutils-2.25.1.PS2/gas/read.h	2019-12-27 15:50:33.365114758 -0600
@@ -165,6 +165,7 @@ extern void s_fail (int);
 extern void s_fill (int);
 extern void s_float_space (int mult);
 extern void s_func (int);
+extern void do_s_func (int end_p, const char *default_prefix);
 extern void s_globl (int arg);
 extern void s_if (int arg);
 extern void s_ifb (int arg);
diff -burNpd binutils-2.25.1.orig/include/dis-asm.h binutils-2.25.1.PS2/include/dis-asm.h
--- binutils-2.25.1.orig/include/dis-asm.h	2014-10-14 02:32:04.000000000 -0500
+++ binutils-2.25.1.PS2/include/dis-asm.h	2019-12-27 15:50:33.366527717 -0600
@@ -219,6 +219,7 @@ typedef struct disassemble_info
    target address.  Return number of octets processed.  */
 typedef int (*disassembler_ftype) (bfd_vma, disassemble_info *);
 
+extern int dvp_insn_p			(disassemble_info*);
 extern int print_insn_aarch64		(bfd_vma, disassemble_info *);
 extern int print_insn_alpha		(bfd_vma, disassemble_info *);
 extern int print_insn_avr		(bfd_vma, disassemble_info *);
@@ -233,6 +234,7 @@ extern int print_insn_crx
 extern int print_insn_d10v		(bfd_vma, disassemble_info *);
 extern int print_insn_d30v		(bfd_vma, disassemble_info *);
 extern int print_insn_dlx 		(bfd_vma, disassemble_info *);
+extern int print_insn_dvp		(bfd_vma, disassemble_info*);
 extern int print_insn_epiphany		(bfd_vma, disassemble_info *);
 extern int print_insn_fr30		(bfd_vma, disassemble_info *);
 extern int print_insn_frv		(bfd_vma, disassemble_info *);
diff -burNpd binutils-2.25.1.orig/include/elf/common.h binutils-2.25.1.PS2/include/elf/common.h
--- binutils-2.25.1.orig/include/elf/common.h	2014-10-14 02:32:04.000000000 -0500
+++ binutils-2.25.1.PS2/include/elf/common.h	2019-12-27 15:50:33.368208413 -0600
@@ -93,6 +93,7 @@
 #define ET_LOOS		0xFE00	/* Operating system-specific */
 #define ET_HIOS		0xFEFF	/* Operating system-specific */
 #define ET_LOPROC	0xFF00	/* Processor-specific */
+#define ET_IRX		0xFF80  /* SONY IRX file */
 #define ET_HIPROC	0xFFFF	/* Processor-specific */
 
 /* Values for e_machine, which identifies the architecture.  These numbers
@@ -428,6 +429,7 @@
 #define PT_LOOS		0x60000000	/* OS-specific */
 #define PT_HIOS		0x6fffffff	/* OS-specific */
 #define PT_LOPROC	0x70000000	/* Processor-specific */
+#define PT_MIPS_IRXHDR	0x70000080	/* SONY IRX loadable program segment */
 #define PT_HIPROC	0x7FFFFFFF	/* Processor-specific */
 
 #define PT_GNU_EH_FRAME	(PT_LOOS + 0x474e550) /* Frame unwind information */
@@ -485,6 +487,7 @@
 #define SHT_GNU_versym	SHT_SUNW_versym
 
 #define SHT_LOPROC	0x70000000	/* Processor-specific semantics, lo */
+#define SHT_IOPMOD	0x70000080	/* SONY IRX .iopmod section */
 #define SHT_HIPROC	0x7FFFFFFF	/* Processor-specific semantics, hi */
 #define SHT_LOUSER	0x80000000	/* Application-specific semantics */
 /* #define SHT_HIUSER	0x8FFFFFFF    *//* Application-specific semantics */
diff -burNpd binutils-2.25.1.orig/include/elf/mips.h binutils-2.25.1.PS2/include/elf/mips.h
--- binutils-2.25.1.orig/include/elf/mips.h	2014-11-04 03:54:41.000000000 -0600
+++ binutils-2.25.1.PS2/include/elf/mips.h	2019-12-27 15:50:33.370210718 -0600
@@ -111,6 +111,13 @@ START_RELOC_NUMBERS (elf_mips_reloc_type
   RELOC_NUMBER (R_MIPS16_TLS_TPREL_HI16, 111)
   RELOC_NUMBER (R_MIPS16_TLS_TPREL_LO16, 112)
   FAKE_RELOC (R_MIPS16_max, 113)
+
+  /* These relocs are for the dvp.  */
+  RELOC_NUMBER (R_MIPS_DVP_11_PCREL, 120)
+  RELOC_NUMBER (R_MIPS_DVP_27_S4, 121)
+  RELOC_NUMBER (R_MIPS_DVP_11_S4, 122)
+  RELOC_NUMBER (R_MIPS_DVP_U15_S3, 123)
+
   /* These relocations are specific to VxWorks.  */
   RELOC_NUMBER (R_MIPS_COPY, 126)
   RELOC_NUMBER (R_MIPS_JUMP_SLOT, 127)
@@ -444,6 +451,15 @@ END_RELOC_NUMBERS (R_MIPS_maxext)
 /* ABI related flags section.  */
 #define SHT_MIPS_ABIFLAGS	0x7000002a
 
+/* The VU overlay table.  */
+#define SHT_DVP_OVERLAY_TABLE           0x7ffff420
+#define SHNAME_DVP_OVERLAY_TABLE        ".DVP.ovlytab"
+#define SHNAME_DVP_OVERLAY_STRTAB       ".DVP.ovlystrtab"
+/* A VU overlay.  */
+#define SHT_DVP_OVERLAY                 0x7ffff421
+/* Prefix of VU overlay sections.  */
+#define SHNAME_DVP_OVERLAY_PREFIX       ".DVP.overlay."
+
 /* A section of type SHT_MIPS_LIBLIST contains an array of the
    following structure.  The sh_link field is the section index of the
    string table.  The sh_info field is the number of entries in the
@@ -809,6 +825,16 @@ extern void bfd_mips_elf32_swap_reginfo_
 #define STO_HIDDEN		STV_HIDDEN
 #define STO_PROTECTED		STV_PROTECTED
 
+/* These values are used for the dvp.  */
+#define STO_DVP_DMA 	0xe8  
+#define STO_DVP_VIF		0xe9  
+#define STO_DVP_GIF		0xea  
+#define STO_DVP_VU		0xeb  
+/* Reserve a couple in case we need them.  */
+#define STO_DVP_RES1		0xec  
+#define STO_DVP_RES2		0xed  
+#define STO_DVP_P(sto) ((sto) >= STO_DVP_DMA && (sto) <= STO_DVP_RES2)
+
 /* Two topmost bits denote the MIPS ISA for .text symbols:
    + 00 -- standard MIPS code,
    + 10 -- microMIPS code,
@@ -1158,6 +1184,30 @@ extern void bfd_mips_elf64_swap_reginfo_
 extern void bfd_mips_elf64_swap_reginfo_out
   (bfd *, const Elf64_Internal_RegInfo *, Elf64_External_RegInfo *);
 
+/* The vu overlay table is an array of this.  */
+typedef struct
+{
+  /* `name' is offset into overlay string table section.  */
+  char name[4];
+  char lma[4];
+  char vma[4];
+} Elf32_Dvp_External_Overlay;
+
+typedef struct
+{
+  bfd_vma name;
+  bfd_vma lma;
+  bfd_vma vma;
+} Elf32_Dvp_Internal_Overlay;
+
+/* overlay swapping routines. */
+extern void bfd_dvp_elf32_swap_overlay_in
+  (bfd *, const Elf32_Dvp_External_Overlay *,
+           Elf32_Dvp_Internal_Overlay *);
+extern void bfd_dvp_elf32_swap_overlay_out
+  (bfd *, const Elf32_Dvp_Internal_Overlay *,
+           Elf32_Dvp_External_Overlay *);
+
 /* MIPS ELF flags swapping routines.  */
 extern void bfd_mips_elf_swap_abiflags_v0_in
   (bfd *, const Elf_External_ABIFlags_v0 *, Elf_Internal_ABIFlags_v0 *);
diff -burNpd binutils-2.25.1.orig/include/opcode/dvp.h binutils-2.25.1.PS2/include/opcode/dvp.h
--- binutils-2.25.1.orig/include/opcode/dvp.h	1969-12-31 18:00:00.000000000 -0600
+++ binutils-2.25.1.PS2/include/opcode/dvp.h	2019-12-27 15:50:33.373143758 -0600
@@ -0,0 +1,462 @@
+/* Opcode table for the DVP.
+   Copyright 1998 Free Software Foundation, Inc.
+
+This file is part of GAS, the GNU Assembler, GDB, the GNU debugger, and
+the GNU Binutils.
+
+GAS/GDB is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GAS/GDB is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GAS or GDB; see the file COPYING.	If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* Enum describing each processing component.
+   In the case where one wants to specify DVP_VU, use DVP_VUUP.  */
+typedef enum {
+  DVP_UNKNOWN, DVP_DMA, DVP_VIF, DVP_GIF, DVP_VUUP, DVP_VULO
+} dvp_cpu;
+
+/* Type to denote a DVP instruction (at least a 32 bit unsigned int).  */
+typedef unsigned int DVP_INSN;
+
+/* Maximum number of operands and syntax chars an instruction can have.  */
+#define DVP_MAX_OPERANDS 16
+
+typedef struct dvp_opcode {
+  char *mnemonic;
+  /* The value stored is 128 + operand number.
+     This allows ASCII chars to go here as well.  */
+  unsigned char syntax[DVP_MAX_OPERANDS];
+  DVP_INSN mask, value;	/* recognize insn if (op&mask)==value */
+  unsigned opcode_word;	/* opcode word to contain contain "value"; usually 0 */
+		      	/* (definition of a word is target specific) */
+  int flags;		/* various flag bits */
+
+/* Values for `flags'.  */
+
+/* This insn is a conditional branch.  */
+#define DVP_OPCODE_COND_BRANCH 1
+/* Ignore this insn during disassembly.  */
+#define DVP_OPCODE_IGNORE_DIS 2
+/* CPU specific values begin at 0x10.  */
+
+  /* These values are used to optimize assembly and disassembly.  Each insn is
+     on a list of related insns (same first letter for assembly, same insn code
+     for disassembly).  */
+  /* FIXME: May wish to move this to separate table.  */
+  struct dvp_opcode *next_asm;	/* Next instruction to try during assembly.  */
+  struct dvp_opcode *next_dis;	/* Next instruction to try during disassembly.  */
+
+  /* Macros to create the hash values for the lists.  */
+#define DVP_HASH_UPPER_OPCODE(string) \
+  (tolower ((string)[0]) >= 'a' && tolower ((string)[0]) <= 'z' \
+   ? tolower ((string)[0]) - 'a' : 26)
+#define DVP_HASH_LOWER_OPCODE(string) \
+  (tolower ((string)[0]) >= 'a' && tolower ((string)[0]) <= 'z' \
+   ? tolower ((string)[0]) - 'a' : 26)
+/* ??? The icode hashing is very simplistic.
+   upper: bits 0x3c, can't use lower two bits because of bc field
+   lower: upper 6 bits  */
+#define DVP_ICODE_HASH_SIZE 6 /* bits */
+#define DVP_HASH_UPPER_ICODE(insn) \
+  ((insn) & 0x3c)
+#define DVP_HASH_LOWER_ICODE(insn) \
+  ((((insn) & 0xfc) >> 26) & 0x3f)
+
+  /* Macros to access `next_asm', `next_dis' so users needn't care about the
+     underlying mechanism.  */
+#define DVP_OPCODE_NEXT_ASM(op) ((op)->next_asm)
+#define DVP_OPCODE_NEXT_DIS(op) ((op)->next_dis)
+} dvp_opcode;
+
+/* The operand table.  */
+
+typedef struct dvp_operand {
+  /* The number of bits in the operand (may be unused for a modifier).  */
+  unsigned char bits;
+
+  /* How far the operand is left shifted in the instruction, or
+     the modifier's flag bit (may be unused for a modifier).  */
+  unsigned char shift;
+
+  /* An index to the instruction word which will contain the operand value.
+     Usually 0.  */
+  unsigned char word;
+
+  /* Various flag bits.  */
+  int flags;
+
+/* Values for `flags'.  */
+
+/* This operand is a suffix to the opcode.  */
+#define DVP_OPERAND_SUFFIX 1
+
+/* This operand is a relative branch displacement.  The disassembler
+   prints these symbolically if possible.  */
+#define DVP_OPERAND_RELATIVE_BRANCH 2
+
+/* This operand is an absolute branch address.  The disassembler
+   prints these symbolically if possible.  */
+#define DVP_OPERAND_ABSOLUTE_BRANCH 4
+
+/* This operand is a mips address.  The disassembler
+   prints these symbolically if possible.  */
+#define DVP_OPERAND_MIPS_ADDRESS 8
+
+/* This operand is a vu address.  The disassembler
+   prints these symbolically if possible.  */
+#define DVP_OPERAND_VU_ADDRESS 0x10
+
+/* This operand takes signed values (default is unsigned).
+   The default was chosen to be unsigned as most fields are unsigned
+   (e.g. registers).  */
+#define DVP_OPERAND_SIGNED 0x20
+
+/* This operand takes signed values, but also accepts a full positive
+   range of values.  That is, if bits is 16, it takes any value from
+   -0x8000 to 0xffff.  */
+#define DVP_OPERAND_SIGNOPT 0x40
+
+/* This operand should be regarded as a negative number for the
+   purposes of overflow checking (i.e., the normal most negative
+   number is disallowed and one more than the normal most positive
+   number is allowed).  This flag will only be set for a signed
+   operand.  */
+#define DVP_OPERAND_NEGATIVE 0x80
+
+/* This operand doesn't really exist.  The program uses these operands
+   in special ways by creating insertion or extraction functions to have
+   arbitrary processing performed during assembly/disassemble.
+   Parse and print routines are ignored for FAKE operands.  */
+#define DVP_OPERAND_FAKE 0x100
+
+/* This operand is the address of the `unpack' insn.  */
+#define DVP_OPERAND_UNPACK_ADDRESS 0x200
+
+/* Inline data.  */
+#define DVP_OPERAND_DMA_INLINE 0x10000
+
+/* Pointer to the data.  */
+#define DVP_OPERAND_DMA_ADDR 0x20000
+
+/* Pointer to the data.  */
+#define DVP_OPERAND_DMA_NEXT 0x40000
+
+/* The actual count operand.  */
+#define DVP_OPERAND_DMA_COUNT 0x80000
+
+/* A 32 bit floating point immediate.  */
+#define DVP_OPERAND_FLOAT 0x100000
+
+/* An 11-bit immediate operand.  May be a label.  */
+#define DVP_OPERAND_RELOC_11_S4 0x200000
+
+/* An 15-bit unsigned immediate operand.  May be a label.  */
+#define DVP_OPERAND_RELOC_U15_S3 0x400000
+
+/* Modifier values.  */
+
+/* A dot is required before a suffix.  e.g. .le  */
+/* ??? Not currently used.  */
+#define DVP_MOD_DOT 0x1000000
+
+/* The count operand was an asterisk.  */
+#define DVP_OPERAND_AUTOCOUNT 0x2000000
+
+/* Ignore the word part of any shift and operate on the "first" word
+   of the instruction.  */
+#define DVP_MOD_THIS_WORD 0x4000000
+
+/* Sum of all DVP_MOD_XXX bits.  */
+#define DVP_MOD_BITS 0xff000000
+
+/* Non-zero if the operand type is really a modifier.  */
+#define DVP_MOD_P(X) ((X) & DVP_MOD_BITS)
+
+  /* Parse function.  This is used by the assembler.
+     MODS is a list of modifiers preceding the operand in the syntax string.
+     If the operand cannot be parsed an error message is stored in ERRMSG,
+     otherwise ERRMSG is unchanged.  */
+  long (*parse) (const struct dvp_opcode *opcode,
+			 const struct dvp_operand *operand,
+			 int mods, char **str, const char **errmsg);
+
+  /* Insertion function.  This is used by the assembler.  To insert an
+     operand value into an instruction, check this field.
+
+     If it is NULL, execute
+         i |= (p & ((1 << o->bits) - 1)) << o->shift;
+     (I is the instruction which we are filling in, O is a pointer to
+     this structure, and OP is the opcode value; this assumes twos
+     complement arithmetic).
+
+     If this field is not NULL, then simply call it with the
+     instruction and the operand value.  It will overwrite the appropriate
+     bits of the instruction with the operand's value.
+     MODS is a list of modifiers preceding the operand in the syntax string.
+     If the ERRMSG argument is not NULL, then if the operand value is illegal,
+     *ERRMSG will be set to a warning string (the operand will be inserted in
+     any case).  If the operand value is legal, *ERRMSG will be unchanged.
+     OPCODE may be NULL, in which case the value isn't known.  This happens
+     when applying fixups.  */
+
+  void (*insert) (const struct dvp_opcode *opcode,
+			  const struct dvp_operand *operand,
+			  int mods, DVP_INSN *insn,
+			  long value, const char **errmsg);
+
+  /* Extraction function.  This is used by the disassembler.  To
+     extract this operand type from an instruction, check this field.
+
+     If it is NULL, compute
+         op = ((i) >> o->shift) & ((1 << o->bits) - 1);
+	 if ((o->flags & DVP_OPERAND_SIGNED) != 0
+	     && (op & (1 << (o->bits - 1))) != 0)
+	   op -= 1 << o->bits;
+     (I is the instruction, O is a pointer to this structure, and OP
+     is the result; this assumes twos complement arithmetic).
+
+     If this field is not NULL, then simply call it with the
+     instruction value.  It will return the value of the operand.  If
+     the INVALID argument is not NULL, *INVALID will be set to
+     non-zero if this operand type can not actually be extracted from
+     this operand (i.e., the instruction does not match).  If the
+     operand is valid, *INVALID will not be changed.
+     MODS is a list of modifiers preceding the operand in the syntax string.
+
+     INSN is a pointer to one or two `DVP_INSN's.  The first element is
+     the insn, the second is an immediate constant if present.
+     FIXME: just thrown in here for now.
+     */
+
+  long (*extract) (const struct dvp_opcode *opcode,
+			   const struct dvp_operand *operand,
+			   int mods, DVP_INSN *insn, int *pinvalid);
+
+  /* Print function.  This is used by the disassembler.  */
+  void (*print) (const struct dvp_opcode *opcode,
+			 const struct dvp_operand *operand,
+			 int mods, DVP_INSN *insn,
+			 disassemble_info *info, long value);
+} dvp_operand;
+
+/* Given an operand entry, return the table index.  */
+#define DVP_OPERAND_INDEX(op) ((op) - 128)
+
+
+/* Macro support.  */
+
+typedef struct dvp_macro {
+  const char *template;
+  const char *result;
+} dvp_macro;
+
+/* Expand an instruction if it is a macro, else NULL.  */
+extern char * dvp_expand_macro (const dvp_macro *, int, char *);
+
+
+/* VU support.  */
+
+/* Flag values.
+   The actual value stored in the insn is left shifted by 27.  */
+#define VU_FLAG_I 16
+#define VU_FLAG_E 8
+#define VU_FLAG_M 4
+#define VU_FLAG_D 2
+#define VU_FLAG_T 1
+
+/* Positions, masks, and values of various fields used in multiple places
+   (the opcode table, the disassembler, GAS).  */
+#define VU_SHIFT_DEST 21
+#define VU_SHIFT_TREG 16
+#define VU_SHIFT_SREG 11
+#define VU_SHIFT_DREG 6
+#define VU_MASK_REG 31
+/* Bits for multiple dest choices.  */
+#define VU_DEST_X 8
+#define VU_DEST_Y 4
+#define VU_DEST_Z 2
+#define VU_DEST_W 1
+/* Values for a single dest choice.  */
+#define VU_SDEST_X 0
+#define VU_SDEST_Y 1
+#define VU_SDEST_Z 2
+#define VU_SDEST_W 3
+
+extern const dvp_operand vu_operands[];
+extern /*const*/ dvp_opcode vu_upper_opcodes[];
+extern /*const*/ dvp_opcode vu_lower_opcodes[];
+extern const int vu_upper_opcodes_count;
+extern const int vu_lower_opcodes_count;
+
+const dvp_opcode *vu_upper_opcode_lookup_asm (const char *);
+const dvp_opcode *vu_lower_opcode_lookup_asm (const char *);
+const dvp_opcode *vu_upper_opcode_lookup_dis (unsigned int);
+const dvp_opcode *vu_lower_opcode_lookup_dis (unsigned int);
+
+
+/* VIF support.  */
+
+/* VIF opcode flags.
+   The usage here is a bit wasteful of bits, but there's enough bits
+   and we can always make better usage later.
+   We begin at 0x10 because the lower 4 bits are reserved for
+   general opcode flags.  */
+
+/* 2 word instruction */
+#define VIF_OPCODE_LEN2 0x10
+/* 5 word instruction */
+#define VIF_OPCODE_LEN5 0x20
+/* variable length instruction */
+#define VIF_OPCODE_LENVAR 0x40
+/* the mpg instruction */
+#define VIF_OPCODE_MPG 0x80
+/* the direct instruction */
+#define VIF_OPCODE_DIRECT 0x100
+/* the directhl instruction */
+#define VIF_OPCODE_DIRECTHL 0x200
+/* the unpack instruction */
+#define VIF_OPCODE_UNPACK 0x400
+
+/* Instruction flag bits.  M,R,U are only applicable to `unpack'.
+   These aren't the actual bit numbers.  They're for internal use.
+   The insert/extract handlers do the appropriate conversions.  */
+#define VIF_FLAG_I 1
+#define VIF_FLAG_M 2
+#define VIF_FLAG_R 4
+#define VIF_FLAG_U 8
+
+/* The "mode" operand of the "stmod" insn.  */
+#define VIF_MODE_DIRECT 0
+#define VIF_MODE_ADD 1
+#define VIF_MODE_ADDROW 2
+
+/* Unpack types.  */
+typedef enum {
+  VIF_UNPACK_S_32 = 0,
+  VIF_UNPACK_S_16 = 1,
+  VIF_UNPACK_S_8 = 2,
+  VIF_UNPACK_UNUSED3 = 3,
+  VIF_UNPACK_V2_32 = 4,
+  VIF_UNPACK_V2_16 = 5,
+  VIF_UNPACK_V2_8 = 6,
+  VIF_UNPACK_UNUSED7 = 7,
+  VIF_UNPACK_V3_32 = 8,
+  VIF_UNPACK_V3_16 = 9,
+  VIF_UNPACK_V3_8 = 10,
+  VIF_UNPACK_UNUSED11 = 11,
+  VIF_UNPACK_V4_32 = 12,
+  VIF_UNPACK_V4_16 = 13,
+  VIF_UNPACK_V4_8 = 14,
+  VIF_UNPACK_V4_5 = 15
+} unpack_type;
+
+extern const dvp_operand vif_operands[];
+extern /*const*/ dvp_opcode vif_opcodes[];
+extern const int vif_opcodes_count;
+extern const dvp_macro vif_macros[];
+extern const int vif_macro_count;
+const dvp_opcode *vif_opcode_lookup_asm (const char *);
+const dvp_opcode *vif_opcode_lookup_dis (unsigned int);
+
+/* Return length, in 32 bit words, of just parsed vif insn,
+   or 0 if unknown.  */
+int vif_len (void);
+
+/* Given the first word of a VIF insn, return its length.  */
+int vif_insn_len (DVP_INSN, dvp_cpu *);
+
+/* Return the length value to use for an unpack instruction.  */
+int vif_unpack_len_value (unpack_type, int, int, int);
+
+/* Return the length, in words, of an unpack insn.  */
+int vif_unpack_len (unpack_type, int);
+
+/* Fetch user data for variable length insns.  */
+void vif_get_var_data (const char **, int *);
+
+/* Fetch the current values of wl,cl.  */
+void vif_get_wl_cl (int *, int *);
+
+/* Various operand numbers.  */
+extern const int vif_operand_mpgloc;
+extern const int vif_operand_datalen_special;
+
+
+/* DMA support.  */
+
+/* DMA instruction flags.  */
+#define DMA_FLAG_PCE0 1
+#define DMA_FLAG_PCE1 2
+#define DMA_FLAG_INT 4
+#define DMA_FLAG_SPR 8
+
+extern const dvp_operand dma_operands[];
+extern /*const*/ dvp_opcode dma_opcodes[];
+extern const int dma_opcodes_count;
+const dvp_opcode *dma_opcode_lookup_asm (const char *);
+const dvp_opcode *dma_opcode_lookup_dis (unsigned int);
+int dvp_dma_operand_autocount (int);
+
+/* Various operand numbers.  */
+extern const int dma_operand_count;
+extern const int dma_operand_addr;
+
+
+/* GIF support.  */
+
+/* Maximum value for nloop.  */
+#define GIF_MAX_NLOOP 32767
+
+/* The PRE bit in the appropriate word in a tag.  */
+#define GIF_PRE (1 << 14)
+
+/* The values here correspond to the values in the instruction.  */
+typedef enum { GIF_PACKED = 0, GIF_REGLIST = 1, GIF_IMAGE = 2 } gif_type;
+
+typedef enum {
+  GIF_REG_PRIM = 0,
+  GIF_REG_RGBAQ = 1,
+  GIF_REG_ST = 2,
+  GIF_REG_UV = 3,
+  GIF_REG_XYZF2 = 4,
+  GIF_REG_XYZ2 = 5,
+  GIF_REG_TEX0_1 = 6,
+  GIF_REG_TEX0_2 = 7,
+  GIF_REG_CLAMP_1 = 8,
+  GIF_REG_CLAMP_2 = 9,
+  GIF_REG_XYZF = 10,
+  GIF_REG_UNUSED11 = 11, /* 11 is unused */
+  GIF_REG_XYZF3 = 12,
+  GIF_REG_XYZ3 = 13,
+  GIF_REG_A_D = 14,
+  GIF_REG_NOP = 15
+} gif_reg;
+
+extern const dvp_operand gif_operands[];
+extern /*const*/ dvp_opcode gif_opcodes[];
+extern const int gif_opcodes_count;
+const dvp_opcode *gif_opcode_lookup_asm (const char *);
+const dvp_opcode *gif_opcode_lookup_dis (unsigned int);
+extern int gif_nloop (void);
+extern int gif_nregs (void);
+
+int vif_get_mpgloc (void);
+
+/* Various operand numbers.  */
+extern const int gif_operand_nloop;
+
+
+/* Utility fns in dvp-opc.c.  */
+void dvp_opcode_init_tables (void);
+void dvp_opcode_init_parse (void);
+void dvp_opcode_init_print (void);
diff -burNpd binutils-2.25.1.orig/ld/Makefile.am binutils-2.25.1.PS2/ld/Makefile.am
--- binutils-2.25.1.orig/ld/Makefile.am	2014-10-14 02:32:04.000000000 -0500
+++ binutils-2.25.1.PS2/ld/Makefile.am	2019-12-27 15:50:33.380190346 -0600
@@ -340,6 +340,7 @@ ALL_EMULATION_SOURCES = \
 	em68kpsos.c \
 	em88kbcs.c \
 	emcorepe.c \
+	emipsirx.c \
 	emn10200.c \
 	emn10300.c \
 	emsp430.c \
@@ -1492,6 +1493,9 @@ em88kbcs.c: $(srcdir)/emulparams/m88kbcs
 emcorepe.c: $(srcdir)/emulparams/mcorepe.sh \
   $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
 
+emipsirx.c:  $(srcdir)/emulparams/mipsirx.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/irx.em $(srcdir)/scripttempl/irx.sc ${GEN_DEPENDS}
+
 emn10200.c: $(srcdir)/emulparams/mn10200.sh \
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 
diff -burNpd binutils-2.25.1.orig/ld/Makefile.in binutils-2.25.1.PS2/ld/Makefile.in
--- binutils-2.25.1.orig/ld/Makefile.in	2014-10-14 02:32:04.000000000 -0500
+++ binutils-2.25.1.PS2/ld/Makefile.in	2019-12-27 15:50:33.382931816 -0600
@@ -648,6 +648,7 @@ ALL_EMULATION_SOURCES = \
 	em68kpsos.c \
 	em88kbcs.c \
 	emcorepe.c \
+	emipsirx.c \
 	emn10200.c \
 	emn10300.c \
 	emsp430.c \
@@ -1300,6 +1301,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68kpsos.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em88kbcs.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emcorepe.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emipsirx.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emmo.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emn10200.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emn10300.Po@am__quote@
@@ -2933,6 +2935,9 @@ em88kbcs.c: $(srcdir)/emulparams/m88kbcs
 emcorepe.c: $(srcdir)/emulparams/mcorepe.sh \
   $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
 
+emipsirx.c:  $(srcdir)/emulparams/mipsirx.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/irx.em $(srcdir)/scripttempl/irx.sc ${GEN_DEPENDS}
+
 emn10200.c: $(srcdir)/emulparams/mn10200.sh \
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 
diff -burNpd binutils-2.25.1.orig/ld/configure.tgt binutils-2.25.1.PS2/ld/configure.tgt
--- binutils-2.25.1.orig/ld/configure.tgt	2014-10-14 02:32:04.000000000 -0500
+++ binutils-2.25.1.PS2/ld/configure.tgt	2019-12-27 15:50:33.374595927 -0600
@@ -180,6 +180,7 @@ d30v-*-*)		targ_emul=d30velf; targ_extra
 			;;
 dlx-*-elf*)		targ_emul=elf32_dlx
 			;;
+dvp-*-*) 		targ_emul=elf32lr5900n32 ;;
 epiphany-*-elf)		targ_emul=elf32epiphany
 			targ_extra_emuls="elf32epiphany_4x4"
 			;;
@@ -470,6 +471,9 @@ mips*el-ps2-elf*)	targ_emul=elf32lr5900
 			targ_extra_libpath=$targ_extra_emuls ;;
 mips*el-*-elf*)		targ_emul=elf32elmip ;;
 mips*-*-elf*)		targ_emul=elf32ebmip ;;
+mips*el-*-irx*)		targ_emul=mipsirx
+			targ_extra_emuls="elf32elmip"
+			targ_extra_libpath=$targ_extra_emuls ;;
 mips*-*-rtems*)		targ_emul=elf32ebmip ;;
 mips*el-*-vxworks*)	targ_emul=elf32elmipvxworks
 			targ_extra_emuls="elf32ebmipvxworks" ;;
diff -burNpd binutils-2.25.1.orig/ld/emulparams/mipsirx.sh binutils-2.25.1.PS2/ld/emulparams/mipsirx.sh
--- binutils-2.25.1.orig/ld/emulparams/mipsirx.sh	1969-12-31 18:00:00.000000000 -0600
+++ binutils-2.25.1.PS2/ld/emulparams/mipsirx.sh	2019-12-27 15:50:33.375668578 -0600
@@ -0,0 +1,8 @@
+SCRIPT_NAME=irx
+OUTPUT_FORMAT="elf32-littlemips"
+ARCH=mips
+ENTRY=_start
+TEXT_START_ADDR=0x0
+DATA_ADDR=.
+TEMPLATE_NAME=elf32
+EXTRA_EM_FILE=irx
diff -burNpd binutils-2.25.1.orig/ld/emultempl/irx.em binutils-2.25.1.PS2/ld/emultempl/irx.em
--- binutils-2.25.1.orig/ld/emultempl/irx.em	1969-12-31 18:00:00.000000000 -0600
+++ binutils-2.25.1.PS2/ld/emultempl/irx.em	2019-12-27 15:50:33.378057068 -0600
@@ -0,0 +1,465 @@
+fragment <<EOF
+/* This file is is generated by a shell script.  DO NOT EDIT! */
+
+/* IRX emulation code for ${EMULATION_NAME}
+   Copyright (C) 1991, 1993 Free Software Foundation, Inc.
+   Written by Steve Chamberlain steve@cygnus.com
+   IRX support by Douglas C. Knight fsdck@uaf.edu
+
+This file is part of GLD, the Gnu Linker.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+EOF
+
+source_em ${srcdir}/emultempl/mipself.em
+
+cat >>e${EMULATION_NAME}.c <<EOF
+
+#include <errno.h>
+
+#define is_mips_elf(bfd)        \
+  (bfd_get_flavour (bfd) == bfd_target_elf_flavour  \
+  && elf_tdata (bfd) != NULL        \
+  && elf_object_id (bfd) == MIPS_ELF_DATA)
+
+static bfd_boolean building_irx;
+static lang_output_section_statement_type *text_section_statement;
+static lang_output_section_statement_type *iopmod_section_statement;
+
+static struct lang_output_section_phdr_list default_phdr = {
+  name: " DEFAULT",
+  next: NULL,
+  used: FALSE
+};
+static struct lang_output_section_phdr_list irxhdr_phdr = {
+  name: " IRXHDR",
+  next: NULL,
+  used: FALSE
+};
+static struct lang_output_section_phdr_list none_phdr = {
+  name: "NONE",
+  next: NULL,
+  used: FALSE
+};
+
+/* This is called just before parsing the linker script.  It does some
+   bfd configuration for irx filex, creates the irx program header,
+   and adds an .iopmod output section to the statement list.  */
+
+static void
+irx_before_parse (void)
+{
+  gld${EMULATION_NAME}_before_parse();
+
+  /* Only setup IRX headers for executable files.  */
+  if (!link_info.relocatable)
+  {
+    building_irx = TRUE;
+    /* IRX files are dynamic.  They need their relocations.  */
+    link_info.emitrelocations = TRUE;
+    /* This isn't really needed, but I've never seen an IRX that's
+      properly paged.  */
+    config.magic_demand_paged = FALSE;
+  
+    /* The IRXHDR program header must be the first in the list of
+      program headers.  By creating it here, before processing the
+      linker script, it is always at the beginning of the list.  */
+    lang_new_phdr (irxhdr_phdr.name, exp_intop (PT_MIPS_IRXHDR), FALSE,
+        FALSE, NULL, exp_intop (PF_R));
+
+    /* An .iopmod output section will be needed.  By creating the
+      .iopmod section before parsing the linker script, the iopmod
+      section statement will be placed at the top of the statement list
+      after the *ABS* section, but before any other sections from the
+      linker script.  The statements from the linker script can then be
+      accessed through iopmod_section_statement->next.  */
+      iopmod_section_statement = lang_output_section_statement_lookup (".iopmod", 0, TRUE);
+  }else{
+    building_irx = FALSE;
+  }
+}
+
+
+/* gldmipsirx_after_parse () is executed after the linker script has
+   been parsed.  It puts the .iopmod output section into the IRXHDR
+   segment.  If the linker script did not create any program headers
+   of its own, this function also creates a PT_LOAD segment and puts
+   all of the remaining sections in it.  */
+
+static void
+gld${EMULATION_NAME}_after_parse (void)
+{
+  bfd_boolean linkscript_uses_phdrs;
+  lang_output_section_statement_type *stat;
+
+  mips_after_parse();
+
+  /* Only setup IRX headers for executable files.  */
+  if (building_irx)
+  {
+    /* Determine whether the link script assigned any sections to phdrs.  */
+
+    /* FIXME: If none of the sections have been explicitly assigned to a
+       segment, this function assumes that the linker script did not
+       create any program headers.  This function should not put the
+       sections in a new PT_LOAD segment if the linker script, for some
+       odd reason, created program headers but did not assign any of the
+       sections to any segments.  There is currently no way to tell
+       whether the linker script created any program headers because the
+       program header list is a static variable.  If there ever is any
+       reason to create program headers, but have all of the sections
+       remain segmentless, explicitly assign the first section in the
+       linker script to the section "NONE". */
+
+    linkscript_uses_phdrs = FALSE;
+    for (stat = iopmod_section_statement->next; stat != NULL;
+      stat = stat->next)
+      if (stat->header.type == lang_output_section_statement_enum)
+        if (stat->phdrs != NULL)
+        {
+          linkscript_uses_phdrs = TRUE;
+          break;
+        }
+
+    if (! linkscript_uses_phdrs)
+    {
+      /* The linker script didn't use program headers, so build the
+        default segment and put all of the sections in it.  */
+      lang_new_phdr (default_phdr.name, exp_intop (PT_LOAD), FALSE,
+        FALSE, NULL, exp_intop (PF_R | PF_W | PF_X));
+      for (stat = iopmod_section_statement->next; stat != NULL;
+        stat = stat->next)
+      if (stat->header.type == lang_output_section_statement_enum)
+        stat->phdrs = &default_phdr;
+    }
+
+    /* Add iopmod to the IRXHDR segment.  */
+    irxhdr_phdr.next = iopmod_section_statement->phdrs;
+    iopmod_section_statement->phdrs = &irxhdr_phdr;
+
+    /* Keep IRXHDR from following through to following sections.  */
+    for (stat = iopmod_section_statement->next; stat != NULL;
+      stat = stat->next)
+      if (stat->header.type == lang_output_section_statement_enum)
+      {
+        if (! stat->phdrs)
+        {
+          stat->phdrs = (irxhdr_phdr.next) ? irxhdr_phdr.next : &none_phdr;
+        }
+        break;
+      }
+  }
+}
+
+/* This is a macro to add a data statement of data type T and the data
+   expression E to the end of the statement list LP.  */
+
+#define new_data_stat(t,e,lp) {                         \
+  lang_statement_union_type *d;                         \
+  d = stat_alloc (sizeof (lang_data_statement_type));   \
+  d->header.type = lang_data_statement_enum;            \
+  d->header.next = NULL;                                \
+  ((lang_data_statement_type *) d)->exp = e;            \
+  ((lang_data_statement_type *) d)->type = t;           \
+  lang_statement_append (lp, d, &d->header.next);       \
+}
+
+/* Called after input files have been opened, and their symbols
+   parsed.  If the .iopmod section is empty, construct a valid .iopmod
+   structure.  If _irx_id is defined, it is used as the id structure to
+   for this irx.  */
+
+static void
+irx_after_open (void)
+{
+  lang_statement_list_type *seg_stat_ptr;
+  union lang_statement_union *stat_list_remainder;
+  union lang_statement_union **stat_list_old_tail;
+  struct bfd_link_hash_entry *h;
+  bfd_vma irxname_pos;
+  asection *irxname_sec;
+  bfd_vma irxid_pos;
+  asection *irxid_sec;
+  int irx_version;
+  char buf[64];
+  bfd_boolean result;
+  unsigned uit;
+  asymbol **syms;
+  arelent **rels;
+  long size;
+  long count;
+
+  gld${EMULATION_NAME}_after_open();
+
+  /* Only setup IRX headers for executable files.  */
+  if (building_irx == FALSE)
+    return;
+  
+  /* If the linker script didn't already start the .iopmod section,
+     build the basics now.  */
+  seg_stat_ptr = &iopmod_section_statement->children;
+  if (seg_stat_ptr->head == NULL)
+  {
+    new_data_stat (LONG, exp_intop (0xffffffff), seg_stat_ptr);
+    new_data_stat (LONG, exp_unop (ABSOLUTE, exp_nameop (NAME, "_start")),
+      seg_stat_ptr);
+    new_data_stat (LONG, exp_nameop (NAME, "_gp"), seg_stat_ptr);
+    new_data_stat (LONG, exp_nameop (NAME, "_text_size"), seg_stat_ptr);
+    new_data_stat (LONG, exp_nameop (NAME, "_data_size"), seg_stat_ptr);
+    new_data_stat (LONG, exp_nameop (NAME, "_bss_size"), seg_stat_ptr);
+    stat_list_old_tail = NULL;
+  }
+  else
+  {
+    /* If the linker script built an .iopmod section, make sure the
+       first six data statments are LONGS, and that the first LONG
+       is set to the int 0xffffffff.  If not, assume the linker
+       script knows what it's doing, and leave everything alone.  */
+    union lang_statement_union *stat_iter;
+    stat_iter = seg_stat_ptr->head;
+    /* Make sure the first satement is a LONG data statement with
+       the value 0xffffffff.  */
+    if (stat_iter->header.type != lang_data_statement_enum
+      || stat_iter->data_statement.type != LONG
+      || stat_iter->data_statement.exp->type.node_class != etree_value
+      || stat_iter->data_statement.exp->type.node_code != INT
+      || stat_iter->data_statement.exp->value.value != 0xffffffff)
+        return;
+
+    /* Make sure the next five statements are LONG data statements.  */
+    stat_iter = stat_iter->header.next;
+    if (stat_iter->header.type != lang_data_statement_enum
+      || stat_iter->data_statement.type != LONG)
+        return;
+    stat_iter = stat_iter->header.next;
+    if (stat_iter->header.type != lang_data_statement_enum
+      || stat_iter->data_statement.type != LONG)
+      return;
+    stat_iter = stat_iter->header.next;
+    if (stat_iter->header.type != lang_data_statement_enum
+      || stat_iter->data_statement.type != LONG)
+      return;
+    stat_iter = stat_iter->header.next;
+    if (stat_iter->header.type != lang_data_statement_enum
+      || stat_iter->data_statement.type != LONG)
+      return;
+    stat_iter = stat_iter->header.next;
+    if (stat_iter->header.type != lang_data_statement_enum
+      || stat_iter->data_statement.type != LONG)
+      return;
+      
+    /* Cut the statement list off after the six LONGs, so that new
+       data can be inserted.  */
+    stat_list_old_tail = seg_stat_ptr->tail;
+    seg_stat_ptr->tail = &stat_iter->header.next;
+    stat_list_remainder = stat_iter->header.next;
+  }
+
+  /* Look for an _irx_id symbol.  */
+  h = bfd_link_hash_lookup (link_info.hash, "_irx_id", FALSE, FALSE, TRUE);
+  if (h != NULL)
+    if (h->type != bfd_link_hash_defined && h->type != bfd_link_hash_defweak)
+      h = NULL;
+
+  /* If _irx_id is undefined.  Set the IRX version to 0.0 and name to
+     an empty string.  */
+  if (h == NULL)
+  {
+    new_data_stat (SHORT, exp_intop (0x0), seg_stat_ptr);
+    new_data_stat (BYTE, exp_intop (0x0), seg_stat_ptr);
+    goto eout;
+  }
+
+  /* Retrieve the contents of _irx_id.  */
+  irxid_pos = h->u.def.value;
+  irxid_sec = h->u.def.section;
+  result = bfd_get_section_contents (irxid_sec->owner,
+             irxid_sec, buf,
+             irxid_pos, 8);
+  if (! result)
+  {
+    einfo ("%F%P: could not read the contents of _irx_id from %E\n",
+     irxid_sec->owner);
+    goto eout;
+  }
+
+  /* Extract the version number, and a pointer to the irx name.  */
+  irxname_pos = bfd_get_32 (irxid_sec->owner, &buf[0]);
+  irx_version = bfd_get_16 (irxid_sec->owner, &buf[4]);
+
+  /* Things get really ugly here.  The contents of the symbol table
+     and relocations are already in memory in the bfd's elf backend,
+     after calling the canonicalize functions there are two copies in
+     memory, one in the backends own format, and one in bfd's standard
+     format.  This could be a waste of memory, but we need to follow
+     the relocations, and digging through the backend's data would be
+     even uglier.  */
+
+  /* Canonicalize the symbol table for the bfd contaning _irx_id.  */
+  size = bfd_get_symtab_upper_bound (irxid_sec->owner);
+  if (size < 0)
+  {
+    einfo ("%F%P: could not read symbols from %E\n", irxid_sec->owner);
+    goto eout;
+  }
+  syms = xmalloc (size);
+  count = bfd_canonicalize_symtab (irxid_sec->owner, syms);
+  if (count < 0)
+  {
+    einfo ("%F%P: could not read symbols from %E\n",
+     irxid_sec->owner);
+    goto eout;
+  }
+  
+  /* Canonicalize the relocations for the section containing _irx_id.  */
+  size = bfd_get_reloc_upper_bound (irxid_sec->owner, irxid_sec);
+  if (size < 0)
+  {
+    einfo ("%F%P: could not read relocations from %E\n", irxid_sec->owner);
+    free (syms);
+    goto eout;
+  }
+  rels = xmalloc (size);
+  count = bfd_canonicalize_reloc (irxid_sec->owner, irxid_sec, rels, syms);
+  if (count < 0)
+  {
+    einfo ("%F%P: could not read relocations from %E\n", irxid_sec->owner);
+    free (syms);
+    goto eout;
+  }
+
+  /* Find the relocation for the irx name pointer in _irx_id, and
+     extract the section that the irx name is stored in from it.  */
+  irxname_sec = NULL;
+  for (uit = 0; uit < count; ++uit)
+  {
+    arelent *r;
+    r = rels[uit];
+    if (r->address == irxid_pos)
+    {
+      if ((*r->sym_ptr_ptr)->flags & (BSF_OBJECT | BSF_FUNCTION
+            | BSF_SECTION_SYM))
+        irxname_sec = (*r->sym_ptr_ptr)->section;
+      else
+      {
+        /* The irx name is not in the same bfd, but we know what
+         the symbol is called now, so we can look for it in
+         the other bfds.  */
+        h = bfd_link_hash_lookup (link_info.hash,
+          (*r->sym_ptr_ptr)->name, FALSE,
+          FALSE, TRUE);
+        if (h != NULL)
+        {
+          irxname_pos = h->u.def.value;
+          irxname_sec = h->u.def.section;
+        }
+      }
+    }
+  }
+
+  /* Release what little memory we can.  */
+  free (rels);
+  free (syms);
+  
+  if (irxname_sec == NULL)
+  {
+    einfo ("%F%P: failed to resolve the irx name\n");
+    goto eout;
+  }
+
+  /* Retrieve up to 63 bytes of the the contents of the irx name.  */
+  count = irxname_sec->size;
+  count -= irxname_pos;
+  if (count > 63)
+    count = 63;
+  buf[count] = 0;
+  result = bfd_get_section_contents (irxname_sec->owner,
+             irxname_sec, buf,
+             irxname_pos, count);
+  if (! result)
+  {
+    einfo ("%F%P: failed to resolve the irx name\n");
+    goto eout;
+  }
+
+  /* Set the first LONG in the .iopmod section to the address of the
+     _irx_id structure.  */
+  seg_stat_ptr->head->data_statement.exp =
+    exp_unop (ABSOLUTE, exp_nameop (NAME, "_irx_id"));
+  /* Add the version number to the header.  */
+  new_data_stat (SHORT, exp_intop (irx_version), seg_stat_ptr);
+  /* Add each byte of the IRX name to the header.  FIXME: If the name
+     is long and the linker script already has a lot of statements in
+     it, the linker could run out of space in the parse tree.  This
+     data could be added to the linker script as LONGs, and a SHORT,
+     and/or a BYTE to save tree nodes.  */
+  for (uit = 0; (uit < 64) && (buf[uit] != 0); ++uit)
+    new_data_stat (BYTE, exp_intop ((unsigned int) buf[uit]), seg_stat_ptr);
+  /* Tack a null on to the end of the string.  */
+  new_data_stat (BYTE, exp_intop (0x0), seg_stat_ptr);
+
+eout:
+  /* Put anything that was cut off the end of the .iopmod section back
+     on.  */
+  if (stat_list_old_tail != NULL)
+  {
+    *seg_stat_ptr->tail = stat_list_remainder;
+    seg_stat_ptr->tail = stat_list_old_tail;
+  }
+}
+
+/* Called before creating the output sections in the output bfd.
+   Since the .iopmod section's data is completely generated, it
+   doesn't have any alignment attributes associated with it.  Force
+   the iopmod section to be word aligned.  */
+
+static void
+irx_before_allocation (void)
+{
+  /* Only setup IRX headers for executable files.  */
+  if (building_irx)
+  {
+    if (iopmod_section_statement->bfd_section->alignment_power < 2)
+      iopmod_section_statement->bfd_section->alignment_power = 2;
+  }
+
+  mips_before_allocation();
+}
+
+/* Called after the output sections have been created.  Makes the
+   .iopmod section exist in the file image, but not in the memory
+   image by marking it as a loaded section, but not allocated.  */
+
+static void
+irx_after_allocation (void)
+{
+  /* Only setup IRX headers for executable files.  */
+  if (building_irx)
+  {
+    iopmod_section_statement->bfd_section->flags |= SEC_LOAD;
+    iopmod_section_statement->bfd_section->flags &= ~SEC_ALLOC;
+  }
+
+  gld${EMULATION_NAME}_after_allocation();
+}
+
+EOF
+
+LDEMUL_BEFORE_PARSE=irx_before_parse
+LDEMUL_AFTER_PARSE=gld${EMULATION_NAME}_after_parse
+LDEMUL_AFTER_OPEN=irx_after_open
+LDEMUL_AFTER_ALLOCATION=irx_after_allocation
+LDEMUL_BEFORE_ALLOCATION=irx_before_allocation
diff -burNpd binutils-2.25.1.orig/ld/scripttempl/irx.sc binutils-2.25.1.PS2/ld/scripttempl/irx.sc
--- binutils-2.25.1.orig/ld/scripttempl/irx.sc	1969-12-31 18:00:00.000000000 -0600
+++ binutils-2.25.1.PS2/ld/scripttempl/irx.sc	2019-12-27 15:50:33.384594958 -0600
@@ -0,0 +1,126 @@
+# Link scripts for PlayStation 2 IRXs.
+
+# NOTE: Limit parameter expansions to a single line.  Cygwin's /bin/sh has
+# been freaking out when it reaches the end of a line, even when the text is
+# being quoted.
+
+test -z "$ENTRY" && ENTRY=_start
+
+test -z "$TEXT_START_ADDR" && TEXT_START_ADDR="0x0000"
+
+if test "x$LD_FLAG" = "xn" -o "x$LD_FLAG" = "xN"; then
+  DATA_ADDR=.
+else
+  test -z "$DATA_ADDR" && DATA_ADDR=0x10000000
+fi
+
+# These variables are used to put braces in parameter expansions so that
+# they expand properly.
+LBRACE="{"
+RBRACE="}"
+
+cat <<EOF
+/* Link script for PlayStation 2 IRXs
+ * Written by Douglas C. Knight <fsdck@uaf.edu>
+ */
+
+OUTPUT_FORMAT("${OUTPUT_FORMAT}")
+
+${RELOCATING+${LIB_SEARCH_DIRS}}
+
+ENTRY(${ENTRY})
+SECTIONS
+{
+  ${RELOCATING+/* This is the .iopmod section for the IRX, it contains}
+  ${RELOCATING+   information that the IOP uses when loading the IRX.}
+  ${RELOCATING+   This section is placed in its own segment.  */}
+  ${RELOCATING+.iopmod : ${LBRACE}}
+  ${RELOCATING+  /* The linker will replace this first LONG with a pointer}
+  ${RELOCATING+     to _irx_id if the symbol has been defined.  */}
+  ${RELOCATING+  LONG (0xffffffff) ;}
+ 
+  ${RELOCATING+  LONG (_start) ;}
+  ${RELOCATING+  LONG (_gp) ;}
+  ${RELOCATING+  LONG (_text_size) ;}
+  ${RELOCATING+  LONG (_data_size) ;}
+  ${RELOCATING+  LONG (_bss_size) ;}
+  ${RELOCATING+  /* The linker will put a SHORT here with the version of}
+  ${RELOCATING+     the IRX (or zero if there is no version).  */}
+  ${RELOCATING+  /* The linker will put a null terminated string here}
+  ${RELOCATING+     containing the name of the IRX (or an empty string if}
+  ${RELOCATING+     the name is not known).  */}
+  ${RELOCATING+${RBRACE}}
+
+  ${RELOCATING+. = ${TEXT_START_ADDR} ;}
+  ${RELOCATING+_ftext = . ;}
+  .text : {
+    CREATE_OBJECT_SYMBOLS
+    * ( .text )
+    * ( .text.* )
+    * ( .init )
+    * ( .fini )
+  } = 0
+  ${RELOCATING+_etext  =  . ;}
+
+  ${RELOCATING+. = ${DATA_ADDR} ;}
+  ${RELOCATING+_fdata = . ;}
+  .rodata : {
+    * ( .rdata )
+    * ( .rodata )
+    * ( .rodata1 )
+    * ( .rodata.* )
+  } = 0
+
+  .data : {
+    * ( .data )
+    * ( .data1 )
+    * ( .data.* )
+    ${CONSTRUCTING+CONSTRUCTORS}
+  }
+
+  ${RELOCATING+. = ALIGN(16) ;}
+  ${RELOCATING+_gp = . + 0x8000 ;}
+
+  .sdata : {
+    * ( .lit8 )
+    * ( .lit4 )
+    * ( .sdata )
+    * ( .sdata.* )
+  }
+  ${RELOCATING+_edata = . ;}
+
+  ${RELOCATING+. = ALIGN(4) ;}
+  ${RELOCATING+_fbss = . ;}
+  .sbss : {
+    * ( .sbss )
+    * ( .scommon )
+  }
+
+  ${RELOCATING+_bss_start = . ;}
+  .bss : {
+    * ( .bss )
+    * ( COMMON )
+    ${RELOCATING+. = ALIGN(4) ;}
+  }
+  ${RELOCATING+_end = . ;}
+
+  ${RELOCATING+_text_size = _etext - _ftext ;}
+  ${RELOCATING+_data_size = _edata - _fdata ;}
+  ${RELOCATING+_bss_size = _end - _fbss ;}
+
+  /* These are the stuff that we don't want to be put in an IRX.  */
+  /DISCARD/ : {
+	* ( .MIPS.abiflags )
+	* ( .gnu.attributes )
+	* ( .comment )
+	* ( .reginfo )
+	* ( .mdebug.* )
+	/* This must go because it confuses the IOP kernel (treated as a reloc section). */
+	* ( .pdr )
+	/* Until I can figure out if there's a better way to rid ourselves of .rel.dyn
+	   this will have to do.  - MRB  */
+	* ( .rel.dyn )
+  }
+}
+
+EOF
diff -burNpd binutils-2.25.1.orig/opcodes/configure binutils-2.25.1.PS2/opcodes/configure
--- binutils-2.25.1.orig/opcodes/configure	2015-07-21 08:42:57.000000000 -0500
+++ binutils-2.25.1.PS2/opcodes/configure	2019-12-27 15:50:33.391762856 -0600
@@ -12547,6 +12547,7 @@ if test x${all_targets} = xfalse ; then
 	bfd_d10v_arch)		ta="$ta d10v-dis.lo d10v-opc.lo" ;;
 	bfd_d30v_arch)		ta="$ta d30v-dis.lo d30v-opc.lo" ;;
 	bfd_dlx_arch)		ta="$ta dlx-dis.lo" ;;
+	bfd_dvp_arch)		ta="$ta mips-dis.lo mips-opc.lo mips16-opc.lo dvp-dis.lo dvp-opc.lo" ;;
 	bfd_fr30_arch)		ta="$ta fr30-asm.lo fr30-desc.lo fr30-dis.lo fr30-ibld.lo fr30-opc.lo" using_cgen=yes ;;
 	bfd_frv_arch)		ta="$ta frv-asm.lo frv-desc.lo frv-dis.lo frv-ibld.lo frv-opc.lo" using_cgen=yes ;;
 	bfd_moxie_arch)		ta="$ta moxie-dis.lo moxie-opc.lo" ;;
diff -burNpd binutils-2.25.1.orig/opcodes/configure.ac binutils-2.25.1.PS2/opcodes/configure.ac
--- binutils-2.25.1.orig/opcodes/configure.ac	2014-10-14 02:32:04.000000000 -0500
+++ binutils-2.25.1.PS2/opcodes/configure.ac	2019-12-27 15:50:33.394205521 -0600
@@ -264,6 +264,7 @@ if test x${all_targets} = xfalse ; then
 	bfd_d10v_arch)		ta="$ta d10v-dis.lo d10v-opc.lo" ;;
 	bfd_d30v_arch)		ta="$ta d30v-dis.lo d30v-opc.lo" ;;
 	bfd_dlx_arch)		ta="$ta dlx-dis.lo" ;;
+	bfd_dvp_arch)		ta="$ta mips-dis.lo mips-opc.lo mips16-opc.lo dvp-dis.lo dvp-opc.lo" ;;
 	bfd_fr30_arch)		ta="$ta fr30-asm.lo fr30-desc.lo fr30-dis.lo fr30-ibld.lo fr30-opc.lo" using_cgen=yes ;;
 	bfd_frv_arch)		ta="$ta frv-asm.lo frv-desc.lo frv-dis.lo frv-ibld.lo frv-opc.lo" using_cgen=yes ;;
 	bfd_moxie_arch)		ta="$ta moxie-dis.lo moxie-opc.lo" ;;
diff -burNpd binutils-2.25.1.orig/opcodes/disassemble.c binutils-2.25.1.PS2/opcodes/disassemble.c
--- binutils-2.25.1.orig/opcodes/disassemble.c	2014-10-14 02:32:04.000000000 -0500
+++ binutils-2.25.1.PS2/opcodes/disassemble.c	2019-12-27 15:50:33.395463505 -0600
@@ -319,12 +319,16 @@ disassembler (abfd)
       disassemble = print_insn_metag;
       break;
 #endif
-#ifdef ARCH_mips
+#if defined(ARCH_mips) || defined(ARCH_dvp)
     case bfd_arch_mips:
+#ifdef ARCH_mips
       if (bfd_big_endian (abfd))
 	disassemble = print_insn_big_mips;
       else
 	disassemble = print_insn_little_mips;
+#else
+	disassemble = print_insn_dvp;
+#endif
       break;
 #endif
 #ifdef ARCH_mmix
diff -burNpd binutils-2.25.1.orig/opcodes/dvp-dis.c binutils-2.25.1.PS2/opcodes/dvp-dis.c
--- binutils-2.25.1.orig/opcodes/dvp-dis.c	1969-12-31 18:00:00.000000000 -0600
+++ binutils-2.25.1.PS2/opcodes/dvp-dis.c	2019-12-27 15:50:33.397697913 -0600
@@ -0,0 +1,442 @@
+/* Instruction printing code for the DVP
+   Copyright (C) 1998 Free Software Foundation, Inc. 
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include "sysdep.h"
+#include "dis-asm.h"
+#include "opcode/dvp.h"
+#include "elf-bfd.h"
+#include "elf/mips.h"
+#include "opintl.h"
+
+int dvp_info_mach_type (struct disassemble_info *info);
+static int print_dma (bfd_vma, disassemble_info *);
+static int print_vif (bfd_vma, disassemble_info *);
+static int print_gif (bfd_vma, disassemble_info *);
+static int print_vu (bfd_vma, disassemble_info *);
+static void print_insn (dvp_cpu, const dvp_opcode *, const dvp_operand *,
+				bfd_vma, disassemble_info *, DVP_INSN *);
+
+static int read_word (bfd_vma, disassemble_info *, DVP_INSN *);
+
+/* Return the dvp mach number to use or 0 if not at a dvp insn.
+   The different machs are distinguished by marking the start of a group
+   of related insns by a specially marked label.  */
+
+int
+dvp_info_mach_type (info)
+     struct disassemble_info *info;
+{
+  if (info->flavour == bfd_target_elf_flavour
+      && info->symbols != NULL)
+    {
+      asymbol **sym,**symend;
+
+      for (sym = info->symbols, symend = sym + info->num_symbols;
+	   sym < symend; ++sym)
+	{
+	  int sto = (*(elf_symbol_type **) sym)->internal_elf_sym.st_other;
+	  switch (sto)
+	    {
+	    case STO_DVP_DMA : return bfd_mach_dvp_dma;
+	    case STO_DVP_VIF : return bfd_mach_dvp_vif;
+	    case STO_DVP_GIF : return bfd_mach_dvp_gif;
+	    case STO_DVP_VU : return bfd_mach_dvp_vu;
+	    default : break;
+	    }
+	}
+    }
+
+  return 0;
+}
+
+/* Print one instruction from PC on INFO->STREAM.
+   Return the size of the instruction.  */
+
+int
+print_insn_dvp (memaddr, info)
+     bfd_vma memaddr;
+     disassemble_info *info;
+{
+  int mach;
+  static int initialized = 0;
+
+  if (!initialized)
+    {
+      initialized = 1;
+      dvp_opcode_init_tables ();
+    }
+
+  mach = dvp_info_mach_type (info);
+  if (mach == bfd_mach_dvp_dma
+      || info->mach == bfd_mach_dvp_dma)
+    return print_dma (memaddr, info);
+  if (mach == bfd_mach_dvp_vif
+      || info->mach == bfd_mach_dvp_vif)
+    return print_vif (memaddr, info);
+  if (mach == bfd_mach_dvp_gif
+      || info->mach == bfd_mach_dvp_gif)
+    return print_gif (memaddr, info);
+  if (mach == bfd_mach_dvp_vu
+      || info->mach == bfd_mach_dvp_vu)
+    return print_vu (memaddr, info);
+
+  (*info->fprintf_func) (info->stream, _("*unknown*"));
+  return 4;
+}
+
+/* Print one DMA instruction from PC on INFO->STREAM.
+   Return the size of the instruction.  */
+
+static int
+print_dma (memaddr, info)
+     bfd_vma memaddr;
+     disassemble_info *info;
+{
+  bfd_byte buffer[8];
+  int i, status, len;
+  DVP_INSN insn_buf[2];
+
+  /* The length of a dma tag is 16, however the upper two words are
+     vif insns.  */
+
+  len = 8;
+  status = (*info->read_memory_func) (memaddr, buffer, len, info);
+  if (status != 0)
+    {
+      (*info->memory_error_func) (status, memaddr, info);
+      return -1;
+    }
+
+  for (i = 0; i < 2; ++i)
+    insn_buf[i] = bfd_getl32 (buffer + i * 4);
+
+  print_insn (DVP_DMA,
+	      dma_opcode_lookup_dis (insn_buf[1]), dma_operands,
+	      memaddr, info, insn_buf);
+  return len;
+}
+
+/* Print one VIF instruction from PC on INFO->STREAM.
+   Return the size of the instruction.  */
+
+static int
+print_vif (memaddr, info)
+     bfd_vma memaddr;
+     disassemble_info *info;
+{
+  int len;
+  /* Non-zero if vu code follows (i.e. this is mpg).  */
+  dvp_cpu cpu;
+  DVP_INSN insn_buf[5];
+
+  if (read_word (memaddr, info, insn_buf) != 0)
+    return -1;
+
+  len = vif_insn_len (insn_buf[0], &cpu);
+  switch (len)
+    {
+    case 5 :
+      if (read_word (memaddr + 16, info, insn_buf + 4) != 0)
+	return -1;
+      if (read_word (memaddr + 12, info, insn_buf + 3) != 0)
+	return -1;
+      if (read_word (memaddr + 8, info, insn_buf + 2) != 0)
+	return -1;
+      /* fall through */
+    case 2 :
+      if (read_word (memaddr + 4, info, insn_buf + 1) != 0)
+	return -1;
+      /* fall through */
+    case 1 :
+    case 0 :
+      break;
+    }
+
+  print_insn (DVP_VIF,
+	      vif_opcode_lookup_dis (insn_buf[0]), vif_operands,
+	      memaddr, info, insn_buf);
+
+  /* If symbols are present and this is an mpg or direct insn, assume there
+     are symbols to distinguish the mach type so that we can properly
+     disassemble the vu code and gif tags.  */
+  if (info->symbols
+      && (cpu == DVP_VUUP || cpu == DVP_GIF))
+    return 4;
+  return len * 4;
+}
+
+/* Print one GIF instruction from PC on INFO->STREAM.
+   Return the size of the instruction.  */
+
+static int
+print_gif (memaddr, info)
+     bfd_vma memaddr;
+     disassemble_info *info;
+{
+  bfd_byte buffer[16];
+  int i, status, len, type, nloop, nregs;
+  DVP_INSN insn_buf[4];
+
+  status = (*info->read_memory_func) (memaddr, buffer, 16, info);
+  if (status != 0)
+    {
+      (*info->memory_error_func) (status, memaddr, info);
+      return -1;
+    }
+  len = 16;
+
+  for (i = 0; i < 4; ++i)
+    insn_buf[i] = bfd_getl32 (buffer + i * 4);
+
+  print_insn (DVP_GIF,
+	      gif_opcode_lookup_dis (insn_buf[1]), gif_operands,
+	      memaddr, info, insn_buf);
+
+  type = (insn_buf[1] >> 26) & 3;
+  nloop = insn_buf[0] & 0x7fff;
+  nregs = (insn_buf[1] >> 28) & 15;
+  switch (type)
+    {
+    case GIF_PACKED :
+      return len + nloop * nregs * 16;
+    case GIF_REGLIST :
+      return len + ((nloop * nregs + 1) & ~1) * 8;
+    case GIF_IMAGE :
+      return len + nloop * 16;
+    }
+
+  return len;
+}
+
+/* Print one VU instruction from PC on INFO->STREAM.
+   Return the size of the instruction.  */
+
+static int
+print_vu (memaddr, info)
+     bfd_vma memaddr;
+     disassemble_info *info;
+{
+  bfd_byte buffer[8];
+  void *stream = info->stream;
+  fprintf_ftype func = info->fprintf_func;
+  int status;
+  /* First element is upper, second is lower.  */
+  DVP_INSN upper,lower;
+
+  status = (*info->read_memory_func) (memaddr, buffer, 8, info);
+  if (status != 0)
+    {
+      (*info->memory_error_func) (status, memaddr, info);
+      return -1;
+    }
+  /* The lower instruction has the lower address.  */
+  upper = bfd_getl32 (buffer + 4);
+  lower = bfd_getl32 (buffer);
+
+  /* FIXME: This will need revisiting.  */
+  print_insn (DVP_VUUP,
+	      vu_upper_opcode_lookup_dis (upper), vu_operands,
+	      memaddr, info, &upper);
+#ifdef VERTICAL_BAR_SEPARATOR
+  (*func) (stream, " | ");
+#else
+  /* Not sure how much whitespace to print here.
+     At least two spaces, not more than 9, and having columns line up somewhat
+     seems reasonable.  */
+  (*func) (stream, " \t");
+#endif
+  /* If the 'i' bit is set then the lower word is not an insn but a 32 bit
+     floating point immediate value.  */
+  if (upper & 0x80000000)
+    {
+      /* FIXME: assumes float/int are same size/endian.  */
+      union { float f; int i; } x;
+      x.i = lower;
+      (*func) (stream, "loi %g", x.f);
+    }
+  else
+    print_insn (DVP_VULO,
+		vu_lower_opcode_lookup_dis (lower), vu_operands,
+		memaddr, info, &lower);
+
+  return 8;
+}
+
+/* Print one instruction.
+   OPCODE is a pointer to the head of the hash list.  */
+
+static void
+print_insn (cpu, opcode, operand_table, memaddr, info, insn)
+     dvp_cpu cpu __attribute__((unused));
+     const dvp_opcode *opcode;
+     const dvp_operand *operand_table;
+     bfd_vma memaddr;
+     disassemble_info *info;
+     DVP_INSN *insn;
+{
+  void *stream = info->stream;
+  fprintf_ftype func = info->fprintf_func;
+
+  for ( ; opcode != NULL; opcode = DVP_OPCODE_NEXT_DIS (opcode))
+    {
+      const unsigned char *syn;
+      int mods,invalid,num_operands;
+      long value;
+      const dvp_operand *operand;
+
+      /* Ignore insns that have a mask value of 0.
+	 Such insns are not intended to be disassembled by us.  */
+      if (opcode->mask == 0)
+	continue;
+      if (opcode->flags & DVP_OPCODE_IGNORE_DIS)
+	continue;
+      /* Basic bit mask must be correct.  */
+      if ((insn[opcode->opcode_word] & opcode->mask) != opcode->value)
+	continue;
+
+      /* Make two passes over the operands.  First see if any of them
+	 have extraction functions, and, if they do, make sure the
+	 instruction is valid.  */
+
+      dvp_opcode_init_print ();
+      invalid = 0;
+
+      for (syn = opcode->syntax; *syn; ++syn)
+	{
+	  int index;
+
+	  if (*syn < 128)
+	    continue;
+
+	  mods = 0;
+	  index = DVP_OPERAND_INDEX (*syn);
+	  while (DVP_MOD_P (operand_table[index].flags))
+	    {
+	      mods |= operand_table[index].flags & DVP_MOD_BITS;
+	      ++syn;
+	      index = DVP_OPERAND_INDEX (*syn);
+	    }
+	  operand = operand_table + index;
+	  if (operand->extract)
+	    (*operand->extract) (opcode, operand, mods, insn, &invalid);
+	}
+      if (invalid)
+	continue;
+
+      /* The instruction is valid.  */
+
+      (*func) (stream, "%s", opcode->mnemonic);
+      num_operands = 0;
+      for (syn = opcode->syntax; *syn; ++syn)
+	{
+	  int index;
+
+	  if (*syn < 128)
+	    {
+	      (*func) (stream, "%c", *syn);
+	      continue;
+	    }
+
+	  /* We have an operand.  Fetch any special modifiers.  */
+	  mods = 0;
+	  index = DVP_OPERAND_INDEX (*syn);
+	  while (DVP_MOD_P (operand_table[index].flags))
+	    {
+	      mods |= operand_table[index].flags & DVP_MOD_BITS;
+	      ++syn;
+	      index = DVP_OPERAND_INDEX (*syn);
+	    }
+	  operand = operand_table + index;
+
+	  /* Extract the value from the instruction.  */
+	  if (operand->extract)
+	    {
+	      value = (*operand->extract) (opcode, operand, mods,
+					   insn, (int *) NULL);
+	    }
+	  else
+	    {
+	      /* We currently assume a field does not cross a word boundary.  */
+	      int shift = ((mods & DVP_MOD_THIS_WORD)
+			   ? (operand->shift & 31)
+			   : operand->shift);
+	      /* FIXME: There are currently two ways to specify which word:
+		 the `word' member and shift / 32.  */
+	      int word = operand->word ? operand->word : shift / 32;
+	      DVP_INSN mask = (operand->bits == 32
+			       ? 0xffffffff : (DVP_INSN)((1 << operand->bits) - 1));
+	      shift = shift % 32;
+	      value = (insn[word] >> shift) & mask;
+	      if ((operand->flags & DVP_OPERAND_SIGNED) != 0
+		  && (value & (1 << (operand->bits - 1)))
+		  && operand->bits < 8 * sizeof (long))
+		value -= 1L << operand->bits;
+	    }
+
+	  /* Print the operand as directed by the flags.  */
+	  if (operand->print)
+	    (*operand->print) (opcode, operand, mods, insn, info, value);
+	  else if (operand->flags & DVP_OPERAND_FAKE)
+	    ; /* nothing to do (??? at least not yet) */
+	  else if (operand->flags & DVP_OPERAND_RELATIVE_BRANCH)
+	    (*info->print_address_func) (memaddr + 8 + (value << 3), info);
+	  /* ??? Not all cases of this are currently caught.  */
+	  else if (operand->flags & DVP_OPERAND_ABSOLUTE_BRANCH)
+	    (*info->print_address_func) ((bfd_vma) value & 0xffffffff, info);
+	  else if (operand->flags & DVP_OPERAND_MIPS_ADDRESS)
+	    (*info->print_address_func) ((bfd_vma) value & 0xffffffff, info);
+	  else if (operand->flags & (DVP_OPERAND_VU_ADDRESS | DVP_OPERAND_UNPACK_ADDRESS))
+	    (*func) (stream, "0x%lx", value & 0xffffffff);
+          else if ((operand->flags & (DVP_OPERAND_SIGNED | DVP_OPERAND_RELOC_11_S4)) != 0
+		   || (value >= -1 && value < 16))
+	    (*func) (stream, "%ld", value);
+	  else
+	    (*func) (stream, "0x%lx", value);
+
+	  if (! (operand->flags & DVP_OPERAND_SUFFIX))
+	    ++num_operands;
+	}
+
+      /* We have found and printed an instruction; return.  */
+      return;
+    }
+
+  (*func) (stream, _("*unknown*"));
+}
+
+
+/* Utility to read one word.
+   The result is 0 for success, -1 for failure.  */
+
+static int
+read_word (memaddr, info, insn_buf)
+     bfd_vma memaddr;
+     disassemble_info *info;
+     DVP_INSN *insn_buf;
+{
+  int status;
+  bfd_byte buffer[4];
+
+  status = (*info->read_memory_func) (memaddr, buffer, 4, info);
+  if (status != 0)
+    {
+      (*info->memory_error_func) (status, memaddr, info);
+      return -1;
+    }
+  *insn_buf = bfd_getl32 (buffer);
+  return 0;
+}
diff -burNpd binutils-2.25.1.orig/opcodes/dvp-opc.c binutils-2.25.1.PS2/opcodes/dvp-opc.c
--- binutils-2.25.1.orig/opcodes/dvp-opc.c	1969-12-31 18:00:00.000000000 -0600
+++ binutils-2.25.1.PS2/opcodes/dvp-opc.c	2019-12-27 15:50:33.409790131 -0600
@@ -0,0 +1,3402 @@
+/* Opcode table for the DVP
+   Copyright (c) 1998 Free Software Foundation, Inc.
+   
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include "sysdep.h"
+#include "ansidecl.h"
+#include "libiberty.h"
+#include "dis-asm.h"
+#include "opcode/dvp.h"
+#include "opintl.h"
+
+#include <ctype.h>
+
+#define MIN(a,b) ((a) < (b) ? (a) : (b))
+
+typedef struct {
+  int value;
+  const char *name;
+} keyword;
+
+static long u_parse_dest (char **pstr);
+static void u_print_dest (disassemble_info *info, DVP_INSN *insn, long value);
+static long u_parse_sdest (char **pstr, const char **errmsg);
+static int lookup_keyword_value (const keyword *, const char *, int);
+static const char *lookup_keyword_name (const keyword *table, int);
+
+static char *scan_symbol (char *);
+
+/* Return non-zero if CH is a character that may appear in a symbol.  */
+/* FIXME: This will need revisiting.  */
+#define issymchar(ch) (isalnum ((unsigned char) ch) || ch == '_')
+
+#define SKIP_BLANKS(var) while (isspace ((unsigned char) *(var))) ++(var)
+
+/* ??? One can argue it's preferable to have the PARSE_FN support in tc-dvp.c
+   and the PRINT_FN support in dvp-dis.c.  For this project I like having
+   them all in one place.  */
+
+#define PARSE_FN(fn) \
+static long CONCAT2 (parse_,fn) \
+     (const dvp_opcode *, const dvp_operand *, int, char **, \
+	      const char **);
+#define INSERT_FN(fn) \
+static void CONCAT2 (insert_,fn) \
+     (const dvp_opcode *, const dvp_operand *, int, DVP_INSN *, \
+	      long, const char **)
+#define EXTRACT_FN(fn) \
+static long CONCAT2 (extract_,fn) \
+     (const dvp_opcode *, const dvp_operand *, int, DVP_INSN *, \
+	      int *);
+#define PRINT_FN(fn) \
+static void CONCAT2 (print_,fn) \
+     (const dvp_opcode *, const dvp_operand *, int, DVP_INSN *, \
+	      disassemble_info *, long);
+
+PARSE_FN (dotdest);
+INSERT_FN (dotdest);
+EXTRACT_FN (dotdest);
+PRINT_FN (dotdest);
+
+PARSE_FN (dotdest1);
+PARSE_FN (dest1);
+PRINT_FN (dest1);
+
+PARSE_FN (uflags);
+PRINT_FN (uflags);
+
+PARSE_FN (bc);
+EXTRACT_FN (bc);
+PRINT_FN (sdest);
+
+PARSE_FN (vfreg);
+PRINT_FN (vfreg);
+
+PARSE_FN (bcftreg);
+PRINT_FN (bcftreg);
+
+PARSE_FN (accdest);
+PRINT_FN (accdest);
+
+INSERT_FN (xyz);
+INSERT_FN (w);
+
+PARSE_FN (ireg);
+PRINT_FN (ireg);
+
+PARSE_FN (freg);
+PRINT_FN (freg);
+
+PARSE_FN (ffstreg);
+INSERT_FN (ffstreg);
+EXTRACT_FN (ffstreg);
+PRINT_FN (ffstreg);
+
+PARSE_FN (vi01);
+PRINT_FN (vi01);
+
+INSERT_FN (luimm12);
+EXTRACT_FN (luimm12);
+
+INSERT_FN (luimm12up6);
+
+INSERT_FN (luimm15);
+EXTRACT_FN (luimm15);
+
+/* Various types of DVP operands, including insn suffixes.
+
+   Fields are:
+
+   BITS SHIFT FLAGS PARSE_FN INSERT_FN EXTRACT_FN PRINT_FN
+
+   Operand values are 128 + table index.  This allows ASCII chars to be
+   included in the syntax spec.  */
+
+const dvp_operand vu_operands[] =
+{
+  /* place holder (??? not sure if needed) */
+#define UNUSED 128
+  { 0 },
+
+  /* Operands that exist in the same place for essentially the same purpose
+     in both upper and lower instructions.  These don't have a U or L prefix.
+     Operands specific to the upper or lower instruction are so prefixed.  */
+
+  /* Destination indicator attached to mnemonic, with leading '.' or '/'.
+     After parsing this, the value is stored in global `state_vu_mnemonic_dest'
+     so that the register parser can verify the same choice of xyzw is
+     used.  */
+#define DOTDEST (UNUSED + 1)
+  { 4, VU_SHIFT_DEST, 0, DVP_OPERAND_SUFFIX,
+      parse_dotdest, insert_dotdest, extract_dotdest, print_dotdest },
+
+  /* ft reg, with vector specification same as DOTDEST */
+#define VFTREG (DOTDEST + 1)
+  { 5, VU_SHIFT_TREG, 0, 0, parse_vfreg, 0, 0, print_vfreg },
+
+  /* fs reg, with vector specification same as DOTDEST */
+#define VFSREG (VFTREG + 1)
+  { 5, VU_SHIFT_SREG, 0, 0, parse_vfreg, 0, 0, print_vfreg },
+
+  /* fd reg, with vector specification same as DOTDEST */
+#define VFDREG (VFSREG + 1)
+  { 5, VU_SHIFT_DREG, 0, 0, parse_vfreg, 0, 0, print_vfreg },
+
+  /* Upper word operands.  */
+
+  /* flag bits */
+#define UFLAGS (VFDREG + 1)
+  { 5, 27, 0, DVP_OPERAND_SUFFIX, parse_uflags, 0, 0, print_uflags },
+
+  /* broadcast */
+#define UBC (UFLAGS + 1)
+  { 2, 0, 0, DVP_OPERAND_SUFFIX, parse_bc, 0, extract_bc, print_sdest },
+
+  /* ftreg in broadcast case */
+#define UBCFTREG (UBC + 1)
+  { 5, VU_SHIFT_TREG, 0, 0, parse_bcftreg, 0, 0, print_bcftreg },
+
+  /* accumulator dest */
+#define UACCDEST (UBCFTREG + 1)
+  { 0, 0, 0, 0, parse_accdest, 0, 0, print_accdest },
+
+  /* The XYZ operand is a fake one that is used to ensure only "xyz" is
+     specified.  It simplifies the opmula and opmsub entries.  */
+#define UXYZ (UACCDEST + 1)
+  { 0, 0, 0, DVP_OPERAND_FAKE, 0, insert_xyz, 0, 0 },
+
+  /* The W operand is a fake one that is used to ensure only "w" is
+     specified.  It simplifies the clipw entry.  */
+#define UW (UXYZ + 1)
+  { 0, 0, 0, DVP_OPERAND_FAKE, 0, insert_w, 0, 0 },
+
+  /* Lower word operands.  */
+
+  /* 5 bit signed immediate.  */
+#define LIMM5 (UW + 1)
+  { 5, 6, 0, DVP_OPERAND_SIGNED, 0, 0, 0, 0 },
+
+  /* 11 bit signed immediate.  */
+#define LIMM11 (LIMM5 + 1)
+  { 11, 0, 0, DVP_OPERAND_SIGNED, 0, 0, 0, 0 },
+  /* WAS: { 11, 0, 0, DVP_OPERAND_RELOC_11_S4, 0, 0, 0, 0 },*/
+
+  /* 15 bit unsigned immediate.  */
+#define LUIMM15 (LIMM11 + 1)
+  { 15, 0, 0, DVP_OPERAND_RELOC_U15_S3, 0, insert_luimm15, extract_luimm15, 0 },
+
+  /* ID register.  */
+#define LIDREG (LUIMM15 + 1)
+  { 5, 6, 0, 0, parse_ireg, 0, 0, print_ireg },
+
+  /* IS register.  */
+#define LISREG (LIDREG + 1)
+  { 5, 11, 0, 0, parse_ireg, 0, 0, print_ireg },
+
+  /* IT register.  */
+#define LITREG (LISREG + 1)
+  { 5, 16, 0, 0, parse_ireg, 0, 0, print_ireg },
+
+  /* FS reg, with FSF field selector.  */
+#define LFSFFSREG (LITREG + 1)
+  { 5, 11, 0, 0, parse_ffstreg, insert_ffstreg, extract_ffstreg, print_ffstreg },
+
+  /* FS reg, no selector (choice of x,y,z,w is provided by opcode).  */
+#define LFSREG (LFSFFSREG + 1)
+  { 5, 11, 0, 0, parse_freg, 0, 0, print_freg },
+
+  /* FT reg, with FTF field selector.  */
+#define LFTFFTREG (LFSREG + 1)
+  { 5, 16, 0, 0, parse_ffstreg, insert_ffstreg, extract_ffstreg, print_ffstreg },
+
+  /* VI01 register.  */
+#define LVI01 (LFTFFTREG + 1)
+  { 0, 0, 0, 0, parse_vi01, 0, 0, print_vi01 },
+
+  /* 24 bit unsigned immediate.  */
+#define LUIMM24 (LVI01 + 1)
+  { 24, 0, 0, 0, 0, 0, 0, 0 },
+
+  /* 12 bit unsigned immediate, split into 1 and 11 bit pieces.  */
+#define LUIMM12 (LUIMM24 + 1)
+  { 12, 0, 0, 0, 0, insert_luimm12, extract_luimm12, 0 },
+
+  /* upper 6 bits of 12 bit unsigned immediate */
+#define LUIMM12UP6 (LUIMM12 + 1)
+  { 12, 0, 0, 0, 0, insert_luimm12up6, extract_luimm12, 0 },
+
+  /* 11 bit pc-relative signed immediate.  */
+#define LPCREL11 (LUIMM12UP6 + 1)
+  { 11, 0, 0, DVP_OPERAND_SIGNED + DVP_OPERAND_RELATIVE_BRANCH, 0, 0, 0, 0 },
+
+  /* Destination indicator, single letter only, with leading '.' or '/'.  */
+#define LDOTDEST1 (LPCREL11 + 1)
+  { 4, VU_SHIFT_DEST, 0, DVP_OPERAND_SUFFIX,
+      /* Note that we borrow the insert/extract/print functions from the
+	 vector case.  */
+      parse_dotdest1, insert_dotdest, extract_dotdest, print_dotdest },
+
+  /* Destination indicator, single letter only, no leading '.'.  */
+  /* ??? Making this FAKE is a workaround to a limitation in the parser.
+     It can't handle operands with a legitimate value of "".  */
+#define LDEST1 (LDOTDEST1 + 1)
+  { 0, 0, 0, DVP_OPERAND_FAKE, parse_dest1, 0, 0, print_dest1 },
+
+  /* 32 bit floating point immediate.  */
+#define LFIMM32 (LDEST1 + 1)
+  { 32, 0, 0, DVP_OPERAND_FLOAT, 0, 0, 0, 0 },
+/* end of list place holder */
+  { 0 }
+};
+
+
+/* Macros to put a field's value into the right place.  */
+/* ??? If assembler needs these, move to opcode/dvp.h.  */
+
+/* value X, B bits, shift S */
+#define V(x,b,s) (((x) & ((1 << (b)) - 1)) << (s))
+
+/* Field value macros for both upper and lower instructions.
+   These shift a value into the right place in the instruction.  */
+
+/* [FI] T reg field (remember it's V for value, not vector, here).  */
+#define VT(x) V ((x), 5, VU_SHIFT_TREG)
+/* [FI] S reg field.  */
+#define VS(x) V ((x), 5, VU_SHIFT_SREG)
+/* [FI] D reg field.  */
+#define VD(x) V ((x), 5, VU_SHIFT_DREG)
+/* DEST field.  */
+#define VDEST(x) V ((x), 4, 21)
+
+/* Masks for fields in both upper and lower instructions.
+   These mask out all bits but the ones for the field in the instruction.  */
+
+#define MT VT (~0)
+#define MS VS (~0)
+#define MD VD (~0)
+#define MDEST VDEST (~0)
+
+/* Upper instruction Value macros.  */
+
+/* Upper Flag bits.  */
+#define VUF(x) V ((x), 5, 27)
+/* Upper REServed two bits next to flag bits.  */
+#define VURES(x) V ((x), 2, 25)
+/* 4 bit opcode field.  */
+#define VUOP4(x) V ((x), 4, 2)
+/* 6 bit opcode field.  */
+#define VUOP6(x) V ((x), 6, 0)
+/* 9 bit opcode field.  */
+#define VUOP9(x) V ((x), 9, 2)
+/* 11 bit opcode field.  */
+#define VUOP11(x) V ((x), 11, 0)
+/* BroadCast field.  */
+#define VUBC(x) V ((x), 2, 0)
+
+/* Upper instruction field masks.  */
+#define MURES VURES (~0)
+#define MUOP4 VUOP4 (~0)
+#define MUOP6 VUOP6 (~0)
+#define MUOP9 VUOP9 (~0)
+#define MUOP11 VUOP11 (~0)
+
+/* A space, separates instruction name (mnemonic + mnemonic operands) from
+   operands.  */
+#define SP ' '
+/* Commas separate operands.  */
+#define C ','
+/* Special I,P,Q,R operands.  */
+#define I 'i'
+#define P 'p'
+#define Q 'q'
+#define R 'r'
+
+/* VU instructions.
+   [??? some of these comments are left over from the ARC port from which
+   this code is borrowed, delete in time]
+
+   Longer versions of insns must appear before shorter ones (if gas sees
+   "lsr r2,r3,1" when it's parsing "lsr %a,%b" it will think the ",1" is
+   junk).  This isn't necessary for `ld' because of the trailing ']'.
+
+   Instructions that are really macros based on other insns must appear
+   before the real insn so they're chosen when disassembling.  Eg: The `mov'
+   insn is really the `and' insn.
+
+   This table is best viewed on a wide screen (161 columns).  I'd prefer to
+   keep it this way.  The rest of the file, however, should be viewable on an
+   80 column terminal.  */
+
+/* ??? This table also includes macros: asl, lsl, and mov.  The ppc port has
+   a more general facility for dealing with macros which could be used if
+   we need to.  */
+
+/* These tables can't be `const' because members `next_asm' and `next_dis' are
+   computed at run-time.  We could split this into two, as that would put the
+   constant stuff into a readonly section.  */
+
+struct dvp_opcode vu_upper_opcodes[] =
+{
+  /* Macros appear first, so the disassembler will try them first.  */
+  /* ??? Any aliases?  */
+
+  /* The rest of these needn't be sorted, but it helps to find them if they are.  */
+  { "abs",    { UFLAGS, DOTDEST, SP, VFTREG, C, VFSREG },                   MURES + MUOP11,      VUOP11 (0x1fd), 0, 0, NULL, NULL },
+  { "add",    { UFLAGS, DOTDEST, SP, VFDREG, C, VFSREG, C, VFTREG },        MURES + MUOP6,       VUOP6 (0x28), 0, 0, NULL, NULL },
+  { "addi",   { UFLAGS, DOTDEST, SP, VFDREG, C, VFSREG, C, I },             MURES + MT + MUOP6,  VUOP6 (0x22), 0, 0, NULL, NULL },
+  { "addq",   { UFLAGS, DOTDEST, SP, VFDREG, C, VFSREG, C, Q },             MURES + MT + MUOP6,  VUOP6 (0x20), 0, 0, NULL, NULL },
+  { "add",    { UBC, UFLAGS, DOTDEST, SP, VFDREG, C, VFSREG, C, UBCFTREG }, MURES + VUOP4 (~0),  VUOP4 (0), 0, 0, NULL, NULL },
+  { "adda",   { UFLAGS, DOTDEST, SP, UACCDEST, C, VFSREG, C, VFTREG },      MURES + MUOP11,      VUOP11 (0x2bc), 0, 0, NULL, NULL },
+  { "addai",  { UFLAGS, DOTDEST, SP, UACCDEST, C, VFSREG, C, I },           MURES + MT + MUOP11, VUOP11 (0x23e), 0, 0, NULL, NULL },
+  { "addaq",  { UFLAGS, DOTDEST, SP, UACCDEST, C, VFSREG, C, Q },           MURES + MT + MUOP11, VUOP11 (0x23c), 0, 0, NULL, NULL },
+  { "adda",   { UBC, UFLAGS, DOTDEST, SP, UACCDEST, C, VFSREG, C, UBCFTREG }, MURES + MUOP9,     VUOP9 (0xf), 0, 0, NULL, NULL },
+  { "clip",   { UBC, UFLAGS, DOTDEST, SP, VFSREG, C, UBCFTREG, UW },        MURES + MDEST + MUOP11, VDEST (0xe) + VUOP11 (0x1ff), 0, 0, NULL, NULL  },
+  { "ftoi0",  { UFLAGS, DOTDEST, SP, VFTREG, C, VFSREG },                   MURES + MUOP11,      VUOP11 (0x17c), 0, 0, NULL, NULL  },
+  { "ftoi4",  { UFLAGS, DOTDEST, SP, VFTREG, C, VFSREG },                   MURES + MUOP11,      VUOP11 (0x17d), 0, 0, NULL, NULL  },
+  { "ftoi12", { UFLAGS, DOTDEST, SP, VFTREG, C, VFSREG },                   MURES + MUOP11,      VUOP11 (0x17e), 0, 0, NULL, NULL  },
+  { "ftoi15", { UFLAGS, DOTDEST, SP, VFTREG, C, VFSREG },                   MURES + MUOP11,      VUOP11 (0x17f), 0, 0, NULL, NULL  },
+  { "itof0",  { UFLAGS, DOTDEST, SP, VFTREG, C, VFSREG },                   MURES + MUOP11,      VUOP11 (0x13c), 0, 0, NULL, NULL  },
+  { "itof4",  { UFLAGS, DOTDEST, SP, VFTREG, C, VFSREG },                   MURES + MUOP11,      VUOP11 (0x13d), 0, 0, NULL, NULL  },
+  { "itof12", { UFLAGS, DOTDEST, SP, VFTREG, C, VFSREG },                   MURES + MUOP11,      VUOP11 (0x13e), 0, 0, NULL, NULL  },
+  { "itof15", { UFLAGS, DOTDEST, SP, VFTREG, C, VFSREG },                   MURES + MUOP11,      VUOP11 (0x13f), 0, 0, NULL, NULL  },
+  { "madd",   { UFLAGS, DOTDEST, SP, VFDREG, C, VFSREG, C, VFTREG },        MURES + MUOP6,       VUOP6 (0x29), 0, 0, NULL, NULL  },
+  { "maddi",  { UFLAGS, DOTDEST, SP, VFDREG, C, VFSREG, C, I },             MURES + MT + MUOP6,  VUOP6 (0x23), 0, 0, NULL, NULL  },
+  { "maddq",  { UFLAGS, DOTDEST, SP, VFDREG, C, VFSREG, C, Q },             MURES + MT + MUOP6,  VUOP6 (0x21), 0, 0, NULL, NULL  },
+  { "madd",   { UBC, UFLAGS, DOTDEST, SP, VFDREG, C, VFSREG, C, UBCFTREG }, MURES + MUOP4,       VUOP4 (0x2), 0, 0, NULL, NULL  },
+  { "madda",  { UFLAGS, DOTDEST, SP, UACCDEST, C, VFSREG, C, VFTREG },      MURES + MUOP11,      VUOP11 (0x2bd), 0, 0, NULL, NULL  },
+  { "maddai", { UFLAGS, DOTDEST, SP, UACCDEST, C, VFSREG, C, I },           MURES + MT + MUOP11, VUOP11 (0x23f), 0, 0, NULL, NULL  },
+  { "maddaq", { UFLAGS, DOTDEST, SP, UACCDEST, C, VFSREG, C, Q },           MURES + MT + MUOP11, VUOP11 (0x23d), 0, 0, NULL, NULL  },
+  { "madda",  { UBC, UFLAGS, DOTDEST, SP, UACCDEST, C, VFSREG, C, UBCFTREG }, MURES + MUOP9,     VUOP9 (0x2f), 0, 0, NULL, NULL  },
+  { "max",    { UFLAGS, DOTDEST, SP, VFDREG, C, VFSREG, C, VFTREG },        MURES + MUOP6,       VUOP6 (0x2b), 0, 0, NULL, NULL  },
+  { "maxi",   { UFLAGS, DOTDEST, SP, VFDREG, C, VFSREG, C, I },             MURES + MT + MUOP6,  VUOP6 (0x1d), 0, 0, NULL, NULL  },
+  { "max",    { UBC, UFLAGS, DOTDEST, SP, VFDREG, C, VFSREG, C, UBCFTREG }, MURES + MUOP4,       VUOP4 (0x4), 0, 0, NULL, NULL  },
+  { "mini",   { UFLAGS, DOTDEST, SP, VFDREG, C, VFSREG, C, VFTREG },        MURES + MUOP6,       VUOP6 (0x2f), 0, 0, NULL, NULL  },
+  { "minii",  { UFLAGS, DOTDEST, SP, VFDREG, C, VFSREG, C, I },             MURES + MT + MUOP6,  VUOP6 (0x1f), 0, 0, NULL, NULL  },
+  { "mini",   { UBC, UFLAGS, DOTDEST, SP, VFDREG, C, VFSREG, C, UBCFTREG }, MURES + MUOP4,       VUOP4 (0x5), 0, 0, NULL, NULL  },
+  { "msub",   { UFLAGS, DOTDEST, SP, VFDREG, C, VFSREG, C, VFTREG },        MURES + MUOP6,       VUOP6 (0x2d), 0, 0, NULL, NULL  },
+  { "msubi",  { UFLAGS, DOTDEST, SP, VFDREG, C, VFSREG, C, I },             MURES + MT + MUOP6,  VUOP6 (0x27), 0, 0, NULL, NULL  },
+  { "msubq",  { UFLAGS, DOTDEST, SP, VFDREG, C, VFSREG, C, Q },             MURES + MT + MUOP6,  VUOP6 (0x25), 0, 0, NULL, NULL  },
+  { "msub",   { UBC, UFLAGS, DOTDEST, SP, VFDREG, C, VFSREG, C, UBCFTREG }, MURES + MUOP4,       VUOP4 (0x3), 0, 0, NULL, NULL  },
+  { "msuba",  { UFLAGS, DOTDEST, SP, UACCDEST, C, VFSREG, C, VFTREG },      MURES + MUOP11,      VUOP11 (0x2fd), 0, 0, NULL, NULL  },
+  { "msubai", { UFLAGS, DOTDEST, SP, UACCDEST, C, VFSREG, C, I },           MURES + MT + MUOP11, VUOP11 (0x27f), 0, 0, NULL, NULL  },
+  { "msubaq", { UFLAGS, DOTDEST, SP, UACCDEST, C, VFSREG, C, Q },           MURES + MT + MUOP11, VUOP11 (0x27d), 0, 0, NULL, NULL  },
+  { "msuba",  { UBC, UFLAGS, DOTDEST, SP, UACCDEST, C, VFSREG, C, UBCFTREG }, MURES + MUOP9,     VUOP9 (0x3f), 0, 0, NULL, NULL  },
+  { "mul",    { UFLAGS, DOTDEST, SP, VFDREG, C, VFSREG, C, VFTREG },        MURES + MUOP6,       VUOP6 (0x2a), 0, 0, NULL, NULL  },
+  { "muli",   { UFLAGS, DOTDEST, SP, VFDREG, C, VFSREG, C, I },             MURES + MT + MUOP6,  VUOP6 (0x1e), 0, 0, NULL, NULL  },
+  { "mulq",   { UFLAGS, DOTDEST, SP, VFDREG, C, VFSREG, C, Q },             MURES + MT + MUOP6,  VUOP6 (0x1c), 0, 0, NULL, NULL  },
+  { "mul",    { UBC, UFLAGS, DOTDEST, SP, VFDREG, C, VFSREG, C, UBCFTREG }, MURES + VUOP4 (~0),  VUOP4 (6), 0, 0, NULL, NULL  },
+  { "mula",   { UFLAGS, DOTDEST, SP, UACCDEST, C, VFSREG, C, VFTREG },      MURES + MUOP11,      VUOP11 (0x2be), 0, 0, NULL, NULL  },
+  { "mulai",  { UFLAGS, DOTDEST, SP, UACCDEST, C, VFSREG, C, I },           MURES + MT + MUOP11, VUOP11 (0x1fe), 0, 0, NULL, NULL  },
+  { "mulaq",  { UFLAGS, DOTDEST, SP, UACCDEST, C, VFSREG, C, Q },           MURES + MT + MUOP11, VUOP11 (0x1fc), 0, 0, NULL, NULL  },
+  { "mula",   { UBC, UFLAGS, DOTDEST, SP, UACCDEST, C, VFSREG, C, UBCFTREG }, MURES + MUOP9,     VUOP9 (0x6f), 0, 0, NULL, NULL  },
+  { "nop",    { UFLAGS },                                                   MURES + MDEST + MT + MS + MUOP11, VUOP11 (0x2ff), 0, 0, NULL, NULL  },
+  { "opmula", { UFLAGS, DOTDEST, SP, UACCDEST, C, VFSREG, C, VFTREG, UXYZ }, MURES + MUOP11,     VUOP11 (0x2fe), 0, 0, NULL, NULL  },
+  { "opmsub", { UFLAGS, DOTDEST, SP, VFDREG, C, VFSREG, C, VFTREG, UXYZ },  MURES + MUOP6,       VUOP6 (0x2e), 0, 0, NULL, NULL  },
+  { "sub",    { UFLAGS, DOTDEST, SP, VFDREG, C, VFSREG, C, VFTREG },        MURES + MUOP6,       VUOP6 (0x2c), 0, 0, NULL, NULL  },
+  { "subi",   { UFLAGS, DOTDEST, SP, VFDREG, C, VFSREG, C, I },             MURES + MT + MUOP6,  VUOP6 (0x26), 0, 0, NULL, NULL  },
+  { "subq",   { UFLAGS, DOTDEST, SP, VFDREG, C, VFSREG, C, Q },             MURES + MT + MUOP6,  VUOP6 (0x24), 0, 0, NULL, NULL  },
+  { "sub",    { UBC, UFLAGS, DOTDEST, SP, VFDREG, C, VFSREG, C, UBCFTREG }, MURES + VUOP4 (~0),  VUOP4 (1), 0, 0, NULL, NULL  },
+  { "suba",   { UFLAGS, DOTDEST, SP, UACCDEST, C, VFSREG, C, VFTREG },      MURES + MUOP11,      VUOP11 (0x2fc), 0, 0, NULL, NULL  },
+  { "subai",  { UFLAGS, DOTDEST, SP, UACCDEST, C, VFSREG, C, I },           MURES + MT + MUOP11, VUOP11 (0x27e), 0, 0, NULL, NULL  },
+  { "subaq",  { UFLAGS, DOTDEST, SP, UACCDEST, C, VFSREG, C, Q },           MURES + MT + MUOP11, VUOP11 (0x27c), 0, 0, NULL, NULL  },
+  { "suba",   { UBC, UFLAGS, DOTDEST, SP, UACCDEST, C, VFSREG, C, UBCFTREG }, MURES + MUOP9,     VUOP9 (0x1f), 0, 0, NULL, NULL  }
+};
+const int vu_upper_opcodes_count = sizeof (vu_upper_opcodes) / sizeof (vu_upper_opcodes[0]);
+
+
+/* Lower instruction Value macros.  */
+
+/* 6 bit opcode.  */
+#define VLOP6(x) V ((x), 6, 0)
+/* 7 bit opcode.  */
+#define VLOP7(x) V ((x), 7, 25)
+/* 11 bit opcode.  */
+#define VLOP11(x) V ((x), 11, 0)
+/* 11 bit immediate.  */
+#define VLIMM11(x) V ((x), 11, 0)
+/* FTF field.  */
+#define VLFTF(x) V ((x), 2, 23)
+/* FSF field.  */
+#define VLFSF(x) V ((x), 2, 21)
+/* Upper bit of 12 bit unsigned immediate.  */
+#define VLUIMM12TOP(x) V ((x), 1, 21)
+/* Upper 4 bits of 15 bit unsigned immediate.  */
+#define VLUIMM15TOP(x) VDEST (x)
+
+/* Lower instruction field masks.  */
+#define MLOP6 VLOP6 (~0)
+#define MLOP7 VLOP7 (~0)
+#define MLOP11 VLOP11 (~0)
+#define MLIMM11 VLIMM11 (~0)
+#define MLB24 V (1, 1, 24)
+#define MLUIMM12TOP VLUIMM12TOP (~0)
+/* 12 bit unsigned immediates are split into two parts, 1 bit and 11 bits.
+   The upper 1 bit is part of the `dest' field.  This mask is for the
+   other 3 bits of the dest field.  */
+#define MLUIMM12UNUSED V (7, 3, 22)
+#define MLUIMM15TOP MDEST
+
+struct dvp_opcode vu_lower_opcodes[] =
+{
+  /* Macros appear first, so the disassembler will try them first.  */
+
+  /* There isn't an explicit nop.  Apparently it's "move vf0,vf0".  */
+  { "nop", { 0 }, 0xffffffff, VLOP7 (0x40) + VLIMM11 (0x33c), 0, 0, NULL, NULL },
+
+  /* The rest of these needn't be sorted, but it helps to find them if they are.  */
+  { "b",       { SP, LPCREL11 },                      MLOP7 + MDEST + MT + MS,          VLOP7 (0x20), 0, 0, NULL, NULL },
+  { "bal",     { SP, LITREG, C, LPCREL11 },           MLOP7 + MDEST + MS,               VLOP7 (0x21), 0, 0, NULL, NULL },
+  { "div",     { SP, Q, C, LFSFFSREG, C, LFTFFTREG }, MLOP7 + MLOP11,                   VLOP7 (0x40) + VLOP11 (0x3bc), 0, 0, NULL, NULL },
+  { "eatan",   { SP, P, C, LFSFFSREG },               MLOP7 + VLFTF (~0) + MT + MLOP11, VLOP7 (0x40) + VLOP11 (0x7fd), 0, 0, NULL, NULL },
+  { "eatanxy", { SP, P, C, LFSREG },                  MLOP7 + MDEST + MT + MLOP11,      VLOP7 (0x40) + VDEST (0xc) + VLOP11 (0x77c), 0, 0, NULL, NULL },
+  { "eatanxz", { SP, P, C, LFSREG },                  MLOP7 + MDEST + MT + MLOP11,      VLOP7 (0x40) + VDEST (0xa) + VLOP11 (0x77d), 0, 0, NULL, NULL },
+  { "eexp",    { SP, P, C, LFSFFSREG },               MLOP7 + VLFTF (~0) + MT + MLOP11, VLOP7 (0x40) + VLOP11 (0x7fe), 0, 0, NULL, NULL },
+  { "eleng",   { SP, P, C, LFSREG },                  MLOP7 + MDEST + MT + MLOP11,      VLOP7 (0x40) + VDEST (0xe) + VLOP11 (0x73e), 0, 0, NULL, NULL },
+  { "ercpr",   { SP, P, C, LFSFFSREG },               MLOP7 + VLFTF (~0) + MT + MLOP11, VLOP7 (0x40) + VLOP11 (0x7be), 0, 0, NULL, NULL },
+  { "erleng",  { SP, P, C, LFSREG },                  MLOP7 + MDEST + MT + MLOP11,      VLOP7 (0x40) + VDEST (0xe) + VLOP11 (0x73f), 0, 0, NULL, NULL },
+  { "ersadd",  { SP, P, C, LFSREG },                  MLOP7 + MDEST + MT + MLOP11,      VLOP7 (0x40) + VDEST (0xe) + VLOP11 (0x73d), 0, 0, NULL, NULL },
+  { "ersqrt",  { SP, P, C, LFSFFSREG },               MLOP7 + VLFTF (~0) + MT + MLOP11, VLOP7 (0x40) + VLOP11 (0x7bd), 0, 0, NULL, NULL },
+  { "esadd",   { SP, P, C, LFSREG },                  MLOP7 + MDEST + MT + MLOP11,      VLOP7 (0x40) + VDEST (0xe) + VLOP11 (0x73c), 0, 0, NULL, NULL },
+  { "esin",    { SP, P, C, LFSFFSREG },               MLOP7 + VLFTF (~0) + MT + MLOP11, VLOP7 (0x40) + VLOP11 (0x7fc), 0, 0, NULL, NULL },
+  { "esqrt",   { SP, P, C, LFSFFSREG },               MLOP7 + VLFTF (~0) + MT + MLOP11, VLOP7 (0x40) + VLOP11 (0x7bc), 0, 0, NULL, NULL },
+  { "esum",    { SP, P, C, LFSREG },                  MLOP7 + MDEST + MT + MLOP11,      VLOP7 (0x40) + VDEST (0xf) + VLOP11 (0x77e), 0, 0, NULL, NULL },
+  { "fcand",   { SP, LVI01, C, LUIMM24 },             MLOP7 + MLB24,                    VLOP7 (0x12), 0, 0, NULL, NULL },
+  { "fceq",    { SP, LVI01, C, LUIMM24 },             MLOP7 + MLB24,                    VLOP7 (0x10), 0, 0, NULL, NULL },
+  { "fcget",   { SP, LITREG },                        MLOP7 + MDEST + MS + MLIMM11,     VLOP7 (0x1c), 0, 0, NULL, NULL },
+  { "fcor",    { SP, LVI01, C, LUIMM24 },             MLOP7 + MLB24,                    VLOP7 (0x13), 0, 0, NULL, NULL },
+  { "fcset",   { SP, LUIMM24 },                       MLOP7 + MLB24,                    VLOP7 (0x11), 0, 0, NULL, NULL },
+  { "fmand",   { SP, LITREG, C, LISREG },             MLOP7 + MDEST + MLIMM11,          VLOP7 (0x1a), 0, 0, NULL, NULL },
+  { "fmeq",    { SP, LITREG, C, LISREG },             MLOP7 + MDEST + MLIMM11,          VLOP7 (0x18), 0, 0, NULL, NULL },
+  { "fmor",    { SP, LITREG, C, LISREG },             MLOP7 + MDEST + MLIMM11,          VLOP7 (0x1b), 0, 0, NULL, NULL },
+  { "fsand",   { SP, LITREG, C, LUIMM12 },            MLOP7 + MLUIMM12UNUSED + MS,      VLOP7 (0x16), 0, 0, NULL, NULL },
+  { "fseq",    { SP, LITREG, C, LUIMM12 },            MLOP7 + MLUIMM12UNUSED + MS,      VLOP7 (0x14), 0, 0, NULL, NULL },
+  { "fsor",    { SP, LITREG, C, LUIMM12 },            MLOP7 + MLUIMM12UNUSED + MS,      VLOP7 (0x17), 0, 0, NULL, NULL },
+  { "fsset",   { SP, LUIMM12UP6 },                    MLOP7 + MLUIMM12UNUSED + V (~0, 6, 0) + MS + MT, VLOP7 (0x15), 0, 0, NULL, NULL },
+  { "iadd",    { SP, LIDREG, C, LISREG, C, LITREG },  MLOP7 + MDEST + MLOP6,            VLOP7 (0x40) + VLOP6 (0x30), 0, 0, NULL, NULL },
+  { "iaddi",   { SP, LITREG, C, LISREG, C, LIMM5 },   MLOP7 + MDEST + MLOP6,            VLOP7 (0x40) + VLOP6 (0x32), 0, 0, NULL, NULL },
+  { "iaddiu",  { SP, LITREG, C, LISREG, C, LUIMM15 }, MLOP7,                            VLOP7 (0x08), 0, 0, NULL, NULL },
+  { "iand",    { SP, LIDREG, C, LISREG, C, LITREG },  MLOP7 + MDEST + MLOP6,            VLOP7 (0x40) + VLOP6 (0x34), 0, 0, NULL, NULL },
+  { "ibeq",    { SP, LITREG, C, LISREG, C, LPCREL11 }, MLOP7 + MDEST,                   VLOP7 (0x28), 0, 0, NULL, NULL },
+  { "ibgez",   { SP, LISREG, C, LPCREL11 },           MLOP7 + MDEST + MT,               VLOP7 (0x2f), 0, 0, NULL, NULL },
+  { "ibgtz",   { SP, LISREG, C, LPCREL11 },           MLOP7 + MDEST + MT,               VLOP7 (0x2d), 0, 0, NULL, NULL },
+  { "iblez",   { SP, LISREG, C, LPCREL11 },           MLOP7 + MDEST + MT,               VLOP7 (0x2e), 0, 0, NULL, NULL },
+  { "ibltz",   { SP, LISREG, C, LPCREL11 },           MLOP7 + MDEST + MT,               VLOP7 (0x2c), 0, 0, NULL, NULL },
+  { "ibne",    { SP, LITREG, C, LISREG, C, LPCREL11 }, MLOP7 + MDEST,                   VLOP7 (0x29), 0, 0, NULL, NULL },
+  { "ilw",     { LDOTDEST1, SP, LITREG, C, LIMM11, '(', LISREG, ')', LDEST1 }, MLOP7,   VLOP7 (0x04), 0, 0, NULL, NULL },
+  { "ilwr",    { LDOTDEST1, SP, LITREG, C, '(', LISREG, ')', LDEST1 }, MLOP7 + MLIMM11, VLOP7 (0x40) + VLIMM11 (0x3fe), 0, 0, NULL, NULL },
+  { "ior",     { SP, LIDREG, C, LISREG, C, LITREG },  MLOP7 + MDEST + MLOP6,            VLOP7 (0x40) + VLOP6 (0x35), 0, 0, NULL, NULL },
+  { "isub",    { SP, LIDREG, C, LISREG, C, LITREG },  MLOP7 + MDEST + MLOP6,            VLOP7 (0x40) + VLOP6 (0x31), 0, 0, NULL, NULL },
+  { "isubiu",  { SP, LITREG, C, LISREG, C, LUIMM15 }, MLOP7,                            VLOP7 (0x09), 0, 0, NULL, NULL },
+  { "isw",     { DOTDEST, SP, LITREG, C, LIMM11, '(', LISREG, ')', LDEST1 }, MLOP7,     VLOP7 (0x05), 0, 0, NULL, NULL },
+  { "iswr",    { DOTDEST, SP, LITREG, C, '(', LISREG, ')', LDEST1 }, MLOP7 + MLIMM11,   VLOP7 (0x40) + VLIMM11 (0x3ff), 0, 0, NULL, NULL },
+  { "jalr",    { SP, LITREG, C, LISREG },             MLOP7 + MDEST + MLIMM11,          VLOP7 (0x25), 0, 0, NULL, NULL },
+  { "jr",      { SP, LISREG },                        MLOP7 + MDEST + MT + MLIMM11,     VLOP7 (0x24), 0, 0, NULL, NULL },
+  { "loi",     { SP, LFIMM32 },                       0,                                0, 0, 0, NULL, NULL },
+  { "lq",      { DOTDEST, SP, VFTREG, C, LIMM11, '(', LISREG, ')' }, MLOP7,             VLOP7 (0x00), 0, 0, NULL, NULL },
+  { "lqd",     { DOTDEST, SP, VFTREG, C, '(', '-', '-', LISREG, ')' }, MLOP7 + MLIMM11, VLOP7 (0x40) + VLIMM11 (0x37e), 0, 0, NULL, NULL },
+  { "lqi",     { DOTDEST, SP, VFTREG, C, '(', LISREG, '+', '+', ')' }, MLOP7 + MLIMM11, VLOP7 (0x40) + VLIMM11 (0x37c), 0, 0, NULL, NULL },
+  /* Only a single VF reg is allowed here.  We can use VFTREG because LDOTDEST1
+     handles verifying only a single choice of xyzw is present.  */
+  { "mfir",    { DOTDEST, SP, VFTREG, C, LISREG },    MLOP7 + MLIMM11,                  VLOP7 (0x40) + VLIMM11 (0x3fd), 0, 0, NULL, NULL },
+  { "mfp",     { DOTDEST, SP, VFTREG, C, P },         MLOP7 + MS + MLIMM11,             VLOP7 (0x40) + VLIMM11 (0x67c), 0, 0, NULL, NULL },
+  { "move",    { DOTDEST, SP, VFTREG, C, VFSREG },    MLOP7 + MLIMM11,                  VLOP7 (0x40) + VLIMM11 (0x33c), 0, 0, NULL, NULL },
+  { "mr32",    { DOTDEST, SP, VFTREG, C, VFSREG },    MLOP7 + MLIMM11,                  VLOP7 (0x40) + VLIMM11 (0x33d), 0, 0, NULL, NULL },
+  { "mtir",    { SP, LITREG, C, LFSFFSREG },          MLOP7 + VLFTF (~0) + MLOP11,      VLOP7 (0x40) + VLOP11 (0x3fc), 0, 0, NULL, NULL },
+  { "rget",    { DOTDEST, SP, VFTREG, C, R },         MLOP7 + MS + MLIMM11,             VLOP7 (0x40) + VLIMM11 (0x43d), 0, 0, NULL, NULL },
+  { "rinit",   { SP, R, C, LFSFFSREG },               MLOP7 + VLFTF (~0) + MT + MLIMM11, VLOP7 (0x40) + VLIMM11 (0x43e), 0, 0, NULL, NULL },
+  { "rnext",   { DOTDEST, SP, VFTREG, C, R },         MLOP7 + MS + MLIMM11,             VLOP7 (0x40) + VLIMM11 (0x43c), 0, 0, NULL, NULL },
+  { "rsqrt",   { SP, Q, C, LFSFFSREG, C, LFTFFTREG }, MLOP7 + MLIMM11,                  VLOP7 (0x40) + VLIMM11 (0x3be), 0, 0, NULL, NULL },
+  { "rxor",    { SP, R, C, LFSFFSREG },               MLOP7 + VLFTF (~0) + MT + MLIMM11, VLOP7 (0x40) + VLIMM11 (0x43f), 0, 0, NULL, NULL },
+  { "sq",      { DOTDEST, SP, VFSREG, C, LIMM11, '(', LITREG, ')' }, MLOP7,             VLOP7 (0x01), 0, 0, NULL, NULL },
+  { "sqd",     { DOTDEST, SP, VFSREG, C, '(', '-', '-', LITREG, ')' }, MLOP7 + MLIMM11, VLOP7 (0x40) + VLIMM11 (0x37f), 0, 0, NULL, NULL },
+  { "sqi",     { DOTDEST, SP, VFSREG, C, '(', LITREG, '+', '+', ')' }, MLOP7 + MLIMM11, VLOP7 (0x40) + VLIMM11 (0x37d), 0, 0, NULL, NULL },
+  { "sqrt",    { SP, Q, C, LFTFFTREG },               MLOP7 + VLFSF (~0) + MS + MLIMM11, VLOP7 (0x40) + VLIMM11 (0x3bd), 0, 0, NULL, NULL },
+  { "waitp",   { 0 },                                 0xffffffff,                       VLOP7 (0x40) + VLIMM11 (0x7bf), 0, 0, NULL, NULL },
+  { "waitq",   { 0 },                                 0xffffffff,                       VLOP7 (0x40) + VLIMM11 (0x3bf), 0, 0, NULL, NULL },
+  { "xgkick",  { SP, LISREG },                        MLOP7 + MDEST + MT + MLIMM11,     VLOP7 (0x40) + VLIMM11 (0x6fc), 0, 0, NULL, NULL },
+  { "xitop",   { SP, LITREG },                        MLOP7 + MDEST + MS + MLIMM11,     VLOP7 (0x40) + VLIMM11 (0x6bd), 0, 0, NULL, NULL },
+  { "xtop",    { SP, LITREG },                        MLOP7 + MDEST + MS + MLIMM11,     VLOP7 (0x40) + VLIMM11 (0x6bc), 0, 0, NULL, NULL }
+};
+const int vu_lower_opcodes_count = sizeof (vu_lower_opcodes) / sizeof (vu_lower_opcodes[0]);
+
+
+/* Value of DEST in use.
+   Each of the registers must specify the same value as the opcode.  */
+static int state_vu_mnemonic_dest;
+
+/* Value of BC to use.
+   The register specified for the ftreg must match the broadcast register
+   specified in the opcode.  */
+static int state_vu_mnemonic_bc;
+
+
+#define INVALID_DEST 		_("invalid `dest'")
+#define MISSING_DEST 		_("missing `dest'")
+#define MISSING_DOT  		_("missing `.'")
+#define UNKNOWN_REGISTER 	_("unknown register")
+#define INVALID_REGISTER_NUMBER _("invalid register number")
+
+/* Multiple destination choice support.
+   The "dest" string selects any combination of x,y,z,w.
+   [The letters are ordered that way to follow the manual's style.]  */
+
+/* Utility to parse a `dest' spec.
+   Return the found value or zero if not present.
+   *PSTR is set to the character that terminated the parsing.
+   It is up to the caller to do any error checking.  */
+
+static long
+u_parse_dest (pstr)
+     char **pstr;
+{
+  long dest = 0;
+
+  while (**pstr)
+    {
+      switch (**pstr)
+	{
+	case 'x' : case 'X' : dest |= VU_DEST_X; break;
+	case 'y' : case 'Y' : dest |= VU_DEST_Y; break;
+	case 'z' : case 'Z' : dest |= VU_DEST_Z; break;
+	case 'w' : case 'W' : dest |= VU_DEST_W; break;
+	default : return dest;
+	}
+      ++*pstr;
+    }
+
+  return dest;
+}
+
+static long
+parse_dotdest (opcode, operand, mods, pstr, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     char **pstr;
+     const char **errmsg;
+{
+  long dest;
+
+  /* If we're at a space, the dest isn't present so use the default: xyzw.  */
+  if (**pstr == ' ')
+    return VU_DEST_X | VU_DEST_Y | VU_DEST_Z | VU_DEST_W;
+
+  if (**pstr != '.' && **pstr != '/')
+    {
+      *errmsg = MISSING_DOT;
+      return 0;
+    }
+
+  ++*pstr;
+  dest = u_parse_dest (pstr);
+  if (dest == 0 || isalnum ((unsigned char) **pstr))
+    {
+      *errmsg = INVALID_DEST;
+      return 0;
+    }
+
+  return dest;
+}
+
+/* Parse a `dest' spec where only a single letter is allowed,
+   but the encoding handles all four.  */
+
+static long
+parse_dotdest1 (opcode, operand, mods, pstr, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     char **pstr;
+     const char **errmsg;
+{
+  char c;
+  long dest;
+
+  if (**pstr != '.' && **pstr != '/')
+    {
+      *errmsg = MISSING_DOT;
+      return 0;
+    }
+
+  ++*pstr;
+  switch (**pstr)
+    {
+    case 'x' : case 'X' : dest = VU_DEST_X; break;
+    case 'y' : case 'Y' : dest = VU_DEST_Y; break;
+    case 'z' : case 'Z' : dest = VU_DEST_Z; break;
+    case 'w' : case 'W' : dest = VU_DEST_W; break;
+    default : *errmsg = INVALID_DEST; return 0;
+    }
+  ++*pstr;
+  c = tolower (**pstr);
+  if (c == 'x' || c == 'y' || c == 'z' || c == 'w')
+    {
+      *errmsg = _("only one of x,y,z,w can be specified");
+      return 0;
+    }
+  if (isalnum ((unsigned char) **pstr))
+    {
+      *errmsg = INVALID_DEST;
+      return 0;
+    }
+
+  return dest;
+}
+
+/* Parse a `dest' spec with no leading '.', where only a single letter is
+   allowed, but the encoding handles all four.  The value, if specified,
+   must match that recorded in `dest'.  */
+
+static long
+parse_dest1 (opcode, operand, mods, pstr, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     char **pstr;
+     const char **errmsg;
+{
+  long dest;
+
+  dest = u_parse_dest (pstr);
+  if (dest == 0)
+    ; /* not specified, nothing to do */
+  else if (dest != VU_DEST_X
+      && dest != VU_DEST_Y
+      && dest != VU_DEST_Z
+      && dest != VU_DEST_W)
+    {
+      *errmsg = _("expecting one of x,y,z,w");
+      return 0;
+    }
+  else if (dest != state_vu_mnemonic_dest)
+    {
+      *errmsg = _("`dest' suffix does not match instruction `dest'");
+      return 0;
+    }
+
+  return dest;
+}
+
+static void
+insert_dotdest (opcode, operand, mods, insn, value, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand;
+     int mods __attribute__((unused));
+     DVP_INSN *insn;
+     long value;
+     const char **errmsg __attribute__((unused));
+{
+  /* Record the DEST value in use so the register parser can use it.  */
+  state_vu_mnemonic_dest = value;
+  *insn |= value << operand->shift;
+}
+
+static long
+extract_dotdest (opcode, operand, mods, insn, pinvalid)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand;
+     int mods __attribute__((unused));
+     DVP_INSN *insn;
+     int *pinvalid __attribute__((unused));
+{
+  /* Record the DEST value in use so the register printer can use it.  */
+  state_vu_mnemonic_dest = (*insn >> operand->shift) & ((1 << operand->bits) - 1);
+  return state_vu_mnemonic_dest;
+}
+
+/* Utility to print a multiple dest spec.  */
+
+static void
+u_print_dest (info, insn, value)
+     disassemble_info *info;
+     DVP_INSN *insn __attribute__((unused));
+     long value;
+{
+  if (value & VU_DEST_X)
+    (*info->fprintf_func) (info->stream, "x");
+  if (value & VU_DEST_Y)
+    (*info->fprintf_func) (info->stream, "y");
+  if (value & VU_DEST_Z)
+    (*info->fprintf_func) (info->stream, "z");
+  if (value & VU_DEST_W)
+    (*info->fprintf_func) (info->stream, "w");
+}
+
+static void
+print_dotdest (opcode, operand, mods, insn, info, value)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn;
+     disassemble_info *info;
+     long value;
+{
+  (*info->fprintf_func) (info->stream, ".");
+  u_print_dest (info, insn, value);
+}
+
+static void
+print_dest1 (opcode, operand, mods, insn, info, value)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn;
+     disassemble_info *info;
+     long value __attribute__((unused));
+{
+  u_print_dest (info, insn, state_vu_mnemonic_dest);
+}
+
+/* Utilities for single destination choice handling.  */
+
+/* Parse a single dest spec.
+   Return one of VU_SDEST_[XYZW] or -1 if not present.  */
+
+static long
+u_parse_sdest (pstr, errmsg)
+     char **pstr;
+     const char **errmsg;
+{
+  char c;
+  long dest = 0;
+
+  switch (**pstr)
+    {
+    case 'x' : case 'X' : dest = VU_SDEST_X; break;
+    case 'y' : case 'Y' : dest = VU_SDEST_Y; break;
+    case 'z' : case 'Z' : dest = VU_SDEST_Z; break;
+    case 'w' : case 'W' : dest = VU_SDEST_W; break;
+    default : return -1;
+    }
+  ++*pstr;
+  c = tolower (**pstr);
+  if (c == 'x' || c == 'y' || c == 'z' || c == 'w')
+    {
+      *errmsg = _("only one of x,y,z,w can be specified");
+      return 0;
+    }
+  if (isalnum ((unsigned char) **pstr))
+    {
+      *errmsg = INVALID_DEST;
+      return 0;
+    }
+
+  return dest;
+}
+
+static void
+print_sdest (opcode, operand, mods, insn, info, value)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn __attribute__((unused));
+     disassemble_info *info;
+     long value;
+{
+  char c;
+
+  switch (value)
+    {
+    case VU_SDEST_X : c = 'x'; break;
+    case VU_SDEST_Y : c = 'y'; break;
+    case VU_SDEST_Z : c = 'z'; break;
+    case VU_SDEST_W : c = 'w'; break;
+    default: abort (); return;
+    }
+
+  (*info->fprintf_func) (info->stream, "%c", c);
+}
+
+/* The upper word flags bits.  */
+
+static long
+parse_uflags (opcode, operand, mods, pstr, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     char **pstr;
+     const char **errmsg;
+{
+  long value = 0;
+  char *str = *pstr;
+
+  if (*str != '[')
+    return 0;
+  ++str;
+  while (*str && *str != ']')
+    {
+      switch (tolower (*str))
+	{
+	case 'i' : value |= VU_FLAG_I; break;
+	case 'e' : value |= VU_FLAG_E; break;
+	case 'm' : value |= VU_FLAG_M; break;
+	case 'd' : value |= VU_FLAG_D; break;
+	case 't' : value |= VU_FLAG_T; break;
+	default : *errmsg = _("invalid flag character present"); return 0;
+	}
+      ++str;
+    }
+  if (*str != ']')
+    {
+      *errmsg = _("syntax error in flag spec");
+      return 0;
+    }
+  *pstr = str + 1;
+  return value;
+}
+
+static void
+print_uflags (opcode, operand, mods, insn, info, value)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn __attribute__((unused));
+     disassemble_info *info;
+     long value;
+{
+  if (value)
+    {
+      (*info->fprintf_func) (info->stream, "[");
+      if (value & VU_FLAG_I)
+	(*info->fprintf_func) (info->stream, "i");
+      if (value & VU_FLAG_E)
+	(*info->fprintf_func) (info->stream, "e");
+      if (value & VU_FLAG_M)
+	(*info->fprintf_func) (info->stream, "m");
+      if (value & VU_FLAG_D)
+	(*info->fprintf_func) (info->stream, "d");
+      if (value & VU_FLAG_T)
+	(*info->fprintf_func) (info->stream, "t");
+      (*info->fprintf_func) (info->stream, "]");
+    }
+}
+
+/* Broadcase field.  */
+
+static long
+parse_bc (opcode, operand, mods, pstr, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     char **pstr;
+     const char **errmsg;
+{
+  long value = u_parse_sdest (pstr, errmsg);
+
+  if (*errmsg)
+    return 0;
+  if (value == -1)
+    {
+      *errmsg = MISSING_DEST;
+      return 0;
+    }
+  if (isalnum ((unsigned char) **pstr))
+    {
+      *errmsg = INVALID_DEST;
+      return 0;
+    }
+  /* Save value for later verification in register parsing.  */
+  state_vu_mnemonic_bc = value;
+  return value;
+}
+
+/* During the extraction process, save the bc field for use in
+   printing the bc register.  */
+
+static long
+extract_bc (opcode, operand, mods, insn, pinvalid)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn;
+     int *pinvalid __attribute__((unused));
+{
+  state_vu_mnemonic_bc = *insn & 3;
+  return state_vu_mnemonic_bc;
+}
+
+static long
+parse_vfreg (opcode, operand, mods, pstr, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     char **pstr;
+     const char **errmsg;
+{
+  char *str = *pstr;
+  char *start;
+  long reg;
+  int reg_dest;
+
+  if (tolower (str[0]) != 'v'
+      || tolower (str[1]) != 'f')
+    {
+      *errmsg = UNKNOWN_REGISTER;
+      return 0;
+    }
+
+  start = str = str + 2;
+  reg = strtol (start, &str, 10);
+  if (reg < 0 || reg > 31)
+    {
+      *errmsg = INVALID_REGISTER_NUMBER;
+      return 0;
+    }
+  reg_dest = u_parse_dest (&str);
+  if (isalnum ((unsigned char) *str))
+    {
+      *errmsg = INVALID_DEST;
+      return 0;
+    }
+  if (reg_dest == 0)
+    ; /* not specified, nothing to do */
+  else if (reg_dest != state_vu_mnemonic_dest)
+    {
+      *errmsg = _("register `dest' does not match instruction `dest'");
+      return 0;
+    }
+  *pstr = str;
+  return reg;
+}
+
+static void
+print_vfreg (opcode, operand, mods, insn, info, value)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     disassemble_info *info;
+     DVP_INSN *insn;
+     long value;
+{
+  (*info->fprintf_func) (info->stream, "vf%02ld", value);
+  u_print_dest (info, insn, state_vu_mnemonic_dest);
+}
+
+/* FT register in broadcast case.  */
+
+static long
+parse_bcftreg (opcode, operand, mods, pstr, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     char **pstr;
+     const char **errmsg;
+{
+  char *str = *pstr;
+  char *start;
+  long reg;
+  int reg_bc;
+
+  if (tolower (str[0]) != 'v'
+      || tolower (str[1]) != 'f')
+    {
+      *errmsg = UNKNOWN_REGISTER;
+      return 0;
+    }
+
+  start = str = str + 2;
+  reg = strtol (start, &str, 10);
+  if (reg < 0 || reg > 31)
+    {
+      *errmsg = _("invalid register number");
+      return 0;
+    }
+  reg_bc = u_parse_sdest (&str, errmsg);
+  if (*errmsg)
+    return 0;
+  if (reg_bc == -1)
+    ; /* not specified, nothing to do */
+  else if (reg_bc != state_vu_mnemonic_bc)
+    {
+      *errmsg = _("register `bc' does not match instruction `bc'");
+      return 0;
+    }
+  *pstr = str;
+  return reg;
+}
+
+static void
+print_bcftreg (opcode, operand, mods, insn, info, value)
+     const dvp_opcode *opcode;
+     const dvp_operand *operand;
+     int mods;
+     DVP_INSN *insn;
+     disassemble_info *info;
+     long value;
+{
+  (*info->fprintf_func) (info->stream, "vf%02ld", value);
+  /* The assembler syntax has been modified to not require the dest spec
+     on the register.  Unlike the normal dest spec, for bc we print the
+     letter because it makes the output more readable without having to
+     remember which register is the bc one.  */
+  print_sdest (opcode, operand, mods, insn, info, state_vu_mnemonic_bc);
+}
+
+/* ACC handling.  */
+
+static long
+parse_accdest (opcode, operand, mods, pstr, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     char **pstr;
+     const char **errmsg;
+{
+  char *str = *pstr;
+  long acc_dest = 0;
+
+  if (strncasecmp (str, "acc", 3) != 0)
+    {
+      *errmsg = _("expecting `acc'");
+      return 0;
+    }
+  str += 3;
+  acc_dest = u_parse_dest (&str);
+  if (isalnum ((unsigned char) *str))
+    {
+      *errmsg = INVALID_DEST;
+      return 0;
+    }
+  if (acc_dest == 0)
+    ; /* not specified, nothing to do */
+  else if (acc_dest != state_vu_mnemonic_dest)
+    {
+      *errmsg = _("acc `dest' does not match instruction `dest'");
+      return 0;
+    }
+  *pstr = str;
+  /* Value isn't used, but we must return something.  */
+  return 0;
+}
+
+static void
+print_accdest (opcode, operand, mods, insn, info, value)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     disassemble_info *info;
+     DVP_INSN *insn;
+     long value __attribute__((unused));
+{
+  (*info->fprintf_func) (info->stream, "acc");
+  u_print_dest (info, insn, state_vu_mnemonic_dest);
+}
+
+/* XYZ operand handling.
+   This simplifies the opmula,opmsub entries by keeping them equivalent to
+   the others.  */
+
+static void
+insert_xyz (opcode, operand, mods, insn, value, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn __attribute__((unused));
+     long value __attribute__((unused));
+     const char **errmsg;
+{
+  if (state_vu_mnemonic_dest != (VU_DEST_X | VU_DEST_Y | VU_DEST_Z))
+    *errmsg = _("expecting `xyz' for `dest' value");
+}
+
+
+/* W operand handling.
+   This simplifies the clip entry. */
+
+static void
+insert_w (opcode, operand, mods, insn, value, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn __attribute__((unused));
+     long value __attribute__((unused));
+     const char **errmsg;
+{
+  if (state_vu_mnemonic_bc != VU_SDEST_W)
+    *errmsg = _("expecting `w' for `bc' value");
+}
+
+
+/* F[ST] register using selector in F[ST]F field.
+   Internally, the value is encoded in 7 bits: the 2 bit xyzw indicator
+   followed by the 5 bit register number.  */
+
+static long
+parse_ffstreg (opcode, operand, mods, pstr, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     char **pstr;
+     const char **errmsg;
+{
+  char *str = *pstr;
+  char *start;
+  int reg, xyzw;
+
+  if (tolower (str[0]) != 'v'
+      || tolower (str[1]) != 'f')
+    {
+      *errmsg = UNKNOWN_REGISTER;
+      return 0;
+    }
+
+  start = str = str + 2;
+  reg = strtol (start, &str, 10);
+  if (reg < 0 || reg > 31)
+    {
+      *errmsg = _("invalid register number");
+      return 0;
+    }
+  xyzw = u_parse_sdest (&str, errmsg);
+  if (*errmsg)
+    return 0;
+  if (xyzw == -1)
+    {
+      *errmsg = MISSING_DEST;
+      return 0;
+    }
+  if (isalnum ((unsigned char) *str))
+    {
+      *errmsg = INVALID_DEST;
+      return 0;
+    }
+  *pstr = str;
+  return reg | (xyzw << 5);
+}
+
+static void
+print_ffstreg (opcode, operand, mods, insn, info, value)
+     const dvp_opcode *opcode;
+     const dvp_operand *operand;
+     int mods;
+     DVP_INSN *insn;
+     disassemble_info *info;
+     long value;
+{
+  (*info->fprintf_func) (info->stream, "vf%02ld", value & VU_MASK_REG);
+  print_sdest (opcode, operand, mods, insn, info, (value >> 5) & 3);
+}
+
+static void
+insert_ffstreg (opcode, operand, mods, insn, value, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand;
+     int mods __attribute__((unused));
+     DVP_INSN *insn;
+     long value;
+     const char **errmsg __attribute__((unused));
+{
+  if (operand->shift == VU_SHIFT_SREG)
+    *insn |= VLFSF (value >> 5) | VS (value);
+  else
+    *insn |= VLFTF (value >> 5) | VT (value);
+}
+
+static long
+extract_ffstreg (opcode, operand, mods, insn, pinvalid)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand;
+     int mods __attribute__((unused));
+     DVP_INSN *insn;
+     int *pinvalid __attribute__((unused));
+{
+  if (operand->shift == VU_SHIFT_SREG)
+    return (((*insn & VLFSF (~0)) >> 21) << 5) | (((*insn) & MS) >> VU_SHIFT_SREG);
+  else
+    return (((*insn & VLFTF (~0)) >> 21) << 5) | (((*insn) & MS) >> VU_SHIFT_TREG);
+}
+
+/* F register.  */
+
+static long
+parse_freg (opcode, operand, mods, pstr, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     char **pstr;
+     const char **errmsg;
+{
+  char *str = *pstr;
+  char *start;
+  long reg;
+
+  if (tolower (str[0]) != 'v'
+      || tolower (str[1]) != 'f')
+    {
+      *errmsg = UNKNOWN_REGISTER;
+      return 0;
+    }
+
+  start = str = str + 2;
+  reg = strtol (start, &str, 10);
+  if (reg < 0 || reg > 31)
+    {
+      *errmsg = INVALID_REGISTER_NUMBER;
+      return 0;
+    }
+  *pstr = str;
+  return reg;
+}
+
+static void
+print_freg (opcode, operand, mods, insn, info, value)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn __attribute__((unused));
+     disassemble_info *info;
+     long value;
+{
+  (*info->fprintf_func) (info->stream, "vf%02ld", value);
+}
+
+/* I register.  */
+
+static long
+parse_ireg (opcode, operand, mods, pstr, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     char **pstr;
+     const char **errmsg;
+{
+  char *str = *pstr;
+  char *start;
+  long reg;
+
+  if (tolower (str[0]) != 'v'
+      || tolower (str[1]) != 'i')
+    {
+      *errmsg = UNKNOWN_REGISTER;
+      return 0;
+    }
+
+  start = str = str + 2;
+  reg = strtol (start, &str, 10);
+  if (reg < 0 || reg > 31)
+    {
+      *errmsg = INVALID_REGISTER_NUMBER;
+      return 0;
+    }
+  *pstr = str;
+  return reg;
+}
+
+static void
+print_ireg (opcode, operand, mods, insn, info, value)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn __attribute__((unused));
+     disassemble_info *info;
+     long value;
+{
+  (*info->fprintf_func) (info->stream, "vi%02ld", value);
+}
+
+/* VI01 register.  */
+
+static long
+parse_vi01 (opcode, operand, mods, pstr, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     char **pstr;
+     const char **errmsg;
+{
+  char *str = *pstr;
+  char *start;
+  long reg;
+
+  if (tolower (str[0]) != 'v'
+      || tolower (str[1]) != 'i')
+    {
+      *errmsg = UNKNOWN_REGISTER;
+      return 0;
+    }
+
+  start = str = str + 2;
+  reg = strtol (start, &str, 10);
+  if (reg != 1)
+    {
+      *errmsg = _("vi01 required here");
+      return 0;
+    }
+  *pstr = str;
+  return reg;
+}
+
+static void
+print_vi01 (opcode, operand, mods, insn, info, value)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn __attribute__((unused));
+     disassemble_info *info;
+     long value __attribute__((unused));
+{
+  (*info->fprintf_func) (info->stream, "vi01");
+}
+
+/* Lower instruction 12 bit unsigned immediate.  */
+
+static void
+insert_luimm12 (opcode, operand, mods, insn, value, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn;
+     long value;
+     const char **errmsg __attribute__((unused));
+{
+  *insn |= VLUIMM12TOP ((value & (1 << 11)) != 0) | VLIMM11 (value);
+}
+
+static long
+extract_luimm12 (opcode, operand, mods, insn, pinvalid)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn;
+     int *pinvalid __attribute__((unused));
+{
+  return (((*insn & MLUIMM12TOP) != 0) << 11) | VLIMM11 (*insn);
+}
+
+/* Lower instruction 12 bit unsigned immediate, upper 6 bits.  */
+
+static void
+insert_luimm12up6 (opcode, operand, mods, insn, value, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn;
+     long value;
+     const char **errmsg __attribute__((unused));
+{
+  *insn |= VLUIMM12TOP ((value & (1 << 11)) != 0) | (value & 0x7c0);
+}
+
+/* Lower instruction 15 bit unsigned immediate.  */
+
+static void
+insert_luimm15 (opcode, operand, mods, insn, value, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn;
+     long value;
+     const char **errmsg __attribute__((unused));
+{
+  *insn |= VLUIMM15TOP (value >> 11) | VLIMM11 (value);
+}
+
+static long
+extract_luimm15 (opcode, operand, mods, insn, pinvalid)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn;
+     int *pinvalid __attribute__((unused));
+{
+  return (((*insn & MLUIMM15TOP) >> 21) << 11) | VLIMM11 (*insn);
+}
+
+
+/* VIF support.  */
+
+PARSE_FN (vif_ibit);
+PRINT_FN (vif_ibit);
+
+INSERT_FN (vif_wlcl);
+EXTRACT_FN (vif_wlcl);
+
+PARSE_FN (vif_mode);
+PRINT_FN (vif_mode);
+
+PARSE_FN (vif_ability);
+PRINT_FN (vif_ability);
+
+PARSE_FN (vif_mpgloc);
+INSERT_FN (vif_mpgloc);
+
+PARSE_FN (vif_datalen_special);
+INSERT_FN (vif_datalen);
+EXTRACT_FN (vif_datalen);
+
+PARSE_FN (vif_imrubits);
+INSERT_FN (vif_imrubits);
+EXTRACT_FN (vif_imrubits);
+PRINT_FN (vif_imrubits);
+
+PARSE_FN (vif_unpacktype);
+PRINT_FN (vif_unpacktype);
+
+const dvp_operand vif_operands[] =
+{
+  /* place holder (??? not sure if needed) */
+#define VIF_UNUSED 128
+  { 0 },
+
+  /* The I bit.  */
+#define VIF_IBIT (VIF_UNUSED + 1)
+  { 1, 31, 0, DVP_OPERAND_SUFFIX, parse_vif_ibit, 0, 0, print_vif_ibit },
+
+  /* WL value, an 8 bit unsigned immediate, stored in upper 8 bits of
+     immed field.  */
+#define VIF_WL (VIF_IBIT + 1)
+  { 8, 8, 0, 0, 0, insert_vif_wlcl, extract_vif_wlcl, 0 },
+
+  /* CL value, an 8 bit unsigned immediate, stored in lower 8 bits of
+     immed field.  */
+#define VIF_CL (VIF_WL + 1)
+  { 8, 0, 0, 0, 0, insert_vif_wlcl, extract_vif_wlcl, 0 },
+
+  /* An 16 bit unsigned immediate, stored in lower 8 bits of immed field.  */
+#define VIF_UIMM16 (VIF_CL + 1)
+  { 16, 0, 0, 0, 0, 0, 0, 0 },
+
+  /* The mode operand of `stmod'.  */
+#define VIF_MODE (VIF_UIMM16 + 1)
+  { 2, 0, 0, 0, parse_vif_mode, 0, 0, print_vif_mode },
+
+  /* The ability operand of `mskpath3'.  */
+#define VIF_ABILITY (VIF_MODE + 1)
+  { 1, 15, 0, 0, parse_vif_ability, 0, 0, print_vif_ability },
+
+  /* A VU address.  */
+#define VIF_VUADDR (VIF_ABILITY + 1)
+  { 16, 0, 0, 0, 0, 0, 0, 0 },
+
+  /* A 32 bit immediate, appearing in 2nd word.  */
+#define VIF_UIMM32_2 (VIF_VUADDR + 1)
+  { 32, 0, 1, 0, 0, 0, 0, 0 },
+
+  /* A 32 bit immediate, appearing in 3rd word.  */
+#define VIF_UIMM32_3 (VIF_UIMM32_2 + 1)
+  { 32, 0, 2, 0, 0, 0, 0, 0 },
+
+  /* A 32 bit immediate, appearing in 4th word.  */
+#define VIF_UIMM32_4 (VIF_UIMM32_3 + 1)
+  { 32, 0, 3, 0, 0, 0, 0, 0 },
+
+  /* A 32 bit immediate, appearing in 5th word.  */
+#define VIF_UIMM32_5 (VIF_UIMM32_4 + 1)
+  { 32, 0, 4, 0, 0, 0, 0, 0 },
+
+  /* VU address used by mpg insn.  */
+#define VIF_MPGLOC (VIF_UIMM32_5 + 1)
+  { 16, 0, 0, DVP_OPERAND_VU_ADDRESS, parse_vif_mpgloc, insert_vif_mpgloc, 0, 0 },
+
+  /* A variable length data specifier as an expression.  */
+#define VIF_DATALEN (VIF_MPGLOC + 1)
+  { 0, 0, 0, 0, 0, insert_vif_datalen, extract_vif_datalen, 0 },
+
+  /* A variable length data specifier as a file name or '*'.
+     The operand is marked as pc-relative as the length is calculated by
+     emitting a label at the end of the data.  */
+#define VIF_DATALEN_SPECIAL (VIF_DATALEN + 1)
+  { 0, 0, 0, DVP_OPERAND_RELATIVE_BRANCH, parse_vif_datalen_special, insert_vif_datalen, 0, 0 },
+
+  /* The IMRU bits of the unpack insn.  */
+#define VIF_IMRUBITS (VIF_DATALEN_SPECIAL + 1)
+  { 0, 0, 0, DVP_OPERAND_SUFFIX,
+    parse_vif_imrubits, insert_vif_imrubits, extract_vif_imrubits, print_vif_imrubits },
+
+  /* The type of the unpack insn.  */
+#define VIF_UNPACKTYPE (VIF_IMRUBITS + 1)
+  { 4, 24, 0, 0, parse_vif_unpacktype, 0, 0, print_vif_unpacktype },
+
+  /* VU address used by unpack insn.  */
+#define VIF_UNPACKLOC (VIF_UNPACKTYPE + 1)
+  { 10, 0, 0, DVP_OPERAND_UNPACK_ADDRESS, 0, 0, 0, 0 },
+
+/* end of list place holder */
+  { 0 }
+};
+
+/* Some useful operand numbers.  */
+const int vif_operand_mpgloc = DVP_OPERAND_INDEX (VIF_MPGLOC);
+const int vif_operand_datalen_special = DVP_OPERAND_INDEX (VIF_DATALEN_SPECIAL);
+
+/* Field mask values.  */
+#define MVIFCMD 0x7f000000
+#define MVIFUNPACK 0x60000000
+
+/* Field values.  */
+#define VVIFCMD(x) V ((x), 7, 24)
+#define VVIFUNPACK V (0x60, 8, 24)
+
+struct dvp_opcode vif_opcodes[] =
+{
+  { "vifnop",   { VIF_IBIT },                                  0x7fffffff, 0, 0, 0, NULL, NULL  },
+  { "stcycle",  { VIF_IBIT, SP, VIF_WL, C, VIF_CL },           MVIFCMD, VVIFCMD (1), 0, DVP_OPCODE_IGNORE_DIS, NULL, NULL },
+  { "stcycl",   { VIF_IBIT, SP, VIF_WL, C, VIF_CL },           MVIFCMD, VVIFCMD (1), 0, 0, NULL, NULL },
+  { "offset",   { VIF_IBIT, SP, VIF_UIMM16 },                  MVIFCMD, VVIFCMD (2), 0, 0, NULL, NULL },
+  { "base",     { VIF_IBIT, SP, VIF_UIMM16 },                  MVIFCMD, VVIFCMD (3), 0, 0, NULL, NULL },
+  { "itop",     { VIF_IBIT, SP, VIF_UIMM16 },                  MVIFCMD, VVIFCMD (4), 0, 0, NULL, NULL },
+  { "stmod",    { VIF_IBIT, SP, VIF_MODE },                    MVIFCMD + V (~0, 14, 2), VVIFCMD (5), 0, 0, NULL, NULL },
+  { "mskpath3", { VIF_IBIT, SP, VIF_ABILITY },                 MVIFCMD + V (~0, 15, 0), VVIFCMD (6), 0, 0, NULL, NULL },
+  { "mark",     { VIF_IBIT, SP, VIF_UIMM16 },                  MVIFCMD, VVIFCMD (7), 0, 0, NULL, NULL },
+  { "flushe",   { VIF_IBIT },                                  MVIFCMD, VVIFCMD (16), 0, 0, NULL, NULL },
+  { "flusha",   { VIF_IBIT },                                  MVIFCMD, VVIFCMD (19), 0, 0, NULL, NULL },
+  /* "flush" must appear after the previous two, longer ones first remember */
+  { "flush",    { VIF_IBIT },                                  MVIFCMD, VVIFCMD (17), 0, 0, NULL, NULL },
+  { "mscalf",   { VIF_IBIT, SP, VIF_VUADDR },                  MVIFCMD, VVIFCMD (21), 0, 0, NULL, NULL },
+  { "mscal",    { VIF_IBIT, SP, VIF_VUADDR },                  MVIFCMD, VVIFCMD (20), 0, 0, NULL, NULL },
+  /* "mscal" must appear after the previous one. */
+  { "mscnt",    { VIF_IBIT },                                  MVIFCMD, VVIFCMD (23), 0, 0, NULL, NULL },
+
+  /* 2 word instructions */
+  { "stmask",   { VIF_IBIT, SP, VIF_UIMM32_2 },                MVIFCMD, VVIFCMD (32), 0, VIF_OPCODE_LEN2, NULL, NULL },
+
+  /* 5 word instructions */
+  { "strow",    { VIF_IBIT, SP, VIF_UIMM32_2, C, VIF_UIMM32_3, C, VIF_UIMM32_4, C, VIF_UIMM32_5 }, MVIFCMD, VVIFCMD (48), 0, VIF_OPCODE_LEN5, NULL, NULL },
+  { "stcol",    { VIF_IBIT, SP, VIF_UIMM32_2, C, VIF_UIMM32_3, C, VIF_UIMM32_4, C, VIF_UIMM32_5 }, MVIFCMD, VVIFCMD (49), 0, VIF_OPCODE_LEN5, NULL, NULL},
+
+  /* variable length instructions */
+  { "mpg",      { VIF_IBIT, SP, VIF_MPGLOC, C, VIF_DATALEN_SPECIAL }, MVIFCMD, VVIFCMD (0x4a), 0, VIF_OPCODE_LENVAR + VIF_OPCODE_MPG + DVP_OPCODE_IGNORE_DIS, NULL, NULL },
+  { "mpg",      { VIF_IBIT, SP, VIF_MPGLOC, C, VIF_DATALEN },         MVIFCMD, VVIFCMD (0x4a), 0, VIF_OPCODE_LENVAR + VIF_OPCODE_MPG, NULL, NULL },
+
+  /* `directhl' must appear before `direct', longer ones first */
+  { "directhl", { VIF_IBIT, SP, VIF_DATALEN_SPECIAL },  MVIFCMD, VVIFCMD (0x51), 0, VIF_OPCODE_LENVAR + VIF_OPCODE_DIRECT + DVP_OPCODE_IGNORE_DIS, NULL, NULL },
+  { "directhl", { VIF_IBIT, SP, VIF_DATALEN },          MVIFCMD, VVIFCMD (0x51), 0, VIF_OPCODE_LENVAR + VIF_OPCODE_DIRECT, NULL, NULL },
+
+  { "direct",   { VIF_IBIT, SP, VIF_DATALEN_SPECIAL },  MVIFCMD, VVIFCMD (0x50), 0, VIF_OPCODE_LENVAR + VIF_OPCODE_DIRECT + DVP_OPCODE_IGNORE_DIS, NULL, NULL },
+  { "direct",   { VIF_IBIT, SP, VIF_DATALEN },          MVIFCMD, VVIFCMD (0x50), 0, VIF_OPCODE_LENVAR + VIF_OPCODE_DIRECT, NULL, NULL},
+
+  { "unpack",   { VIF_IMRUBITS, SP, VIF_UNPACKTYPE, C, VIF_UNPACKLOC, C, VIF_DATALEN_SPECIAL }, MVIFUNPACK, VVIFUNPACK, 0, VIF_OPCODE_LENVAR + VIF_OPCODE_UNPACK + DVP_OPCODE_IGNORE_DIS, NULL, NULL },
+  { "unpack",   { VIF_IMRUBITS, SP, VIF_UNPACKTYPE, C, VIF_UNPACKLOC, C, VIF_DATALEN },         MVIFUNPACK, VVIFUNPACK, 0, VIF_OPCODE_LENVAR + VIF_OPCODE_UNPACK, NULL, NULL },
+};
+const int vif_opcodes_count = sizeof (vif_opcodes) / sizeof (vif_opcodes[0]);
+
+
+/* unpack/stcycl macro */
+
+const struct dvp_macro vif_macros[] = {
+  { "unpack${imrubits} ${wl},${cl},${unpacktype},${unpackloc},${datalen}", "stcycl %1,%2\nunpack%0 %3,%4,%5" }
+};
+const int vif_macro_count = sizeof (vif_macros) / sizeof (vif_macros[0]);
+
+
+/* Length of parsed insn, in 32 bit words, or 0 if unknown.  */
+static int state_vif_len;
+
+/* The value for mpgloc seen.  */
+static int state_vif_mpgloc;
+/* Non-zero if '*' was seen for mpgloc.  */
+static int state_vif_mpgloc_star_p;
+
+/* The most recent WL,CL args to stcycl.
+   HACK WARNING: This is a real kludge because when processing an `unpack'
+   we don't necessarily know what stcycl insn goes with it.
+   For now we punt and assume the last one we assembled.
+   Note that this requires that there be at least one stcycl in the
+   file before any unpack (if not we assume wl <= cl).  */
+static int state_vif_wl = -1, state_vif_cl = -1;
+
+/* The file argument to mpg,direct,directhl,unpack is stored here
+   (in a malloc'd buffer).  */
+static char *state_vif_data_file;
+/* A numeric length for mpg,direct,directhl,unpack is stored here.  */
+static int state_vif_data_len;
+
+
+/* VIF parse,insert,extract,print helper fns.  */
+
+static long
+parse_vif_ibit (opcode, operand, mods, pstr, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     char **pstr;
+     const char **errmsg;
+{
+  char *str = *pstr;
+  int flags = 0;
+
+  if (*str != '[')
+    return 0;
+
+  for (str = str + 1; *str != ']'; ++str)
+    {
+      switch (tolower (*str))
+	{
+	case 'i' : flags = 1; break;
+	default : *errmsg = _("unknown flag"); return 0;
+	}
+    }
+
+  *pstr = str + 1;
+  return flags;
+}
+
+static void
+print_vif_ibit (opcode, operand, mods, insn, info, value)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn __attribute__((unused));
+     disassemble_info *info;
+     long value;
+{
+  if (value)
+    (*info->fprintf_func) (info->stream, "[i]");
+}
+
+/* Insert the wl,cl value into the insn.
+   This is used to record the wl,cl values for subsequent use by an unpack
+   insn.  */
+
+static void
+insert_vif_wlcl (opcode, operand, mods, insn, value, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand;
+     int mods __attribute__((unused));
+     DVP_INSN *insn;
+     long value;
+     const char **errmsg __attribute__((unused));
+{
+  *insn |= (value & ((1 << operand->bits) - 1)) << operand->shift;
+  if (operand->shift == 8)
+    state_vif_wl = value;
+  else
+    state_vif_cl = value;
+}
+
+/* Extract the wl,cl value from the insn.
+   This is used to record the wl,cl values for subsequent use by an unpack
+   insn.  */
+
+static long
+extract_vif_wlcl (opcode, operand, mods, insn, pinvalid)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand;
+     int mods __attribute__((unused));
+     DVP_INSN *insn;
+     int *pinvalid __attribute__((unused));
+{
+  long value = (*insn >> operand->shift) & ((1 << operand->bits) - 1);
+  if (operand->shift == 8)
+    state_vif_wl = value;
+  else
+    state_vif_cl = value;
+  return value;
+}
+
+static const keyword stmod_modes[] = {
+  { VIF_MODE_DIRECT, "direct" },
+  { VIF_MODE_ADD,    "add" },
+  { VIF_MODE_ADDROW, "addrow" },
+  { 0, 0 }
+};
+
+static long
+parse_vif_mode (opcode, operand, mods, pstr, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     char **pstr;
+     const char **errmsg;
+{
+  int mode;
+  char *str = *pstr;
+  char *start;
+  char c;
+
+  start = str;
+  if (isdigit ((unsigned char) *str))
+    {
+      mode = strtol (start, &str, 0);
+    }
+  else
+    {
+      str = scan_symbol (str);
+      c = *str;
+      *str = 0;
+      mode = lookup_keyword_value (stmod_modes, start, 0);
+      *str = c;
+    }
+  if (mode >= 0 && mode <= 2)
+    {
+      *pstr = str;
+      return mode;
+    }
+  *errmsg = _("invalid mode");
+  return 0;
+}
+
+static void
+print_vif_mode (opcode, operand, mods, insn, info, value)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     disassemble_info *info;
+     DVP_INSN *insn __attribute__((unused));
+     long value;
+{
+  const char *name = lookup_keyword_name (stmod_modes, value);
+
+  if (name)
+    (*info->fprintf_func) (info->stream, name);
+  else
+    (*info->fprintf_func) (info->stream, "???");
+}
+
+static long
+parse_vif_ability (opcode, operand, mods, pstr, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     char **pstr;
+     const char **errmsg;
+{
+  char *str = *pstr;
+
+  if (strncasecmp (str, "disable", 7) == 0)
+    {
+      *pstr += 7;
+      return 1;
+    }
+  else if (strncasecmp (str, "enable", 6) == 0)
+    {
+      *pstr += 6;
+      return 0;
+    }
+  *errmsg = _("invalid ability");
+  return 1;
+}
+
+static void
+print_vif_ability (opcode, operand, mods, insn, info, value)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn __attribute__((unused));
+     disassemble_info *info;
+     long value;
+{
+  if (! value)
+    (*info->fprintf_func) (info->stream, "enable");
+  else
+    (*info->fprintf_func) (info->stream, "disable");
+}
+
+/* Parse the mpgloc field.
+   This doesn't do any actual parsing.
+   It exists to record the fact that '*' was seen.  */
+
+static long
+parse_vif_mpgloc (opcode, operand, mods, pstr, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     char **pstr;
+     const char **errmsg __attribute__((unused));
+{
+  if (**pstr == '*')
+    state_vif_mpgloc_star_p = 1;
+  /* Since we don't advance *pstr, the normal expression parser will
+     be called.  */
+  return 0;
+}
+
+static void
+insert_vif_mpgloc (opcode, operand, mods, insn, value, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand;
+     int mods __attribute__((unused));
+     DVP_INSN *insn;
+     long value;
+     const char **errmsg __attribute__((unused));
+{
+  *insn |= (value & ((1 << operand->bits) - 1)) << operand->shift;
+  /* If we saw a '*', don't record VALUE - it's meaningless.  */
+  if (! state_vif_mpgloc_star_p)
+    state_vif_mpgloc = value;
+}
+
+/* Parse a file name or '*'.
+   If a file name, the name is stored in state_vif_data_file and result is 0.
+   If a *, result is -1.  */
+
+static long
+parse_vif_datalen_special (opcode, operand, mods, pstr, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     char **pstr;
+     const char **errmsg;
+{
+  char *str = *pstr;
+  char *start;
+  int len;
+
+  if (*str == '*')
+    {
+      ++*pstr;
+      return -1;
+    }
+
+  if (*str == '"')
+    {
+      start = ++str;
+      ++str;
+      while (*str && *str != '"')
+	{
+	  /* FIXME: \ parsing? */
+	  ++str;
+	}
+      if (*str == 0)
+	{
+	  *errmsg = _("file name missing terminating `\"'");
+	  return 0;
+	}
+      len = str - start;
+      state_vif_data_file = xmalloc (len + 1);
+      memcpy (state_vif_data_file, start, len);
+      state_vif_data_file[len] = 0;
+      *pstr = str + 1;
+      return 0;
+    }
+
+  *errmsg = _("invalid data length");
+  return 0;
+}
+
+/* This routine is used for both the mpg and unpack insns which store
+   their length value in the `num' field and the direct/directhl insns
+   which store their length value in the `immediate' field.  */
+
+static void
+insert_vif_datalen (opcode, operand, mods, insn, value, errmsg)
+     const dvp_opcode *opcode;
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn __attribute__((unused));
+     long value;
+     const char **errmsg __attribute__((unused));
+{
+  /* FIXME: The actual insertion of the value in the insn is currently done
+     in tc-dvp.c.  We just record the value.  */
+  /* Perform the max+1 -> 0 conversion.  */
+  if ((opcode->flags & VIF_OPCODE_MPG) != 0
+      && value == 256)
+    value = 0;
+  else if ((opcode->flags & VIF_OPCODE_DIRECT) != 0
+	   && value == 65536)
+    value = 0;
+  else if ((opcode->flags & VIF_OPCODE_UNPACK) != 0
+	   && value == 256)
+    value = 0;
+  state_vif_data_len = value;
+}
+
+/* This routine is used for both the mpg and unpack insns which store
+   their length value in the `num' field and the direct/directhl insns
+   which store their length value in the `immediate' field.  */
+
+static long
+extract_vif_datalen (opcode, operand, mods, insn, pinvalid)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn;
+     int *pinvalid __attribute__((unused));
+{
+  int len;
+
+  switch ((*insn >> 24) & 0x70)
+    {
+    case 0x40 : /* mpg */
+      len = (*insn >> 16) & 0xff;
+      return len ? len : 256;
+    case 0x50 : /* direct,directhl */
+      len = *insn & 0xffff;
+      return len ? len : 65536;
+    case 0x60 : /* unpack */
+    case 0x70 :
+      len = (*insn >> 16) & 0xff;
+      return len ? len : 256;
+    default :
+      return 0;
+    }
+}
+
+static long
+parse_vif_imrubits (opcode, operand, mods, pstr, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     char **pstr;
+     const char **errmsg;
+{
+  char *str = *pstr;
+  int flags = 0;
+
+  if (*str != '[')
+    return 0;
+
+  for (str = str + 1; *str != ']'; ++str)
+    {
+      switch (tolower (*str))
+	{
+	case 'i' : flags |= VIF_FLAG_I; break;
+	case 'm' : flags |= VIF_FLAG_M; break;
+	case 'r' : flags |= VIF_FLAG_R; break;
+	case 'u' : flags |= VIF_FLAG_U; break;
+	default : *errmsg = _("unknown vif flag"); return 0;
+	}
+    }
+
+  *pstr = str + 1;
+  return flags;
+}
+
+static void
+insert_vif_imrubits (opcode, operand, mods, insn, value, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn;
+     long value;
+     const char **errmsg __attribute__((unused));
+{
+  if (value & VIF_FLAG_I)
+    *insn |= 0x80000000;
+  if (value & VIF_FLAG_M)
+    *insn |= 0x10000000;
+  if (value & VIF_FLAG_R)
+    *insn |= 0x8000;
+  if (value & VIF_FLAG_U)
+    *insn |= 0x4000;
+}
+
+static long
+extract_vif_imrubits (opcode, operand, mods, insn, pinvalid)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn;
+     int *pinvalid __attribute__((unused));
+{
+  long value = 0;
+  if (*insn & 0x80000000)
+    value |= VIF_FLAG_I;
+  if (*insn & 0x10000000)
+    value |= VIF_FLAG_M;
+  if (*insn & 0x8000)
+    value |= VIF_FLAG_R;
+  if (*insn & 0x4000)
+    value |= VIF_FLAG_U;
+  return value;
+}
+
+static void
+print_vif_imrubits (opcode, operand, mods, insn, info, value)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn __attribute__((unused));
+     disassemble_info *info;
+     long value;
+{
+  if (value)
+    {
+      (*info->fprintf_func) (info->stream, "[");
+      if (value & VIF_FLAG_I)
+	(*info->fprintf_func) (info->stream, "i");
+      if (value & VIF_FLAG_M)
+	(*info->fprintf_func) (info->stream, "m");
+      if (value & VIF_FLAG_R)
+	(*info->fprintf_func) (info->stream, "r");
+      if (value & VIF_FLAG_U)
+	(*info->fprintf_func) (info->stream, "u");
+      (*info->fprintf_func) (info->stream, "]");
+    }
+}
+
+static const keyword unpack_types[] = {
+  { VIF_UNPACK_S_32, "s_32" },
+  { VIF_UNPACK_S_16, "s_16" },
+  { VIF_UNPACK_S_8, "s_8" },
+  { VIF_UNPACK_V2_32, "v2_32" },
+  { VIF_UNPACK_V2_16, "v2_16" },
+  { VIF_UNPACK_V2_8, "v2_8" },
+  { VIF_UNPACK_V3_32, "v3_32" },
+  { VIF_UNPACK_V3_16, "v3_16" },
+  { VIF_UNPACK_V3_8, "v3_8" },
+  { VIF_UNPACK_V4_32, "v4_32" },
+  { VIF_UNPACK_V4_16, "v4_16" },
+  { VIF_UNPACK_V4_8, "v4_8" },
+  { VIF_UNPACK_V4_5, "v4_5" },
+  { 0, 0 }
+};
+
+static long
+parse_vif_unpacktype (opcode, operand, mods, pstr, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     char **pstr;
+     const char **errmsg;
+{
+  int type;
+  char *str = *pstr;
+  char *start;
+  char c;
+
+  start = str;
+  str = scan_symbol (str);
+  c = *str;
+  *str = 0;
+  type = lookup_keyword_value (unpack_types, start, 0);
+  *str = c;
+  if (type != -1)
+    {
+      *pstr = str;
+      return type;
+    }
+  *errmsg = _("invalid unpack type");
+  return 0;
+}
+
+static void
+print_vif_unpacktype (opcode, operand, mods, insn, info, value)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn __attribute__((unused));
+     disassemble_info *info;
+     long value;
+{
+  const char *name = lookup_keyword_name (unpack_types, value);
+
+  if (name)
+    (*info->fprintf_func) (info->stream, name);
+  else
+    (*info->fprintf_func) (info->stream, "???");
+}
+
+
+/* External VIF supporting routines.  */
+
+/* Return length, in 32 bit words, of just parsed vif insn,
+   or 0 if unknown.  */
+
+int
+vif_len ()
+{
+  /* This shouldn't be called unless a vif insn was parsed.
+     Also, we want to catch errors in parsing that don't set this.  */
+  if (state_vif_len == -1)
+    abort ();
+
+  return state_vif_len;
+}
+
+/* Return the length value to use for an unpack instruction, type TYPE,
+   whose data length in bytes is LEN.
+   We do not perform the max + 1 -> 0 transformation.  That's up to the caller.
+   WL,CL are the values to use for those registers.  A value of -1 means to
+   use the internally recorded values.  If the values are still -1, we
+   assume wl <= cl.
+   This means that it is assumed that unpack always requires a preceeding
+   stcycl sufficiently recently that the value we have recorded is correct.
+   FIXME: We assume len % 4 == 0.  */
+
+int
+vif_unpack_len_value (type, wl, cl, len)
+     unpack_type type;
+     int wl,cl;
+     int len;
+{
+  int vn = (type >> 2) & 3;
+  int vl = type & 3;
+  int n, num;
+
+  if (wl < 0)
+    wl = state_vif_wl;
+  if (cl < 0)
+    cl = state_vif_cl;
+  if (wl == -1 || cl == -1)
+    wl = cl = 1;
+
+  if (wl <= cl)
+    {
+      /* data length (in words) len = ((((32 >> vl) * (vn + 1)) * num) / 32)
+	 Thus num = (len / 4) * 32 / ((32 >> vl) * (vn + 1)) */
+      num = (len * 32 / 4) / ((32 >> vl) * (vn + 1));
+    }
+  else /* wl > cl */
+    {
+      /* data length (in words) len = ((((32 >> vl) * (vn + 1)) * n) / 32)
+	 n = CL * (num / WL) + min (num % WL, CL)
+	 Thus n = (len / 4) * 32 / ((32 >> vl) * (vn + 1))
+	 num = (n - delta) * wl / cl;
+	 where `delta' is defined to be "just right".
+	 I'm too bloody tired to do this more cleverly.  */
+      n = (len * 32 / 4) / ((32 >> vl) * (vn + 1));
+      /* Avoid divide by zero.  */
+      if (cl == 0)
+	return 0;
+      /* Note that wl cannot be zero here.
+	 We know that cl > 0 and thus if wl == 0 we would have taken
+	 the `then' part of this if().  */
+      num = n * wl / cl;
+      while (num > 0
+	     && n != (cl * num / wl) + MIN (num % wl, cl))
+	--num;
+      if (num == 0)
+	{
+	  fprintf (stderr, _("internal error in unpack length calculation"));
+	  abort ();
+	}
+    }
+  return num;
+}
+
+/* Return the data length, in bytes, of an unpack insn of type TYPE,
+   whose `num' field in NUM.
+   If WL,CL are unknown, we assume wl <= cl.  */
+
+int
+vif_unpack_len (type, num)
+     unpack_type type;
+     int num;
+{
+  int vn = (type >> 2) & 3;
+  int vl = type & 3;
+  int wl = state_vif_wl;
+  int cl = state_vif_cl;
+  int n, len;
+
+  if (wl == -1 || cl == -1)
+    wl = cl = 1;
+
+  /* Perform 0 -> max+1 conversion.  */
+  if (num == 0)
+    num = 256;
+  if (wl == 0)
+    wl = 256;
+
+  if (wl <= cl)
+    {
+      /* data length (in words) len = ((((32 >> vl) * (vn + 1)) * num) / 32) */
+      n = num;
+    }
+  else /* wl > cl */
+    {
+      /* data length (in words) len = ((((32 >> vl) * (vn + 1)) * n) / 32)
+	 n = CL * (num / WL) + min (num % WL, CL) */
+      n = cl * num / wl + MIN (num % wl, cl);
+    }
+  /* +31: round up to next word boundary */
+  len = ((((32 >> vl) * (vn + 1)) * n) + 31) / 32;
+  return len * 4;
+}
+
+/* Return the length, in 32 bit words, of a VIF insn.
+   INSN is the first word.
+   The cpu type of the following data is stored in PCPU.  */
+
+int
+vif_insn_len (insn, pcpu)
+     DVP_INSN insn;
+     dvp_cpu *pcpu;
+{
+  unsigned char cmd;
+
+  *pcpu = DVP_VIF;
+
+  /* strip off `i' bit */
+  insn &= 0x7fffffff;
+
+  /* get top byte */
+  cmd = insn >> 24;
+
+  /* see page 11 of cpu2 spec 2.1 for further info */
+  if ((cmd & 0x60) == 0)
+    return 1;
+  if ((cmd & 0x70) == 0x20)
+    return 2;
+  if ((cmd & 0x70) == 0x30)
+    return 5;
+  if ((cmd & 0x70) == 0x40)
+    {
+      /* mpg */
+      int len = (insn >> 16) & 0xff;
+      *pcpu = DVP_VUUP;
+      return 1 + (len == 0 ? 256 : len) * 2;
+    }
+  if ((cmd & 0x70) == 0x50)
+    {
+      /* direct,directhl */
+      int len = insn & 0xffff;
+      *pcpu = DVP_GIF;
+      return 1 + (len == 0 ? 65536 : len) * 4;
+    }
+  if ((cmd & 0x60) == 0x60)
+    {
+      /* unpack */
+      int len = vif_unpack_len (cmd & 15, (insn >> 16) & 0xff);
+      if (len == -1)
+	len = 4; /* FIXME: revisit */
+      return 1 + len / 4;
+    }
+
+  /* unknown insn */
+  return 1;
+}
+
+/* Get the value of mpgloc seen.  */
+
+int
+vif_get_mpgloc (void)
+{
+  return state_vif_mpgloc;
+}
+
+/* Return recorded variable data length indicator.
+   This is either a file name or a numeric length.
+   A length of -1 means the caller must compute it.  */
+
+void
+vif_get_var_data (file, len)
+     const char **file;
+     int *len;
+{
+  *file = state_vif_data_file;
+  *len = state_vif_data_len;
+}
+
+/* Return the specified values for wl,cl.  */
+
+void
+vif_get_wl_cl (wlp, clp)
+     int *wlp, *clp;
+{
+  *wlp = state_vif_wl;
+  *clp = state_vif_cl;
+}
+
+
+/* DMA support.  */
+
+PARSE_FN (dma_flags);
+INSERT_FN (dma_flags);
+EXTRACT_FN (dma_flags);
+PRINT_FN (dma_flags);
+
+INSERT_FN (dma_addr);
+EXTRACT_FN (dma_addr);
+
+const dvp_operand dma_operands[] =
+{
+    /* place holder (??? not sure if needed) */
+#define DMA_UNUSED 128
+    { 0 },
+
+    /* dma tag flag bits */
+#define DMA_FLAGS (DMA_UNUSED + 1)
+    { 0, 0, 0, DVP_OPERAND_SUFFIX,
+      parse_dma_flags, insert_dma_flags, extract_dma_flags, print_dma_flags },
+
+    /* dma data spec */
+#define DMA_COUNT (DMA_FLAGS + 1)
+    { 16, 0, 0, DVP_OPERAND_DMA_COUNT,
+      0, 0 /*insert_dma_count*/,
+      0 /*extract_dma_count*/, 0 /*print_dma_count*/ },
+
+    /* dma autocount modifier */
+#define DMA_AUTOCOUNT (DMA_COUNT + 1)
+    { 0, 0, 0, DVP_OPERAND_AUTOCOUNT, 0, 0, 0, 0 },
+
+    /* dma in-line-data */
+#define DMA_INLINE (DMA_AUTOCOUNT + 1)
+    { 0, 0, 0, DVP_OPERAND_FAKE + DVP_OPERAND_DMA_INLINE, 0, 0, 0, 0 },
+
+    /* dma ref data address */
+#define DMA_ADDR (DMA_INLINE + 1)
+    { 27, 4, 1, DVP_OPERAND_DMA_ADDR + DVP_OPERAND_MIPS_ADDRESS,
+      0 /*parse_dma_addr*/, insert_dma_addr,
+      extract_dma_addr, 0 /*print_dma_addr*/ },
+
+    /* dma next tag spec */
+#define DMA_NEXT (DMA_ADDR + 1)
+    { 27, 4, 1, DVP_OPERAND_DMA_NEXT + DVP_OPERAND_MIPS_ADDRESS,
+      0, insert_dma_addr, extract_dma_addr, 0 /*print_dma_addr*/ },
+
+/* end of list place holder */
+  { 0 }
+};
+
+/* Some useful operand numbers.  */
+const int dma_operand_count = DVP_OPERAND_INDEX (DMA_COUNT);
+const int dma_operand_addr = DVP_OPERAND_INDEX (DMA_ADDR);
+
+struct dvp_opcode dma_opcodes[] =
+{
+  { "dmarefe", { DMA_FLAGS, SP, '*',       C, DMA_AUTOCOUNT, DMA_ADDR },             0x70000000, 0x00000000, 0, DVP_OPCODE_IGNORE_DIS, NULL, NULL },
+  { "dmarefe", { DMA_FLAGS, SP, DMA_COUNT, C, DMA_ADDR },                            0x70000000, 0x00000000, 0, 0, NULL, NULL },
+  { "dmacnt",  { DMA_FLAGS, SP, '*',       DMA_AUTOCOUNT, DMA_INLINE },              0x70000000, 0x10000000, 0, DVP_OPCODE_IGNORE_DIS, NULL, NULL },
+  { "dmacnt",  { DMA_FLAGS, SP, DMA_COUNT, DMA_INLINE },                             0x70000000, 0x10000000, 0, 0, NULL, NULL },
+  { "dmanext", { DMA_FLAGS, SP, '*',       C, DMA_AUTOCOUNT, DMA_INLINE, DMA_NEXT }, 0x70000000, 0x20000000, 0, DVP_OPCODE_IGNORE_DIS, NULL, NULL },
+  { "dmanext", { DMA_FLAGS, SP, DMA_COUNT, C, DMA_INLINE, DMA_NEXT },                0x70000000, 0x20000000, 0, 0, NULL, NULL },
+  { "dmaref",  { DMA_FLAGS, SP, '*',       C, DMA_AUTOCOUNT, DMA_ADDR },             0x70000000, 0x30000000, 0, DVP_OPCODE_IGNORE_DIS, NULL, NULL },
+  { "dmaref",  { DMA_FLAGS, SP, DMA_COUNT, C, DMA_ADDR },                            0x70000000, 0x30000000, 0, 0, NULL, NULL },
+  { "dmarefs", { DMA_FLAGS, SP, '*',       C, DMA_AUTOCOUNT, DMA_ADDR },             0x70000000, 0x40000000, 0, DVP_OPCODE_IGNORE_DIS, NULL, NULL },
+  { "dmarefs", { DMA_FLAGS, SP, DMA_COUNT, C, DMA_ADDR },                            0x70000000, 0x40000000, 0, 0, NULL, NULL },
+  { "dmacall", { DMA_FLAGS, SP, '*',       C, DMA_AUTOCOUNT, DMA_INLINE, DMA_NEXT }, 0x70000000, 0x50000000, 0, DVP_OPCODE_IGNORE_DIS, NULL, NULL },
+  { "dmacall", { DMA_FLAGS, SP, DMA_COUNT, C, DMA_INLINE, DMA_NEXT },                0x70000000, 0x50000000, 0, 0, NULL, NULL },
+  { "dmaret",  { DMA_FLAGS, SP, '*',       DMA_AUTOCOUNT, DMA_INLINE},               0x70000000, 0x60000000, 0, DVP_OPCODE_IGNORE_DIS, NULL, NULL },
+  { "dmaret",  { DMA_FLAGS, SP, DMA_COUNT, DMA_INLINE },                             0x70000000, 0x60000000, 0, 0, NULL, NULL },
+  { "dmaend",  { DMA_FLAGS, SP, '*',       DMA_AUTOCOUNT, DMA_INLINE },              0x70000000, 0x70000000, 0, DVP_OPCODE_IGNORE_DIS, NULL, NULL },
+  { "dmaend",  { DMA_FLAGS, SP, DMA_COUNT, DMA_INLINE },                             0x70000000, 0x70000000, 0, 0, NULL, NULL },
+  { "dmaend",  { DMA_FLAGS },                                                        0x70000000, 0x70000000, 0, 0, NULL, NULL },
+};
+const int dma_opcodes_count = sizeof (dma_opcodes) / sizeof (dma_opcodes[0]);
+
+
+/* DMA parse,insert,extract,print helper fns.  */
+
+static long
+parse_dma_flags (opcode, operand, mods, pstr, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     char **pstr;
+     const char **errmsg;
+{
+  char *str = *pstr;
+  int flags = 0;
+
+  if (*str != '[')
+    return 0;
+
+  for (str = str + 1; *str != ']'; ++str)
+    {
+      switch (tolower (*str))
+	{
+	case '0' : flags |= DMA_FLAG_PCE0; break;
+	case '1' : flags |= DMA_FLAG_PCE1; break;
+	case 'i' : flags |= DMA_FLAG_INT; break;
+	case 's' : flags |= DMA_FLAG_SPR; break;
+	default : *errmsg = _("unknown dma flag"); return 0;
+	}
+    }
+
+  *pstr = str + 1;
+  return flags;
+}
+
+static void
+insert_dma_flags (opcode, operand, mods, insn, value, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn;
+     long value;
+     const char **errmsg __attribute__((unused));
+{
+  if (value & DMA_FLAG_PCE0)
+    insn[0] |= 2 << 26;
+  else if (value & DMA_FLAG_PCE0)
+    insn[0] |= 3 << 26;
+  if (value & DMA_FLAG_INT)
+    insn[0] |= (1 << 31);
+  if (value & DMA_FLAG_SPR)
+    insn[1] |= (1 << 31);
+}
+
+static long
+extract_dma_flags (opcode, operand, mods, insn, pinvalid)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn;
+     int *pinvalid __attribute__((unused));
+{
+  long value = 0;
+  if (((insn[0] >> 26) & 3) == 2)
+     value |= DMA_FLAG_PCE0;
+  if (((insn[0] >> 26) & 3) == 3)
+     value |= DMA_FLAG_PCE0;
+  if (((insn[0] >> 31) & 1) == 1)
+     value |= DMA_FLAG_INT;
+  if (((insn[1] >> 31) & 1) == 1)
+     value |= DMA_FLAG_SPR;
+  return value;
+}
+
+static void
+print_dma_flags (opcode, operand, mods, insn, info, value)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn __attribute__((unused));
+     disassemble_info *info;
+     long value;
+{
+  if (value)
+    {
+      (*info->fprintf_func) (info->stream, "[");
+      if (value & DMA_FLAG_PCE0)
+	(*info->fprintf_func) (info->stream, "0");
+      if (value & DMA_FLAG_PCE1)
+	(*info->fprintf_func) (info->stream, "1");
+      if (value & DMA_FLAG_INT)
+	(*info->fprintf_func) (info->stream, "i");
+      if (value & DMA_FLAG_SPR)
+	(*info->fprintf_func) (info->stream, "s");
+      (*info->fprintf_func) (info->stream, "]");
+    }
+}
+
+static void
+insert_dma_addr (opcode, operand, mods, insn, value, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand;
+     int mods;
+     DVP_INSN *insn;
+     long value;
+     const char **errmsg __attribute__((unused));
+{
+  int word;
+
+  if (mods & DVP_MOD_THIS_WORD)
+    word = 0;
+  else if (operand->word)
+    word = operand->word;
+  else
+    word = operand->shift / 32;
+
+  /* The lower 4 bits are cut off and the value begins at bit 4.  */
+  insn[word] |= value & 0x7ffffff0;
+}
+
+static long
+extract_dma_addr (opcode, operand, mods, insn, pinvalid)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand;
+     int mods;
+     DVP_INSN *insn;
+     int *pinvalid __attribute__((unused));
+{
+  int word;
+
+  if (mods & DVP_MOD_THIS_WORD)
+    word = 0;
+  else if (operand->word)
+    word = operand->word;
+  else
+    word = operand->shift / 32;
+
+  return insn[word] & 0x7ffffff0;
+}
+
+/* GIF support.  */
+
+PARSE_FN (gif_prim);
+INSERT_FN (gif_prim);
+EXTRACT_FN (gif_prim);
+PRINT_FN (gif_prim);
+
+PARSE_FN (gif_regs);
+INSERT_FN (gif_regs);
+EXTRACT_FN (gif_regs);
+PRINT_FN (gif_regs);
+
+PARSE_FN (gif_nloop);
+INSERT_FN (gif_nloop);
+EXTRACT_FN (gif_nloop);
+PRINT_FN (gif_nloop);
+
+PARSE_FN (gif_eop);
+EXTRACT_FN (gif_eop);
+PRINT_FN (gif_eop);
+
+/* Bit numbering:
+
+    insn[0]    insn[1]     insn[2]     insn[3]
+   31 ... 0 | 63 ... 32 | 95 ... 64 | 127 ... 96  */
+
+const dvp_operand gif_operands[] =
+{
+  /* place holder (??? not sure if needed) */
+#define GIF_UNUSED 128
+  { 0 },
+
+  /* PRIM=foo operand */
+#define GIF_PRIM (GIF_UNUSED + 1)
+  { 11, 47, 0, 0, parse_gif_prim, insert_gif_prim, extract_gif_prim, print_gif_prim },
+
+  /* REGS=foo operand */
+#define GIF_REGS (GIF_PRIM + 1)
+  { 64, 0, 0, 0, parse_gif_regs, insert_gif_regs, extract_gif_regs, print_gif_regs },
+
+  /* NLOOP=foo operand */
+#define GIF_NLOOP (GIF_REGS + 1)
+  { 15, 0, 0, 0, parse_gif_nloop, insert_gif_nloop, extract_gif_nloop, print_gif_nloop },
+
+  /* EOP operand */
+#define GIF_EOP (GIF_NLOOP + 1)
+  { 1, 15, 0, 0, parse_gif_eop, 0, extract_gif_eop, print_gif_eop },
+
+/* end of list place holder */
+  { 0 }
+};
+
+/* Some useful operand numbers.  */
+const int gif_operand_nloop = DVP_OPERAND_INDEX (GIF_NLOOP);
+
+/* GIF opcode values.  */
+#define VGIFOP(x) (((x) & 3) << 26)
+#define VGIFNREGS(x) (((x) & 15) << 28)
+
+/* GIF opcode masks.  */
+#define MGIFOP VGIFOP (~0)
+#define MGIFNREGS VGIFNREGS (~0)
+
+struct dvp_opcode gif_opcodes[] =
+{
+  /* Some of these may take optional arguments.
+     The way this is handled is to have multiple table entries, those with and
+     those without the optional arguments.
+     !!! The order here is important.  The code that scans this table assumes
+     that if it reaches the end of a syntax string there is nothing more to
+     parse.  This means that longer versions of instructions must appear before
+     shorter ones.  Otherwise the text at the "end" of a longer one may be
+     interpreted as junk when the parser is using a shorter version of the
+     syntax string.  */
+
+  { "gifpacked", { SP, GIF_PRIM, C, GIF_REGS, C, GIF_NLOOP, C, GIF_EOP }, MGIFOP, VGIFOP (0), 1, 0, NULL, NULL },
+  { "gifpacked", { SP, GIF_REGS, C, GIF_NLOOP, C, GIF_EOP },              MGIFOP, VGIFOP (0), 1, 0, NULL, NULL },
+  { "gifpacked", { SP, GIF_PRIM, C, GIF_REGS, C, GIF_EOP },               MGIFOP, VGIFOP (0), 1, 0, NULL, NULL },
+  { "gifpacked", { SP, GIF_PRIM, C, GIF_REGS, C, GIF_NLOOP },             MGIFOP, VGIFOP (0), 1, 0, NULL, NULL },
+  { "gifpacked", { SP, GIF_REGS, C, GIF_EOP },                            MGIFOP, VGIFOP (0), 1, 0, NULL, NULL },
+  { "gifpacked", { SP, GIF_REGS, C, GIF_NLOOP },                          MGIFOP, VGIFOP (0), 1, 0, NULL, NULL },
+  { "gifpacked", { SP, GIF_PRIM, C, GIF_REGS },                           MGIFOP, VGIFOP (0), 1, 0, NULL, NULL },
+  { "gifpacked", { SP, GIF_REGS },                                        MGIFOP, VGIFOP (0), 1, 0, NULL, NULL },
+
+  { "gifreglist", { SP, GIF_REGS, C, GIF_NLOOP, C, GIF_EOP }, MGIFOP, VGIFOP (1), 1, 0, NULL, NULL},
+  { "gifreglist", { SP, GIF_REGS, C, GIF_EOP },               MGIFOP, VGIFOP (1), 1, 0, NULL, NULL },
+  { "gifreglist", { SP, GIF_REGS, C, GIF_NLOOP },             MGIFOP, VGIFOP (1), 1, 0, NULL, NULL },
+  { "gifreglist", { SP, GIF_REGS },                           MGIFOP, VGIFOP (1), 1, 0, NULL, NULL },
+
+  { "gifimage", { SP, GIF_NLOOP, C, GIF_EOP }, MGIFOP, VGIFOP (2), 1, 0, NULL, NULL },
+  { "gifimage", { SP, GIF_EOP },               MGIFOP, VGIFOP (2), 1, 0, NULL, NULL },
+  { "gifimage", { SP, GIF_NLOOP },             MGIFOP, VGIFOP (2), 1, 0, NULL, NULL },
+  { "gifimage", { 0 },                         MGIFOP, VGIFOP (2), 1, 0, NULL, NULL },
+};
+const int gif_opcodes_count = sizeof (gif_opcodes) / sizeof (gif_opcodes[0]);
+
+
+/* GIF parsing/printing state.  */
+
+static int state_gif_nregs;
+static int state_gif_regs[16];
+static int state_gif_nloop;
+
+
+/* GIF parse,insert,extract,print helper fns.  */
+
+static long
+parse_gif_prim (opcode, operand, mods, pstr, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     char **pstr;
+     const char **errmsg;
+{
+  char *str = *pstr;
+  char *start;
+  long prim;
+
+  if (strncasecmp (str, "prim=", 5) != 0)
+    {
+      *errmsg = _("missing PRIM spec");
+      return 0;
+    }
+  str += 5;
+  start = str;
+  prim = strtol (start, &str, 0);
+  if (str == start)
+    {
+      *errmsg = _("missing PRIM spec");
+      return 0;
+    }
+  *pstr = str;
+  return prim;
+}
+
+static void
+insert_gif_prim (opcode, operand, mods, insn, value, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand;
+     int mods __attribute__((unused));
+     DVP_INSN *insn;
+     long value;
+     const char **errmsg __attribute__((unused));
+{
+  int word = operand->shift / 32;
+  /* Chop off unwanted bits.  */
+  insn[word] |= (value & ((1 << operand->bits) - 1)) << operand->shift % 32;
+  /* Set the PRE bit.  */
+  insn[word] |= GIF_PRE;
+}
+
+static long
+extract_gif_prim (opcode, operand, mods, insn, pinvalid)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand;
+     int mods __attribute__((unused));
+     DVP_INSN *insn;
+     int *pinvalid;
+{
+  int word = operand->shift / 32;
+  if (! (insn[word] & GIF_PRE))
+    {
+      /* The prim register isn't used.  Mark as invalid so this choice is
+	 skipped as a possibility for disassembly.  */
+      *pinvalid = 1;
+      return -1;
+    }
+  return (insn[word] >> operand->shift % 32) & ((1 << operand->bits) - 1);
+}
+
+static void
+print_gif_prim (opcode, operand, mods, insn, info, value)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn __attribute__((unused));
+     disassemble_info *info;
+     long value;
+{
+  if (value != -1)
+    (*info->fprintf_func) (info->stream, "prim=0x%lx", value);
+}
+
+static const keyword gif_regs[] = {
+  { GIF_REG_PRIM,    "prim" },
+  { GIF_REG_RGBAQ,   "rgbaq" },
+  { GIF_REG_ST,      "st" },
+  { GIF_REG_UV,      "uv" },
+  { GIF_REG_XYZF2,   "xyzf2" },
+  { GIF_REG_XYZ2,    "xyz2" },
+  { GIF_REG_TEX0_1,  "tex0_1" },
+  { GIF_REG_TEX0_2,  "tex0_2" },
+  { GIF_REG_CLAMP_1, "clamp_1" },
+  { GIF_REG_CLAMP_2, "clamp_2" },
+  { GIF_REG_XYZF,    "xyzf" },
+  /* 11 is unused.  Should it ever appear we want to disassemble it somehow
+     so we give it a name anyway.  */
+  { GIF_REG_UNUSED11, "unused11" },
+  { GIF_REG_XYZF3,   "xyzf3" },
+  { GIF_REG_XYZ3,    "xyz3" },
+  { GIF_REG_A_D,     "a_d" },
+  { GIF_REG_NOP,     "nop" },
+  { 0, 0 }
+};
+
+/* Parse a REGS= spec.
+   The result is the number of registers parsed.
+   The selected registers are recorded internally in a static
+   variable for use later by the insert routine.  */
+
+static long
+parse_gif_regs (opcode, operand, mods, pstr, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     char **pstr;
+     const char **errmsg;
+{
+  char *str = *pstr;
+  char *start;
+  char c;
+  int reg,nregs;
+
+  if (strncasecmp (str, "regs=", 5) != 0)
+    {
+      *errmsg = _("missing REGS spec");
+      return 0;
+    }
+  str += 5;
+  SKIP_BLANKS (str);
+  if (*str != '{')
+    {
+      *errmsg = _("missing '{' in REGS spec");
+      return 0;
+    }
+  ++str;
+
+  nregs = 0;
+  while (*str && *str != '}')
+    {
+      if (nregs == 16)
+	{
+	  *errmsg = _("too many registers");
+	  return 0;
+	}
+
+      /* Pick out the register name.  */
+      SKIP_BLANKS (str);
+      start = str;
+      str = scan_symbol (str);
+      if (str == start)
+	{
+	  *errmsg = _("invalid REG");
+	  return 0;
+	}
+
+      /* Look it up in the table.  */
+      c = *str;
+      *str = 0;
+      reg = lookup_keyword_value (gif_regs, start, 0);
+      *str = c;
+      if (reg == -1)
+	{
+	  *errmsg = _("invalid REG");
+	  return 0;
+	}
+
+      /* Tuck the register number away for later use.  */
+      state_gif_regs[nregs++] = reg;
+
+      /* Prepare for the next one.  */
+      SKIP_BLANKS (str);
+      if (*str == ',')
+	++str;
+      else if (*str != '}')
+	break;
+    }
+  if (*str != '}')
+    {
+      *errmsg = _("missing '}' in REGS spec");
+      return 0;
+    }
+
+  *pstr = str + 1;
+  return nregs;
+}
+
+static void
+insert_gif_regs (opcode, operand, mods, insn, value, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn;
+     long value;
+     const char **errmsg __attribute__((unused));
+{
+  int i;
+  DVP_INSN *p;
+
+  state_gif_nregs = value;
+
+  /* Registers are stored in word 2,3 (0-origin) in memory.
+     Each word is processed from the lower bit numbers upwards,
+     and the words are stored little endian.  We must record each word
+     in host-endian form as the word will be swapped to target endianness
+     when written out.  */
+
+  p = insn + 2;
+  for (i = 0; i < state_gif_nregs; ++i)
+    {
+      /* Move to next word?  */
+      if (i == 8)
+	++p;
+
+      *p |= state_gif_regs[i] << (i * 4);
+    }
+
+  insn[1] |= VGIFNREGS (state_gif_nregs);
+}
+
+static long
+extract_gif_regs (opcode, operand, mods, insn, pinvalid)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn;
+     int *pinvalid __attribute__((unused));
+{
+  state_gif_nregs = (insn[1] & MGIFNREGS) >> 28;
+  return state_gif_nregs;
+}
+
+static void
+print_gif_regs (opcode, operand, mods, insn, info, value)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn;
+     disassemble_info *info;
+     long value;
+{
+  /* VALUE is the number of registers [returned by the extract handler].  */
+  int i;
+  DVP_INSN *p;
+
+  /* See insert_gif_regs for an explanation of how the regs are stored.  */
+
+  (*info->fprintf_func) (info->stream, "regs={");
+
+  p = insn + 2;
+  for (i = 0; i < value; ++i)
+    {
+      int reg;
+
+      /* Move to next word?  */
+      if (i == 8)
+	++p;
+
+      reg = (*p >> (i * 4)) & 15;
+
+      (*info->fprintf_func) (info->stream, "%s",
+			     lookup_keyword_name (gif_regs, reg));
+      if (i + 1 != value)
+	(*info->fprintf_func) (info->stream, ",");
+    }
+
+  (*info->fprintf_func) (info->stream, "}");
+}
+
+static long
+parse_gif_nloop (opcode, operand, mods, pstr, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     char **pstr;
+     const char **errmsg;
+{
+  char *str = *pstr;
+  char *start;
+  int nloop;
+
+  if (strncasecmp (str, "nloop=", 6) != 0)
+    {
+      *errmsg = _("missing NLOOP spec");
+      return 0;
+    }
+  str += 6;
+  SKIP_BLANKS (str);
+  start = str;
+  nloop = strtol (start, &str, 10);
+  if (str == start)
+    {
+      *errmsg = _("invalid NLOOP spec");
+      return 0;
+    }
+  *pstr = str;
+  return nloop;
+}
+
+static void
+insert_gif_nloop (opcode, operand, mods, insn, value, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand;
+     int mods __attribute__((unused));
+     DVP_INSN *insn;
+     long value;
+     const char **errmsg __attribute__((unused));
+{
+  int word = operand->shift / 32;
+  insn[word] |= (value & ((1 << operand->bits) - 1)) << operand->shift % 32;
+  /* Tuck the value away for later use.  */
+  state_gif_nloop = value;
+}
+
+static long
+extract_gif_nloop (opcode, operand, mods, insn, pinvalid)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand;
+     int mods __attribute__((unused));
+     DVP_INSN *insn;
+     int *pinvalid __attribute__((unused));
+{
+  long value;
+  int word = operand->shift / 32;
+  value = (insn[word] >> operand->shift % 32) & ((1 << operand->bits) - 1);
+  /* Tuck the value away for later use.  */
+  state_gif_nloop = value;
+  return value;
+}
+
+static void
+print_gif_nloop (opcode, operand, mods, insn, info, value)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn __attribute__((unused));
+     disassemble_info *info;
+     long value;
+{
+  (*info->fprintf_func) (info->stream, "nloop=%ld", value);
+}
+
+static long
+parse_gif_eop (opcode, operand, mods, pstr, errmsg)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     char **pstr;
+     const char **errmsg;
+{
+  if (strncasecmp (*pstr, "eop", 3) == 0)
+    {
+      *pstr += 3;
+      return 1;
+    }
+  *errmsg = _("missing `EOP'");
+  return 0;
+}
+
+static long
+extract_gif_eop (opcode, operand, mods, insn, pinvalid)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand;
+     int mods __attribute__((unused));
+     DVP_INSN *insn;
+     int *pinvalid;
+{
+  long value;
+  int word = operand->shift / 32;
+  value = (insn[word] >> operand->shift % 32) & ((1 << operand->bits) - 1);
+  /* If EOP=0, mark this choice as invalid so it's not used for
+     disassembly.  */
+  if (! value)
+    *pinvalid = 1;
+  return value;
+}
+
+static void
+print_gif_eop (opcode, operand, mods, insn, info, value)
+     const dvp_opcode *opcode __attribute__((unused));
+     const dvp_operand *operand __attribute__((unused));
+     int mods __attribute__((unused));
+     DVP_INSN *insn __attribute__((unused));
+     disassemble_info *info;
+     long value;
+{
+  if (value)
+    (*info->fprintf_func) (info->stream, "eop");
+}
+
+
+/* External GIF support routines.  */
+
+int
+gif_nloop ()
+{
+  return state_gif_nloop;
+}
+
+int
+gif_nregs ()
+{
+  return state_gif_nregs;
+}
+
+
+/* Init fns.
+   These are called before doing each of the respective activities.  */
+
+/* Called by the assembler before parsing an instruction.  */
+
+void
+dvp_opcode_init_parse ()
+{
+  state_vu_mnemonic_dest = -1;
+  state_vu_mnemonic_bc = -1;
+  state_vif_mpgloc = -1;
+  state_vif_mpgloc_star_p = 0;
+  state_vif_len = -1;
+  state_vif_data_file = NULL;
+  state_vif_data_len = 0;
+  state_gif_nregs = -1;
+  state_gif_nloop = -1;
+}
+
+/* Called by the disassembler before printing an instruction.  */
+
+void
+dvp_opcode_init_print ()
+{
+  state_vu_mnemonic_dest = -1;
+  state_vu_mnemonic_bc = -1;
+  state_vif_len = -1;
+  state_gif_nregs = -1;
+  state_gif_nloop = -1;
+}
+
+
+/* Indexed by first letter of opcode.  Points to chain of opcodes with same
+   first letter.  */
+/* ??? One can certainly use a better hash.  Later.  */
+static dvp_opcode *upper_opcode_map[26 + 1];
+static dvp_opcode *lower_opcode_map[26 + 1];
+
+/* Indexed by insn code.  Points to chain of opcodes with same insn code.  */
+static dvp_opcode *upper_icode_map[(1 << DVP_ICODE_HASH_SIZE) - 1];
+static dvp_opcode *lower_icode_map[(1 << DVP_ICODE_HASH_SIZE) - 1];
+
+
+/* Initialize any tables that need it.
+   Must be called once at start up (or when first needed).
+
+   FLAGS is currently unused but is intended to control initialization.  */
+
+void
+dvp_opcode_init_tables (void)
+{
+  static int init_p = 0;
+
+  /* We may be intentionally called more than once (for example gdb will call
+     us each time the user switches cpu).  These tables only need to be init'd
+     once though.  */
+  /* ??? We can remove the need for dvp_opcode_supported by taking it into
+     account here, but I'm not sure I want to do that yet (if ever).  */
+  if (!init_p)
+    {
+      int i;
+
+      /* Upper VU table.  */
+
+      memset (upper_opcode_map, 0, sizeof (upper_opcode_map));
+      memset (upper_icode_map, 0, sizeof (upper_icode_map));
+      /* Scan the table backwards so macros appear at the front.  */
+      for (i = vu_upper_opcodes_count - 1; i >= 0; --i)
+	{
+	  int opcode_hash = DVP_HASH_UPPER_OPCODE (vu_upper_opcodes[i].mnemonic);
+	  int icode_hash = DVP_HASH_UPPER_ICODE (vu_upper_opcodes[i].value);
+
+	  vu_upper_opcodes[i].next_asm = upper_opcode_map[opcode_hash];
+	  upper_opcode_map[opcode_hash] = &vu_upper_opcodes[i];
+
+	  vu_upper_opcodes[i].next_dis = upper_icode_map[icode_hash];
+	  upper_icode_map[icode_hash] = &vu_upper_opcodes[i];
+	}
+
+      /* Lower VU table.  */
+
+      memset (lower_opcode_map, 0, sizeof (lower_opcode_map));
+      memset (lower_icode_map, 0, sizeof (lower_icode_map));
+      /* Scan the table backwards so macros appear at the front.  */
+      for (i = vu_lower_opcodes_count - 1; i >= 0; --i)
+	{
+	  int opcode_hash = DVP_HASH_LOWER_OPCODE (vu_lower_opcodes[i].mnemonic);
+	  int icode_hash = DVP_HASH_LOWER_ICODE (vu_lower_opcodes[i].value);
+
+	  vu_lower_opcodes[i].next_asm = lower_opcode_map[opcode_hash];
+	  lower_opcode_map[opcode_hash] = &vu_lower_opcodes[i];
+
+	  vu_lower_opcodes[i].next_dis = lower_icode_map[icode_hash];
+	  lower_icode_map[icode_hash] = &vu_lower_opcodes[i];
+	}
+
+      /* FIXME: We just hash everything to the same value for the rest.
+	 Quick hack while other things are worked on.  */
+
+      /* VIF table.  */
+
+      for (i = vif_opcodes_count - 2; i >= 0; --i)
+	{
+	  vif_opcodes[i].next_asm = & vif_opcodes[i+1];
+	  vif_opcodes[i].next_dis = & vif_opcodes[i+1];
+	}
+
+      /* DMA table.  */
+
+      for (i = dma_opcodes_count - 2; i >= 0; --i)
+	{
+	  dma_opcodes[i].next_asm = & dma_opcodes[i+1];
+	  dma_opcodes[i].next_dis = & dma_opcodes[i+1];
+	}
+
+      /* GIF table.  */
+
+      for (i = gif_opcodes_count - 2; i >= 0; --i)
+	{
+	  gif_opcodes[i].next_asm = & gif_opcodes[i+1];
+	  gif_opcodes[i].next_dis = & gif_opcodes[i+1];
+	}
+
+      init_p = 1;
+    }
+}
+
+/* Return the first insn in the chain for assembling upper INSN.  */
+
+const dvp_opcode *
+vu_upper_opcode_lookup_asm (insn)
+     const char *insn;
+{
+  return upper_opcode_map[DVP_HASH_UPPER_OPCODE (insn)];
+}
+
+/* Return the first insn in the chain for disassembling upper INSN.  */
+
+const dvp_opcode *
+vu_upper_opcode_lookup_dis (insn)
+     DVP_INSN insn;
+{
+  return upper_icode_map[DVP_HASH_UPPER_ICODE (insn)];
+}
+
+/* Return the first insn in the chain for assembling lower INSN.  */
+
+const dvp_opcode *
+vu_lower_opcode_lookup_asm (insn)
+     const char *insn;
+{
+  return lower_opcode_map[DVP_HASH_LOWER_OPCODE (insn)];
+}
+
+/* Return the first insn in the chain for disassembling lower INSN.  */
+
+const dvp_opcode *
+vu_lower_opcode_lookup_dis (insn)
+     DVP_INSN insn;
+{
+  return lower_icode_map[DVP_HASH_LOWER_ICODE (insn)];
+}
+
+/* Return the first insn in the chain for assembling lower INSN.  */
+
+const dvp_opcode *
+vif_opcode_lookup_asm (insn)
+     const char *insn __attribute__((unused));
+{
+  return &vif_opcodes[0];
+}
+
+/* Return the first insn in the chain for disassembling lower INSN.  */
+
+const dvp_opcode *
+vif_opcode_lookup_dis (insn)
+     DVP_INSN insn __attribute__((unused));
+{
+  return &vif_opcodes[0];
+}
+
+/* Return the first insn in the chain for assembling lower INSN.  */
+
+const dvp_opcode *
+dma_opcode_lookup_asm (insn)
+     const char *insn __attribute__((unused));
+{
+  return &dma_opcodes[0];
+}
+
+/* Return the first insn in the chain for disassembling lower INSN.  */
+
+const dvp_opcode *
+dma_opcode_lookup_dis (insn)
+     DVP_INSN insn __attribute__((unused));
+{
+  return &dma_opcodes[0];
+}
+
+/* Return the first insn in the chain for assembling lower INSN.  */
+
+const dvp_opcode *
+gif_opcode_lookup_asm (insn)
+     const char *insn __attribute__((unused));
+{
+  return &gif_opcodes[0];
+}
+
+/* Return the first insn in the chain for disassembling lower INSN.  */
+
+const dvp_opcode *
+gif_opcode_lookup_dis (insn)
+     DVP_INSN insn __attribute__((unused));
+{
+  return &gif_opcodes[0];
+}
+
+
+/* Misc. utilities.  */
+
+/* Scan a symbol and return a pointer to one past the end.  */
+
+static char *
+scan_symbol (sym)
+     char *sym;
+{
+  while (*sym && issymchar (*sym))
+    ++sym;
+  return sym;
+}
+
+/* Given a keyword, look up its value, or -1 if not found.  */
+
+static int
+lookup_keyword_value (table, name, case_sensitive_p)
+     const keyword *table;
+     const char *name;
+     int case_sensitive_p;
+{
+  const keyword *p;
+
+  if (case_sensitive_p)
+    {
+      for (p = table; p->name; ++p)
+	if (strcmp (name, p->name) == 0)
+	  return p->value;
+    }
+  else
+    {
+      for (p = table; p->name; ++p)
+	if (strcasecmp (name, p->name) == 0)
+	  return p->value;
+    }
+
+  return -1;
+}
+
+/* Given a keyword's value, look up its name, or NULL if not found.  */
+
+static const char *
+lookup_keyword_name (table, value)
+     const keyword *table;
+     int value;
+{
+  const keyword *p;
+
+  for (p = table; p->name; ++p)
+    if (value == p->value)
+      return p->name;
+
+  return NULL;
+}
+
+
+/* Macro insn support.  */
+
+/* Given a string, see if it's a macro insn and return the expanded form.
+   If not a macro insn, return NULL.
+   The expansion is done in malloc'd space.
+   It is up to the caller to free it.  */
+
+char *
+dvp_expand_macro (mactable, tabsize, insn)
+     const dvp_macro * mactable;
+     int tabsize;
+     char *insn;
+{
+  const dvp_macro * m, *mend;
+  char * operands[10];
+  int oplens[10];
+  int noperands = 0;
+
+  for (m = mactable, mend = mactable + tabsize; m < mend; ++m)
+    {
+      const char * p = m->template;
+      char * ip = insn;
+
+      for (;;)
+	{
+	  while (*p && *p == *ip)
+	    ++p, ++ip;
+
+	  /* Did we find a complete match?  */
+	  if (*p == 0 && *ip == 0)
+	    {
+	      int total_len = strlen (m->result);
+	      int i;
+	      char * result;
+
+	      for (i = 0; i < noperands; ++i)
+		total_len += strlen (operands[i]);
+	      total_len += 1 + 10  /* slop */;
+	      result = xmalloc (total_len);
+	      for (ip = result, p = m->result; *p; )
+		{
+		  if (*p == '%')
+		    {
+		      /* Ok, we shouldn't assume max 10 operands.  */
+		      int opnum = *++p - '0';
+		      memcpy (ip, operands[opnum], oplens[opnum]);
+		      ++p;
+		      ip += oplens[opnum];
+		    }
+		  else
+		    {
+		      *ip++ = *p++;
+		    }
+		}
+	      if (ip - result >= total_len)
+		abort ();
+	      *ip = 0;
+	      return result;
+	    }
+
+	  /* Is this an operand?  */
+	  if (*p == '$' && p[1] == '{')
+	    {
+	      if (strncmp (p + 2, "imrubits}", 9) == 0)
+		{
+		  if (*ip == '[')
+		    {
+		      char *q = ip;
+		      while (*q && *q != ']')
+			++q;
+		      if (! *q)
+			return NULL;
+		      ++q;
+		      operands[noperands] = ip;
+		      oplens[noperands++] = q - ip;
+		      ip = q;
+		    }
+		  else
+		    {
+		      operands[noperands] = "";
+		      oplens[noperands++] = 0;
+		    }
+		}
+	      else if (strncmp (p + 2, "wl}", 3) == 0
+		       || strncmp (p + 2, "cl}", 3) == 0
+		       || strncmp (p + 2, "unpacktype}", 11) == 0
+		       || strncmp (p + 2, "unpackloc}", 10) == 0
+		       || strncmp (p + 2, "datalen}", 8) == 0)
+		{
+		  char *q = ip;
+		  while (*q && *q != ',')
+		    ++q;
+		  operands[noperands] = ip;
+		  oplens[noperands++] = q - ip;
+		  ip = q;
+		}
+	      else
+		abort ();
+
+	      /* Skip to end of operand in template.  */
+	      p = strchr (p, '}');
+	      if (! p)
+		abort ();
+	      ++p;
+	    }
+	  else
+	    break;
+	}
+    }
+
+  return NULL;
+}
diff -burNpd binutils-2.25.1.orig/opcodes/mips-dis.c binutils-2.25.1.PS2/opcodes/mips-dis.c
--- binutils-2.25.1.orig/opcodes/mips-dis.c	2014-10-14 02:32:04.000000000 -0500
+++ binutils-2.25.1.PS2/opcodes/mips-dis.c	2019-12-27 15:50:33.411645875 -0600
@@ -2356,6 +2356,19 @@ _print_insn_mips (bfd_vma memaddr,
   bfd_byte buffer[INSNLEN];
   int status;
 
+#ifdef ARCH_dvp
+  {
+    /* bfd_mach_dvp_p is a macro which may evaluate its arguments more than  
+       once.  Since dvp_mach_type is a function, ensure it's only called  
+       once.  */
+    int mach = dvp_info_mach_type (info);
+
+    if (bfd_mach_dvp_p (info->mach)
+        || bfd_mach_dvp_p (mach))
+      return print_insn_dvp (memaddr, info);
+  }
+#endif  
+
   set_default_mips_dis_options (info);
   parse_mips_dis_options (info->disassembler_options);
 
